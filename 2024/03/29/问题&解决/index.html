

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Homo vexillues">
  <script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
  <meta name="keywords" content="">
  
    <meta name="description" content=".db文件是啥 .db文件是sqlite的数据库文件，通常用于存储和管理数据  方法和函数的区别是什么？ 一般在面向对象的语言中，这个被称为方法，面向过程语言中被称为函数，没啥太大区别，都是接收输入的数据并返回数据 仅有的一点区别是：方法与其被调用的对象实例相关联，方法仅限于在其所包含的类中操作数据 在C++中可以创建与对象关联的函数，被称为成员函数，在其它语言中就是方法  C语言有没有修饰访问符">
<meta property="og:type" content="article">
<meta property="og:title" content="问题&amp;解决">
<meta property="og:url" content="https://homovexillues.github.io/2024/03/29/%E9%97%AE%E9%A2%98&%E8%A7%A3%E5%86%B3/index.html">
<meta property="og:site_name" content="红石门">
<meta property="og:description" content=".db文件是啥 .db文件是sqlite的数据库文件，通常用于存储和管理数据  方法和函数的区别是什么？ 一般在面向对象的语言中，这个被称为方法，面向过程语言中被称为函数，没啥太大区别，都是接收输入的数据并返回数据 仅有的一点区别是：方法与其被调用的对象实例相关联，方法仅限于在其所包含的类中操作数据 在C++中可以创建与对象关联的函数，被称为成员函数，在其它语言中就是方法  C语言有没有修饰访问符">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://homovexillues.github.io/images/%E9%97%AE%E9%A2%98&%E8%A7%A3%E5%86%B3/v2-86d3f4d428d8e1664d59c97ee6ff909d_1440w-1715759664937-3.webp">
<meta property="og:image" content="https://homovexillues.github.io/images/%E9%97%AE%E9%A2%98&%E8%A7%A3%E5%86%B3/image-20250329231632185.png">
<meta property="og:image" content="https://homovexillues.github.io/images/%E9%97%AE%E9%A2%98&%E8%A7%A3%E5%86%B3/image-20250329231714549.png">
<meta property="og:image" content="https://homovexillues.github.io/images/%E9%97%AE%E9%A2%98&%E8%A7%A3%E5%86%B3/image-20250329231736194.png">
<meta property="article:published_time" content="2024-03-29T01:51:22.492Z">
<meta property="article:modified_time" content="2025-07-01T07:06:43.971Z">
<meta property="article:author" content="Homo vexillues">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://homovexillues.github.io/images/%E9%97%AE%E9%A2%98&%E8%A7%A3%E5%86%B3/v2-86d3f4d428d8e1664d59c97ee6ff909d_1440w-1715759664937-3.webp">
  
  
  
  <title>问题&amp;解决 - 红石门</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"homovexillues.github.io","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>红石门</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="问题&amp;解决"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-03-29 09:51" pubdate>
          2024年3月29日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          35k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          291 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">问题&amp;解决</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="db文件是啥"><a href="#db文件是啥" class="headerlink" title=".db文件是啥"></a>.db文件是啥</h2><ul>
<li>.db文件是sqlite的数据库文件，通常用于存储和管理数据</li>
</ul>
<h2 id="方法和函数的区别是什么？"><a href="#方法和函数的区别是什么？" class="headerlink" title="方法和函数的区别是什么？"></a>方法和函数的区别是什么？</h2><ul>
<li>一般在面向对象的语言中，这个被称为方法，面向过程语言中被称为函数，没啥太大区别，都是接收输入的数据并返回数据</li>
<li>仅有的一点区别是：方法与其被调用的对象实例相关联，方法仅限于在其所包含的类中操作数据</li>
<li>在C++中可以创建与对象关联的函数，被称为成员函数，在其它语言中就是方法</li>
</ul>
<h2 id="C语言有没有修饰访问符？C语言该如何进行封装？"><a href="#C语言有没有修饰访问符？C语言该如何进行封装？" class="headerlink" title="C语言有没有修饰访问符？C语言该如何进行封装？"></a>C语言有没有修饰访问符？C语言该如何进行封装？</h2><ul>
<li>C语言没有修饰访问符</li>
</ul>
<h2 id="写法是什么意思？"><a href="#写法是什么意思？" class="headerlink" title="///&lt;summary&gt;...&lt;/summary&gt;写法是什么意思？"></a><code>///&lt;summary&gt;...&lt;/summary&gt;</code>写法是什么意思？</h2><ul>
<li>这是一种特殊的注释，被称为XML文档注释，这种注释可以被VisualStudio的IntelliSense（智能感知）和其他工具用来生成代码的文档</li>
<li>可以在属性、方法等前面输入&#x2F;&#x2F;&#x2F;来自动生成这种注</li>
</ul>
<h2 id="什么是数据回写？自动化项目中的数据回写有什么用？"><a href="#什么是数据回写？自动化项目中的数据回写有什么用？" class="headerlink" title="什么是数据回写？自动化项目中的数据回写有什么用？"></a>什么是数据回写？自动化项目中的数据回写有什么用？</h2><h2 id="什么是匿名函数？"><a href="#什么是匿名函数？" class="headerlink" title="什么是匿名函数？"></a>什么是匿名函数？</h2><h2 id="text和-txt有什么区别？"><a href="#text和-txt有什么区别？" class="headerlink" title=".text和.txt有什么区别？"></a>.text和.txt有什么区别？</h2><ul>
<li>没啥区别，文件扩展名不是文件格式，扩展名只是为了方便人快速识别文件格式和Windows上用于关联打开程序，只是一种约定而已，不代表文件本身格式，就像是将.zip文件扩展名改为.txt一样，不会影响文件本身内容</li>
</ul>
<h2 id="如何完全卸载influxdb"><a href="#如何完全卸载influxdb" class="headerlink" title="如何完全卸载influxdb"></a>如何完全卸载influxdb</h2><pre><code class="hljs">- 在C盘的用户文件夹下有`.influxdbv2`文件夹，删除，任务管理器停止后台进程
</code></pre>
<h2 id="当前上下文中不存在名称“Console-WriteLine”是什么情况"><a href="#当前上下文中不存在名称“Console-WriteLine”是什么情况" class="headerlink" title="当前上下文中不存在名称“Console.WriteLine”是什么情况"></a>当前上下文中不存在名称“Console.WriteLine”是什么情况</h2><ul>
<li><p>命名空间未被引用——开头没有using System</p>
</li>
<li><p>大小写拼写错误</p>
</li>
<li><p>错误的上下文使用：Console.WriteLine是一个静态方法，它只能在方法内部使用，如果在类的定义中，但不在任何方法体内部去使用它，就会收到这个错误。</p>
</li>
<li><p>- </p>
</li>
<li><p>什么是回写？</p>
<ul>
<li>将数据读到内存上处理，处理之后写到硬盘上，这就是回写。</li>
</ul>
</li>
<li><p>.dll文件和python库之间有什么关系？</p>
<ul>
<li>.dll文件是动态链接库（Dynamic Link Library）的缩写，它包含了可以被多个程序共享的代码和数据。这些库通常是用C或C++编写的。</li>
<li>如<code>numpy</code>库的源代码中有大量的C代码，这些代码在安装numpy库的时候会被编译为动态链接库。然后在python中通过import numpy调用库的时候，python会加载动态链接库，并将其中国的函数和数据结构结构映射到python的命名空间中。</li>
<li>如调用numpy.arrary()的时候，实际上是在调用一个C语言实现的函数。这个函数会在C语言的环境中执行，然后将结果返回给python。</li>
</ul>
</li>
<li><p>在判断中，is not null和!&#x3D;null有什么区别吗？</p>
<ul>
<li><p>在大多数编程语言中没啥区别</p>
</li>
<li><p>在SQL中，这两者有重要区别。NULL是一种特殊的值，表示未知或缺失的数据。因此，NULL与任何值，包括NULL自己的比较结果都是未知的，即<code>NULL=NULL</code>和<code>NULL!=NULL</code>都不会返回<code>true</code></p>
</li>
<li><p>因此当想要检查一个字段是否为<code>NULL</code>的时候，应该用<code>IS NULL</code>或<code>IS NOT NULL</code>。</p>
</li>
<li><p>如<code>WHERE column IS NOT NULL</code>会选取那些column字段不为NULL的行。</p>
</li>
</ul>
</li>
<li><p>.yaml .json .xml文件格式各自用于做什么？有什么使用上要注意的事？</p>
<ul>
<li><strong>JSON（JavaScript Object Notation）</strong>：json简介易读，适用于API的请求和响应。它是一种轻量级的数据交换格式，易于人阅读和编写，同时也易于机器解析和生成。JSON采用完全独立于语言的文本格式，使得JSON成为理想的数据交换语言。</li>
<li><strong>XML(eXtensible Markup Language)</strong>: XML具有跨平台和跨语言的优点，适用于Web服务和RSS源。它是一种标记语言，可以用来编码文档和数据。XML的设计目标是强调通用性和简单性。尽管XML的使用在web上的数据序列化的用途已经减少，但它仍然被广泛用于存储和传输数据。</li>
<li><strong>YAML(YAML Ain’t Markup Language)<strong>：YAML适合用于需要人类可读的数据表示场景，如配置文件和日志文件。YAML是一种人类友好的数据序列化标注，它允许在不同语言之间交换数据。</strong>YAML是对JSON的超集，因此任何JSON文件都应该能够用YAML解析器解析</strong>。</li>
<li>XML用<strong>标记</strong>来定义结构数据，就像html那样</li>
<li>YAML使用<strong>缩进</strong>来定义结构化数据。就像python</li>
<li>JSON使用的是<strong>冒号和大括号</strong>来定义结构化数据</li>
<li><strong>数据传输</strong>的时候，XML和JSON很常见，尤其是<strong>JSON</strong>，在<strong>API</strong>的开发中变得非常普及</li>
<li><strong>文件大小</strong>上来说，同样的<strong>数据集</strong>。<strong>YAML文件最小，JSON次之，XML最大</strong></li>
<li><strong>学习难度上来说</strong>，<strong>YAML最难，JSON和XML相对简单</strong></li>
</ul>
</li>
<li><p>目前的这些主流语言的设计目的和初衷都是什么？</p>
</li>
<li><p>.ico文件和.resx文件是啥？.config文件一般是什么格式的？</p>
<ul>
<li><strong>.ico</strong>:图标文件</li>
<li><strong>.resx</strong>:资源文件格式，用于存储本地化字符串、图像和其他资源。通常用于.NET Framework应用程序，以便用于管理和本地化应用程序的资源。</li>
<li><strong>.config</strong>:在.NET应用程序中，包含应用程序的设置，如数据库连接字符串，应用该程序设置等。XML格式，允许开发者以结构化的方式定义配置选项。</li>
</ul>
</li>
<li><p>什么是组件？</p>
</li>
<li><p>什么是fody框架？</p>
<ul>
<li>一个针对.NET平台的IL（intermediate language）编织工具，允许开发人员在代码编译过程中对代码进行自动化的注入和修改，以实现一些常见的横切关注点</li>
</ul>
</li>
<li><h2 id="什么是横切关注点（Cross-cutting-conerns）？"><a href="#什么是横切关注点（Cross-cutting-conerns）？" class="headerlink" title="什么是横切关注点（Cross-cutting conerns）？"></a>什么是横切关注点（Cross-cutting conerns）？</h2></li>
<li><p>什么是ping&amp;pong?(计算机网络相关，非游戏)</p>
<ul>
<li>用来描述一种简单的请求&#x2F;响应模式，其中两个<strong>设备</strong>或<strong>进程</strong>之间进行基本的通信。</li>
<li>涉及到以下几个概念：<ul>
<li><strong>ICMP回显请求&#x2F;回显应答</strong>：<ul>
<li>最常见的ping-pong是ICMP（Internet control message protocol）的ping命令。一台设备发送一个ICMP回显请求消息给另一台设备，接收设备在收到请求后返返回一个ICMP回显应答消息。</li>
</ul>
</li>
<li><strong>TCP握手过程</strong>:<ul>
<li>在TCP（Transmission Control Protocol）连接建立过程中，也有ping-pong操作。最著名的是三次握手过程，客户端发送一个SYN（Synchronize Sequence Numbers）同步序列编号消息给服务器以开始连接服务器回复一个SYN-ACK同步-确认消息，最后客户端发送ACK确认消息完成连接建立</li>
</ul>
</li>
<li><strong>应用层协议</strong>:<ul>
<li>许多应用层协议，如HTTP或FTP，也使用请求&#x2F;响应模式。客户端发送一个请求到服务器，服务器处理请求并返回一个响应。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="什么是网桥"><a href="#什么是网桥" class="headerlink" title="什么是网桥"></a>什么是网桥</h2><ul>
<li><p>一种网络设备，用于连接两个或多个局域网LAN并转发数据帧frame。网桥工作在OSI参考模型的数据链路层，主要用于在同一网络协议下连接两个或多个局域网，使他们成为一个逻辑上的网络。</p>
</li>
<li><p>没错，看完了上面的定义会让人想起交换机，现代网络中，网桥通常被交换机取代，交换机具有与网桥类似的功能，但性能更好、管理更简单。概念上，交换机可以看作是多端口的网桥。</p>
</li>
<li><p><strong>主要功能包括</strong>: </p>
<ul>
<li><strong>帧过滤</strong>：</li>
<li><strong>学习</strong></li>
<li><strong>转发</strong></li>
<li><strong>环路检测</strong></li>
<li><strong>隔离</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>主要工作流程:</p>
<ul>
<li><strong>学习阶段</strong><ul>
<li>当网桥首次启动时，它开始学习阶段，通过接收网络上的数据帧来学习每个设备的MAC地址</li>
<li>网桥通过检查进入数据帧中的源MAC地址来学习这些地址，并记录这些MAC地址与数据帧到达的端口之间的关联。</li>
</ul>
</li>
</ul>
<h2 id="什么是4G模块"><a href="#什么是4G模块" class="headerlink" title="什么是4G模块"></a>什么是4G模块</h2><p>  <img src="/../images/%E9%97%AE%E9%A2%98&%E8%A7%A3%E5%86%B3/v2-86d3f4d428d8e1664d59c97ee6ff909d_1440w-1715759664937-3.webp" srcset="/img/loading.gif" lazyload alt="img"></p>
<ul>
<li><p>4G模块是一种用于实现无线网络连接的设备，它可以让设备通过4G网络（第四代移动通信技术）进行数据通信。这种模块通常被集成到设备中，例如智能手机、平板电脑、物联网设备等，以实现无线互联网连接。</p>
</li>
<li><p>4G模块通常包括: </p>
<ul>
<li><strong>调制解调器</strong></li>
<li><strong>天线</strong></li>
<li><strong>SIM卡槽</strong></li>
<li><strong>处理器和存储器</strong></li>
</ul>
</li>
</ul>
<h2 id="什么是调制解调器（Modem）？"><a href="#什么是调制解调器（Modem）？" class="headerlink" title="什么是调制解调器（Modem）？"></a>什么是调制解调器（Modem）？</h2><ul>
<li>将数字信号转换为模拟信号（<strong>调制</strong>）将模拟信号转换为数字信号（<strong>解调</strong>）</li>
<li>在数字通信中，数据通常是以数字形式存在的，如二进制数据，但是，许多通信介质（电话线、光纤、无线电波）中，传递的是模拟信号，要转这么一手。</li>
</ul>
<h2 id="为什么4G模块每次上线都会获得一个新的IP地址"><a href="#为什么4G模块每次上线都会获得一个新的IP地址" class="headerlink" title="为什么4G模块每次上线都会获得一个新的IP地址"></a>为什么4G模块每次上线都会获得一个新的IP地址</h2><ul>
<li>在移动通信网络中，运营山通常采用动态IP地址分配的方式，即每次设备连接到网络时，运营商会从其IP地址池中动态分配一个可用的IP地址给设备使用。这种动态分配的IP地址通常具有一定的生命周期，一旦设备断开连接或一段时间未使用，分配的IP地址就会被释放，返回到IP地址池中供其他设备使用。</li>
</ul>
<h2 id="MQTT是什么？"><a href="#MQTT是什么？" class="headerlink" title="MQTT是什么？"></a>MQTT是什么？</h2><ul>
<li><p>Message Queuing Telemetry Transport 消息队列遥测传输，在应用层</p>
</li>
<li><p>一种轻量级的、开放式的、基于发布&#x2F;订阅模式的通信协议，用于物联网(loT)和机器到机器（M2M）通信。</p>
</li>
<li><p>MQTT协议的特点包括：</p>
<ol>
<li><strong>轻量级</strong>：MQTT协议设计简洁，通信开销小，适用于资源受限的设备和网络环境，如传感器、嵌入式设备、移动设备等。</li>
<li><strong>发布&#x2F;订阅模式</strong>：MQTT使用发布&#x2F;订阅模式进行消息传递，消息发送者（发布者）将消息发布到特定的主题（Topic），消息接收者（订阅者）通过订阅特定的主题来接收消息。这种模式使得设备之间可以进行松耦合的通信，易于扩展和管理。</li>
<li><strong>可靠性</strong>：MQTT支持不同级别的消息传递质量（QoS），包括最多一次（QoS 0）、至少一次（QoS 1）和仅一次（QoS 2），可根据应用需求选择适当的消息传递质量级别。</li>
<li><strong>持久性</strong>：MQTT支持持久会话和持久订阅，使得设备断线后可以恢复之前的会话状态和订阅关系。</li>
<li><strong>安全性</strong>：MQTT协议支持基于TLS&#x2F;SSL的加密通信和基于用户名和密码的身份认证，保障通信的安全性和隐私性。</li>
</ol>
</li>
</ul>
<h2 id="什么是寄存器（Register）？"><a href="#什么是寄存器（Register）？" class="headerlink" title="什么是寄存器（Register）？"></a>什么是寄存器（Register）？</h2><h2 id="什么是PLC（Programmable-Logic-Controller）？"><a href="#什么是PLC（Programmable-Logic-Controller）？" class="headerlink" title="什么是PLC（Programmable Logic Controller）？"></a>什么是PLC（Programmable Logic Controller）？</h2><pre><code class="hljs">- 一种借鉴了冯诺依曼机的专为工业自动化控制设计和优化的专用计算设备
</code></pre>
</li>
</ul>
<h2 id="原语是什么意思？"><a href="#原语是什么意思？" class="headerlink" title="原语是什么意思？"></a>原语是什么意思？</h2><pre><code class="hljs">- 在计算机科学中，原语通常是指操作系统提供的一些基本的、不可分割的操作，这些操作作为系统调用供用户程序使用。如进程控制、信号、文件操作等可以被视为原语。


- 在编程语言中，原语也可以指最基本的操作或函数，它们是构建更复杂程序的基础。
</code></pre>
<h2 id="什么是组件的连接字（Component-Connector）？"><a href="#什么是组件的连接字（Component-Connector）？" class="headerlink" title="什么是组件的连接字（Component Connector）？"></a>什么是组件的连接字（Component Connector）？</h2><ul>
<li><p>一个软件架构和设计模式中的术语，形容不同组件或模块之间相互连接和通信的机制或接口</p>
<ul>
<li><strong>接口（Interface）</strong>：<ul>
<li>在面向对象编程中，接口定义了一组方法和属性，组件通过实现这些接口来进行通信。</li>
</ul>
</li>
<li><strong>API（应用程序编程接口）</strong>：<ul>
<li>API是一组预定义的函数、协议和工具，用于构建软件应用。组件通过调用API来实现交互。</li>
</ul>
</li>
<li><strong>服务（Service）</strong>：<ul>
<li>在服务导向架构（SOA）或微服务架构中，服务作为独立的业务功能单元，组件通过服务调用来交互。</li>
</ul>
</li>
<li><strong>消息队列（Message Queue）</strong>：<ul>
<li>组件通过发送和接收消息来进行异步通信，消息队列是这种通信方式的典型实现。</li>
</ul>
</li>
<li><strong>事件（Event）</strong>：<ul>
<li>组件可以基于事件来通信，其中某个组件触发事件，其他组件监听并响应这些事件。</li>
</ul>
</li>
<li><strong>管道（Pipe）</strong>：<ul>
<li>在某些系统设计中，管道可以作为进程间通信的手段，允许数据从一个进程流向另一个进程。</li>
</ul>
</li>
<li><strong>套接字（Socket）</strong>：<ul>
<li>网络编程中，套接字用于在网络中的不同主机上的组件之间建立通信。</li>
</ul>
</li>
<li><strong>数据库（Database）</strong>：<ul>
<li>组件可以通过数据库来共享数据，数据库作为一个共享的存储机制，允许组件进行读写操作。</li>
</ul>
</li>
<li><strong>文件系统（File System）</strong>：<ul>
<li>组件可以通过读写文件来交换数据，文件系统在这里充当连接字的角色。</li>
</ul>
</li>
<li><strong>通信协议（Communication Protocol）</strong>：<ul>
<li>在网络通信中，如TCP&#x2F;IP、HTTP等协议定义了数据传输的规则，是组件间通信的基础。</li>
</ul>
</li>
<li><strong>中间件（Middleware）</strong>：<ul>
<li>中间件提供了一种在不同系统或组件之间传递数据的方法，它可以处理不同系统之间的通信细节。</li>
</ul>
</li>
</ul>
</li>
<li><p>在DBeaver上配置数据库到底是怎样的过程？DBeaver这个软件的作用又是什么？</p>
<ul>
<li>商业版本可以支持各种 NoSQL 和大数据平台：MongoDB、InfluxDB、Apache Cassandra、Redis、Apache Hive 等。</li>
</ul>
<h2 id="什么是套接字（Socket）？"><a href="#什么是套接字（Socket）？" class="headerlink" title="什么是套接字（Socket）？"></a>什么是套接字（Socket）？</h2><ul>
<li>是网络通信的一个基本概念和工具，它提供了在计算机网络中进行数据交换的端点</li>
</ul>
<h2 id="什么是上位机？"><a href="#什么是上位机？" class="headerlink" title="什么是上位机？"></a>什么是上位机？</h2><h2 id="什么是端口转发？什么是内网穿透？二者有什么异同？"><a href="#什么是端口转发？什么是内网穿透？二者有什么异同？" class="headerlink" title="什么是端口转发？什么是内网穿透？二者有什么异同？"></a>什么是端口转发？什么是内网穿透？二者有什么异同？</h2><ul>
<li>端口转发 （Port ForWarding）</li>
</ul>
<h2 id="什么是注册表？"><a href="#什么是注册表？" class="headerlink" title="什么是注册表？"></a>什么是注册表？</h2><ul>
<li>一个硬盘上的数据库，存着window和安装的软件的设置</li>
</ul>
<h2 id="Windows的回收站是个什么设定？"><a href="#Windows的回收站是个什么设定？" class="headerlink" title="Windows的回收站是个什么设定？"></a>Windows的回收站是个什么设定？</h2><ul>
<li>每个盘符有一定的空间存放，文件被删除后不是直接从硬盘上消失，而是被标注为可覆盖</li>
</ul>
<h2 id="Linux是否有回收站机制？"><a href="#Linux是否有回收站机制？" class="headerlink" title="Linux是否有回收站机制？"></a>Linux是否有回收站机制？</h2><ul>
<li>无</li>
</ul>
<h2 id="什么是缓存锁（Cache-Locking）？"><a href="#什么是缓存锁（Cache-Locking）？" class="headerlink" title="什么是缓存锁（Cache Locking）？"></a>什么是缓存锁（Cache Locking）？</h2><ul>
<li>一种用于控制对共享资源的访问机制，特别是在多线程或分布式系统中。当多个进程或线程需要访问相同的数据时，缓存锁可以确保</li>
</ul>
<h2 id="什么是双向转发（Two-way-Forwarding）？"><a href="#什么是双向转发（Two-way-Forwarding）？" class="headerlink" title="什么是双向转发（Two-way Forwarding）？"></a>什么是双向转发（Two-way Forwarding）？</h2><ul>
<li>双向转发通常是在网络通信中，数据可以在两个方向上进行传输，即发送</li>
</ul>
<h2 id="什么是有限状态机？"><a href="#什么是有限状态机？" class="headerlink" title="什么是有限状态机？"></a>什么是有限状态机？</h2><ul>
<li>有限状态机（Finite State Machine，FSM）是一种计算模型，它由一组状态以及在这些状态之间的转移组成。</li>
</ul>
</li>
<li><p>vs中打包和生成的区别是什么？</p>
<ul>
<li><strong>主要区别</strong>:<ul>
<li><strong>范围</strong>：生成通常只涉及编译源代码，而打包涉及更全面的部署准备过程</li>
<li><strong>依赖项</strong>:打包过程会考虑应用程序的所有依赖性，并确保它们被包含在部署包中</li>
<li><strong>部署</strong>：打包通常是为了直接支持部署，而生成是为了确保代码可以编译成功</li>
<li><strong>配置</strong>:打包可以包含特定的配置选项，如发布配置、目标框架、运行时标识符等</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>MQTT Broker</strong> 是一种服务器，它负责接收来自发布者（Publishers）的消息，并将这些消息分发给订阅了相应主题（Topics）的订阅者（Subscribers）。它的主要功能包括：</p>
<ol>
<li><p><strong>消息路由</strong>：接收发布者发送的消息，并根据订阅者的订阅主题将消息路由到正确的订阅者。</p>
</li>
<li><p><strong>会话管理</strong>：维护客户端连接的会话信息，包括连接状态、订阅信息和消息队列。</p>
</li>
<li><p><strong>消息存储</strong>：存储持久化消息，以便在订阅者不可用时保留消息，并在订阅者恢复连接时传递消息。</p>
</li>
<li><p><strong>质量保证</strong>：根据 QoS（Quality of Service）等级，确保消息按规定的可靠性传递。</p>
<h3 id="MQTT-Broker-的工作原理"><a href="#MQTT-Broker-的工作原理" class="headerlink" title="MQTT Broker 的工作原理"></a>MQTT Broker 的工作原理</h3><ol>
<li><strong>客户端连接</strong>：客户端（包括发布者和订阅者）通过网络连接到 Broker。连接建立后，客户端可以发布消息或订阅主题。</li>
<li><strong>消息发布</strong>：发布者将消息发送到 Broker，并指定一个或多个主题。消息可以携带不同的 QoS 等级，决定消息的传递可靠性。</li>
<li><strong>消息订阅</strong>：订阅者向 Broker 订阅感兴趣的主题。订阅请求可以指定 QoS 等级，决定订阅者希望接收消息的可靠性。</li>
<li><strong>消息路由和分发</strong>：Broker 接收到消息后，根据订阅者的订阅信息，将消息分发给相应的订阅者。</li>
</ol>
<h3 id="QoS（服务质量）等级"><a href="#QoS（服务质量）等级" class="headerlink" title="QoS（服务质量）等级"></a>QoS（服务质量）等级</h3><p>MQTT 定义了三个 QoS 等级，以满足不同的可靠性需求：</p>
<ul>
<li><strong>QoS 0</strong>：至多一次（At most once），消息发送但不确认，不保证消息到达（“最佳努力”传递）。</li>
<li><strong>QoS 1</strong>：至少一次（At least once），消息发送并确认，确保消息至少到达一次，但可能会有重复。</li>
<li><strong>QoS 2</strong>：仅一次（Exactly once），消息发送并通过四步握手确认，确保消息仅到达一次，最可靠但开销最大。</li>
</ul>
<h3 id="常见的-MQTT-Broker-实现"><a href="#常见的-MQTT-Broker-实现" class="headerlink" title="常见的 MQTT Broker 实现"></a>常见的 MQTT Broker 实现</h3><p>有许多开源和商业的 MQTT Broker 实现，以下是一些常见的 MQTT Broker：</p>
<ul>
<li><strong>Mosquitto</strong>：一个轻量级的开源 MQTT Broker，适合嵌入式设备和小型物联网项目。</li>
<li><strong>EMQX</strong>：一个高性能的开源 MQTT Broker，支持大规模并发连接，适合大型物联网项目。</li>
<li><strong>HiveMQ</strong>：一个商业 MQTT Broker，提供企业级功能和支持。</li>
<li><strong>Eclipse Paho</strong>：Eclipse 基金会下的一个开源 MQTT 客户端库和 Broker 项目。</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>MQTT Broker 被广泛应用于物联网（IoT）场景中，包括但不限于：</p>
<ul>
<li><strong>智能家居</strong>：设备之间的通信和控制，如智能灯、智能插座等。</li>
<li><strong>工业自动化</strong>：机器和传感器之间的数据传输和监控。</li>
<li><strong>车联网</strong>：车辆数据的采集和实时传输。</li>
<li><strong>医疗健康</strong>：医疗设备的数据传输和监控。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>MQTT Broker 是 MQTT 协议的核心组件，负责管理消息的传递和分发。通过支持发布&#x2F;订阅模式、QoS 等级和会话管理，MQTT Broker 提供了高效可靠的消息传输机制，适用于各种物联网应用场景。选择合适的 MQTT Broker 取决于项目的规模、性能要求和特定功能需求。</p>
</li>
</ol>
<h2 id="什么是分治（Divide-and-Conquer）"><a href="#什么是分治（Divide-and-Conquer）" class="headerlink" title="什么是分治（Divide and Conquer）"></a>什么是分治（Divide and Conquer）</h2><p>是一种算法设计范式，通过将问题分解为更小的子问题来解决，然后递归地解决这些子问题，并最终将子问题的解结合并形成原问题的解。</p>
<p>- </p>
<h2 id="什么是安装证书"><a href="#什么是安装证书" class="headerlink" title="什么是安装证书"></a>什么是安装证书</h2><ul>
<li><p>安装证书通常指的是在计算机或设备上添加<strong>数字证书</strong>的过程。数字证书是一种用于加密和验证通信的安全性工具，通常用于加密和保护网络通信、网站身份验证等方面。在安装证书的过程中，用户将数字证书文件添加到其操作系统、浏览器或应用程序的信任存储中，以确保与其他实体的安全通信。</p>
<h3 id="安装证书的常见场景"><a href="#安装证书的常见场景" class="headerlink" title="安装证书的常见场景"></a>安装证书的常见场景</h3><ol>
<li><strong>网站身份验证</strong>：Web 浏览器通常会使用数字证书来验证网站的身份。当用户访问一个使用 HTTPS 协议的网站时，网站会向浏览器发送其数字证书，浏览器会验证证书的有效性，并确定是否与信任的证书颁发机构相关联。</li>
<li><strong>电子邮件加密</strong>：在电子邮件通信中，数字证书可以用于加密和签名邮件，确保邮件内容的保密性和完整性。</li>
<li><strong>VPN 连接</strong>：VPN（Virtual Private Network）连接通常需要数字证书来验证用户的身份和加密通信。</li>
</ol>
</li>
</ul>
<ol start="4">
<li><strong>客户端身份验证</strong>：在某些系统中，客户端需要提供数字证书来验证其身份，以访问受限资源或服务。</li>
</ol>
<h3 id="安装证书的步骤"><a href="#安装证书的步骤" class="headerlink" title="安装证书的步骤"></a>安装证书的步骤</h3><p>  安装数字证书通常涉及以下步骤：</p>
<ol>
<li><strong>获取证书</strong>：用户需要获取数字证书文件，通常是由可信任的证书颁发机构（CA）签发的。这些证书可以是网站的 SSL 证书、电子邮件签名证书等。</li>
<li><strong>导入证书</strong>：用户需要将数字证书导入其操作系统、浏览器或应用程序的证书存储中。导入证书的方法取决于所使用的操作系统和软件。</li>
<li><strong>信任证书</strong>：一旦证书被导入，用户可能需要手动将其标记为受信任的证书。这样做可以确保系统或软件信任证书颁发机构签发的证书，并在与其他实体通信时使用它们。</li>
<li><strong>配置选项</strong>：有时，用户可能需要在操作系统、浏览器或应用程序中配置一些选项，以确保数字证书被正确地使用和管理。</li>
</ol>
<h3 id="安全考虑"><a href="#安全考虑" class="headerlink" title="安全考虑"></a>安全考虑</h3><p>在安装数字证书时，需要注意以下安全考虑：</p>
<ul>
<li><p><strong>来源可信性</strong>：确保从可信任的来源获取数字证书，避免使用来自不可信任或未知来源的证书。</p>
<ul>
<li><strong>验证证书有效性</strong>：在安装证书之前，用户应该验证证书的有效性，包括证书的有效期、签发者等信息。</li>
</ul>
</li>
<li><p><strong>保护私钥</strong>：如果证书包含私钥，则需要确保私钥的保密性，以防止未经授权的访问或使用。</p>
<ul>
<li><strong>定期更新</strong>：定期检查和更新证书，以确保其仍然有效，并且与安全最佳实践保持一致。</li>
</ul>
<p>通过正确地安装和管理数字证书，用户可以增强其网络通信的安全性和可信度，并确保与其他实体的安全通信。</p>
</li>
</ul>
</li>
<li><p>var parts &#x3D; content.Split(new string[] { “&amp;&amp;” }, StringSplitOptions.None); 这句话是什么意思</p>
</li>
</ul>
<h3 id="代码部分解释"><a href="#代码部分解释" class="headerlink" title="代码部分解释"></a>代码部分解释</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">csharp<br>复制代码<br><span class="hljs-keyword">var</span> parts = content.<span class="hljs-built_in">Split</span>(<span class="hljs-keyword">new</span> string[] &#123; <span class="hljs-string">&quot;&amp;&amp;&quot;</span> &#125;, StringSplitOptions.<span class="hljs-built_in">None</span>);<br></code></pre></td></tr></table></figure>

<h3 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h3><ol>
<li><strong><code>content</code></strong>:<ul>
<li>这是一个字符串变量，包含需要分割的原始字符串内容。在你的示例中，它是去掉包头和包尾后的HJ212数据字符串。</li>
</ul>
</li>
<li><strong><code>Split</code>方法</strong>:<ul>
<li><code>Split</code>方法是C#中用于将字符串分割成子字符串数组的方法。</li>
</ul>
</li>
<li><strong><code>new string[] &#123; &quot;&amp;&amp;&quot; &#125;</code></strong>:<ul>
<li>这是指定的分隔符数组。在这里，<code>&quot;&amp;&amp;&quot;</code>是用来分割字符串的特定子字符串。</li>
<li><code>new string[] &#123; &quot;&amp;&amp;&quot; &#125;</code>表示创建一个包含一个元素的字符串数组，该元素是<code>&quot;&amp;&amp;&quot;</code>。</li>
</ul>
</li>
<li><strong><code>StringSplitOptions.None</code></strong>:<ul>
<li>这是一个枚举值，指定在分割操作中不忽略空条目。如果指定为<code>StringSplitOptions.RemoveEmptyEntries</code>，则会忽略结果数组中的空字符串。</li>
</ul>
</li>
</ol>
<h2 id="如何获取元组中的变量？"><a href="#如何获取元组中的变量？" class="headerlink" title="如何获取元组中的变量？"></a>如何获取元组中的变量？</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">var</span> (Rtd,Flag) = tuple;<br><span class="hljs-comment">//解构元组</span><br></code></pre></td></tr></table></figure>

<ul>
<li><pre><code class="C#">FiTools.BridgeManager.Bridge: System.OperationCanceledException: The operation was canceled.
   at System.Threading.CancellationToken.ThrowOperationCanceledException()
   at System.Threading.CancellationToken.ThrowIfCancellationRequested()
   at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.ThrowException(SocketError error, CancellationToken cancellationToken)
   at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.System.Threading.Tasks.Sources.IValueTaskSource&lt;System.Net.Sockets.Socket&gt;.GetResult(Int16 token)
   at System.Net.Sockets.TcpListener.&lt;AcceptTcpClientAsync&gt;g__WaitAndWrap|32_0(ValueTask`1 task)
   at FiTools.BridgeManager.Bridge.BeginTcpProxy() in C:\uzone\项目\2024\2024-01 山东港口集团日照港 智慧环保一期\代码\BridgeManager\Bridge.cs:line 75
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>一般这种报错，有多行at的这种是什么原因？要怎么看才能更直观的获得信息？<br><br>- 在 C# 程序中，当异常发生时，通常会有一个堆栈跟踪（stack trace），它列出了异常抛出时调用堆栈的内容。每行 `at` 都表示一个方法调用，从最内层的方法开始，一直到异常抛出的位置。通过分析堆栈跟踪，可以更直观地了解异常是在哪里发生的，以及调用链中的哪些方法可能导致了这个异常。<br><br>  ### 一般性解释<br><br>  堆栈跟踪的每一行 `at` 表示调用堆栈中的一个方法。堆栈跟踪从内到外显示方法调用顺序，最后一行通常是最外层方法，第一行是最内层方法（即异常实际抛出的地方）。<br><br>  ### 示例堆栈跟踪<br><br></code></pre></td></tr></table></figure>
  plaintext复制代码System.OperationCanceledException: The operation was canceled.
     at System.Threading.CancellationToken.ThrowOperationCanceledException()
     at System.Threading.CancellationToken.ThrowIfCancellationRequested()
     at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.ThrowException(SocketError error, CancellationToken cancellationToken)
     at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.System.Threading.Tasks.Sources.IValueTaskSource&lt;System.Net.Sockets.Socket&gt;.GetResult(Int16 token)
     at System.Net.Sockets.TcpListener.&lt;AcceptTcpClientAsync&gt;g__WaitAndWrap|32_0(ValueTask`1 task)
     at FiTools.BridgeManager.Bridge.BeginTcpProxy() in C:\uzone\项目\2024\2024-01 山东港口集团日照港 智慧环保一期\代码\BridgeManager\Bridge.cs:line 75
  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-section">### 分析堆栈跟踪</span><br><br><span class="hljs-bullet">1.</span> <span class="hljs-strong">**异常类型和消息**</span>：<br><br><span class="hljs-bullet">   -</span> <span class="hljs-code">`System.OperationCanceledException: The operation was canceled.`</span> 表示抛出了一个操作取消异常，通常由取消标记（<span class="hljs-code">`CancellationToken`</span>）引发。<br><br><span class="hljs-bullet">2.</span> <span class="hljs-strong">**堆栈跟踪行**</span>：<br><br><span class="hljs-bullet">   -</span> <span class="hljs-code">`at System.Threading.CancellationToken.ThrowOperationCanceledException()`</span> 表示异常在 <span class="hljs-code">`ThrowOperationCanceledException`</span> 方法中抛出。<br><br><span class="hljs-bullet">   -</span> 其他 <br><br></code></pre></td></tr></table></figure>
       at
       <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-code">          行表示调用链中的方法，依次为：</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">         -</span> <span class="hljs-code">`System.Threading.CancellationToken.ThrowIfCancellationRequested()`</span><br><span class="hljs-bullet">         -</span> <span class="hljs-code">`System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.ThrowException(SocketError error, CancellationToken cancellationToken)`</span><br><span class="hljs-bullet">         -</span> <span class="hljs-code">`System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.System.Threading.Tasks.Sources.IValueTaskSource&lt;System.Net.Sockets.Socket&gt;.GetResult(Int16 token)`</span><br><span class="hljs-bullet">         -</span> <span class="hljs-code">`System.Net.Sockets.TcpListener.&lt;AcceptTcpClientAsync&gt;g__WaitAndWrap|32_0(ValueTask`</span>1 task)`<br><span class="hljs-bullet">         -</span> <span class="hljs-code">`FiTools.BridgeManager.Bridge.BeginTcpProxy() in C:\uzone\项目\2024\2024-01 山东港口集团日照港 智慧环保一期\代码\BridgeManager\Bridge.cs:line 75`</span><br><br><span class="hljs-bullet">    3.</span> <span class="hljs-strong">**源代码位置**</span>：<br><br><span class="hljs-bullet">       -</span> 最后一行 <span class="hljs-code">`at FiTools.BridgeManager.Bridge.BeginTcpProxy() in C:\uzone\项目\2024\2024-01 山东港口集团日照港 智慧环保一期\代码\BridgeManager\Bridge.cs:line 75`</span> 提供了源代码文件的路径和行号，表明异常在 <span class="hljs-code">`Bridge.cs`</span> 文件的第 75 行发生。<br><br><span class="hljs-section">## 目前主流的编程语言的初衷是什么？它们的创造者现在如何评价它们？</span><br><br><span class="hljs-section">### 1. C</span><br><br><span class="hljs-strong">**创造者**</span>：丹尼斯·里奇（Dennis Ritchie）<br><span class="hljs-strong">**初衷**</span>：C语言是在1970年代早期由贝尔实验室的丹尼斯·里奇开发的，目的是为开发UNIX操作系统提供一种高效且灵活的语言。C语言继承了B语言的某些特性，并增加了类型系统以提高编程的安全性和表达能力。<br><span class="hljs-strong">**评价**</span>：丹尼斯·里奇认为，C语言成功地达到了他的目标，即提供了一种既接近硬件又适合高级程序设计的语言。它的简单性和效率使其成为系统编程和嵌入式编程的主流语言之一。<br><br><span class="hljs-section">### 2. Java</span><br><br><span class="hljs-strong">**创造者**</span>：詹姆斯·高斯林（James Gosling）<br><span class="hljs-strong">**初衷**</span>：Java语言最初于1990年代初在Sun Microsystems开发，目标是创建一种跨平台的编程语言，能够在不同的设备和操作系统上运行。Java的设计哲学是“写一次，运行到处”（Write Once, Run Anywhere），并且注重安全性和稳定性。<br><span class="hljs-strong">**评价**</span>：詹姆斯·高斯林对Java的评价是，它成功地实现了跨平台的目标，并成为了互联网时代的关键编程语言之一。尽管随着时间推移，Java面临了一些新的挑战和竞争，但其核心理念和影响力依然强大。<br><br><span class="hljs-section">### 3. Python</span><br><br><span class="hljs-strong">**创造者**</span>：吉多·范罗苏姆（Guido van Rossum）<br><span class="hljs-strong">**初衷**</span>：Python语言于1980年代末至1990年代初由吉多·范罗苏姆开发，目的是创建一种易于阅读和使用的编程语言，能够帮助程序员快速开发和调试代码。Python强调简洁和可读性，力求减少程序员的认知负担。<br><span class="hljs-strong">**评价**</span>：吉多·范罗苏姆对Python的发展表示满意，他认为Python在保持简单和易用的同时，已经发展成为一个功能强大的语言，广泛应用于数据科学、人工智能、Web开发等领域。<br><br><span class="hljs-section">### 4. JavaScript</span><br><br><span class="hljs-strong">**创造者**</span>：布兰登·艾克（Brendan Eich）<br><span class="hljs-strong">**初衷**</span>：JavaScript于1995年由布兰登·艾克在Netscape公司开发，目标是为Web浏览器添加一种轻量级的脚本语言，以便于处理用户交互和动态内容。JavaScript的设计注重简便和灵活性。<br><span class="hljs-strong">**评价**</span>：布兰登·艾克认为，尽管JavaScript起初面临许多批评和挑战，但它已经成长为一种重要的编程语言，推动了Web技术的发展。如今，JavaScript不仅在客户端编程中占据主导地位，还扩展到了服务器端（如Node.js）。<br><br><span class="hljs-section">### 5. C++</span><br><br><span class="hljs-strong">**创造者**</span>：比雅尼·斯特劳斯特鲁普（Bjarne Stroustrup）<br><span class="hljs-strong">**初衷**</span>：C++是在1980年代由比雅尼·斯特劳斯特鲁普开发的，目的是在C语言的基础上增加面向对象编程的特性，从而提高程序的模块化和可维护性。C++兼顾了系统编程的效率和高级程序设计的灵活性。<br><span class="hljs-strong">**评价**</span>：比雅尼·斯特劳斯特鲁普认为，C++成功地达到了他的设计目标，并且在工业界和学术界得到了广泛应用。他对C++的演变和持续发展表示欣慰，并认为它在现代软件开发中仍然具有重要地位。<br><br><span class="hljs-section">### 6. Ruby</span><br><br><span class="hljs-strong">**创造者**</span>：松本行弘（Yukihiro &quot;Matz&quot; Matsumoto）<br><span class="hljs-strong">**初衷**</span>：Ruby语言于1990年代中期由松本行弘开发，目标是创建一种简洁且强大的编程语言，使程序员在编程时感到愉悦和高效。Ruby融合了多种编程范式，强调优雅和简便。<br><span class="hljs-strong">**评价**</span>：松本行弘对Ruby的成功感到高兴，尤其是在Web开发领域（如Ruby on Rails的影响）。他认为Ruby实现了他当初的设计理念，让编程变得更有乐趣和创造性。<br><br><span class="hljs-section">### 7. Swift</span><br><br><span class="hljs-strong">**创造者**</span>：克里斯·拉特纳（Chris Lattner）<br><span class="hljs-strong">**初衷**</span>：Swift语言由克里斯·拉特纳在苹果公司主导开发，发布于2014年，目的是取代Objective-C，提供一种现代、安全、快速的编程语言，适用于iOS和macOS应用开发。Swift结合了现代编程语言的最佳特性，注重安全性和性能。<br><span class="hljs-strong">**评价**</span>：克里斯·拉特纳对Swift的评价非常正面，他认为Swift在简化开发过程、提高代码安全性和执行性能方面表现出色。Swift的快速普及和广泛应用表明它达到了预期的目标。<br><br>这些编程语言的创造者普遍认为，他们的语言在实现最初的设计目标方面取得了成功，并且在各自的应用领域内产生了深远的影响。尽管随着时间的推移，每种语言都面临新的挑战和竞争，但其核心理念和影响力依然显著。<br><br><br><br><span class="hljs-section">## Web浏览器是什么？</span><br><br><br><br><span class="hljs-section">## influxdb数据库是什么？它是一种类似于MySQL的东西还是像DBeaver一样可以使用多种数据库的工具？</span><br><br>InfluxDB是一种时序数据库（Time Series Database），专门设计用于处理高写入和查询性能的时间序列数据，如监控数据、传感器数据和物联网数据。它与传统的关系型数据库（如MySQL）不同，主要用于存储和查询按时间顺序排列的数据。<br><br>以下是关于InfluxDB的一些关键点：<br><br><span class="hljs-section">#### InfluxDB的特点</span><br><br><span class="hljs-bullet">1.</span> <span class="hljs-strong">**专为时间序列数据设计**</span>：InfluxDB优化了存储和查询时间序列数据，提供高效的写入和读取性能。<br><span class="hljs-bullet">2.</span> <span class="hljs-strong">**SQL类查询语言**</span>：使用InfluxQL或Flux（InfluxData自己的脚本语言）来执行复杂的查询。<br><span class="hljs-bullet">3.</span> <span class="hljs-strong">**无需预定义模式**</span>：你可以在运行时添加新的字段和标签，无需预定义数据库的模式。<br><span class="hljs-bullet">4.</span> <span class="hljs-strong">**高效的数据压缩和存储**</span>：支持数据的自动压缩和删除，优化存储空间的使用。<br><span class="hljs-bullet">5.</span> <span class="hljs-strong">**集成和扩展性**</span>：提供丰富的API和插件，可以与多种数据收集工具和可视化工具（如Grafana）集成。<br><br><span class="hljs-section">#### InfluxDB vs. MySQL</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**数据模型**</span>：MySQL是一个关系型数据库，采用表、行和列的模式，而InfluxDB是一个时序数据库，采用测量（measurement）、字段（field）和标签（tag）的模式。<br><span class="hljs-bullet">-</span> <span class="hljs-strong">**查询语言**</span>：MySQL使用SQL，InfluxDB使用InfluxQL或Flux。<br><span class="hljs-bullet">-</span> <span class="hljs-strong">**应用场景**</span>：MySQL适合传统的业务数据管理，如用户信息、订单记录等；InfluxDB更适合时间序列数据管理，如传感器数据、服务器监控数据等。<br><br><span class="hljs-section">#### InfluxDB vs. DBeaver</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**功能**</span>：InfluxDB是一个数据库系统，专门用于存储和处理时间序列数据。DBeaver则是一个数据库管理工具，可以连接和管理多种数据库系统，包括MySQL、PostgreSQL、SQLite、Oracle、SQL Server等。<br><span class="hljs-bullet">-</span> <span class="hljs-strong">**用途**</span>：InfluxDB用于存储和查询时序数据，而DBeaver用于数据库开发和管理工作，可以对多种数据库系统进行操作和查询。<br><br><span class="hljs-section">#### 使用场景</span><br><br>InfluxDB通常用于以下场景：<br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**监控和报警**</span>：服务器性能监控、应用程序监控、基础设施监控等。<br><span class="hljs-bullet">-</span> <span class="hljs-strong">**物联网（IoT）**</span>：传感器数据收集和分析。<br><span class="hljs-bullet">-</span> <span class="hljs-strong">**金融数据分析**</span>：股票价格、交易量等金融时间序列数据。<br><span class="hljs-bullet">-</span> <span class="hljs-strong">**工业数据**</span>：工业设备数据监控和预测维护。<br><br><span class="hljs-section">#### 示例</span><br><br>假设你在使用InfluxDB来存储服务器的CPU使用率数据，你可以用以下示例来展示如何插入和查询数据：<br><br><span class="hljs-strong">**写入数据**</span><br><br></code></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>bash<br>复制代码<br>curl -i -XPOST ‘<a target="_blank" rel="noopener" href="http://localhost:8086/write?db=mydb">http://localhost:8086/write?db=mydb</a>‘ –data-binary ‘cpu,host&#x3D;server01,region&#x3D;uswest value&#x3D;0.64’</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-strong">**查询数据**</span><br><br></code></pre></td></tr></table></figure>
<p>sql<br>复制代码<br>SELECT “value” FROM “cpu” WHERE “host” &#x3D; ‘server01’ AND “region” &#x3D; ‘uswest’</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>总的来说，InfluxDB是一个专门用于处理时间序列数据的数据库系统，而不是一个多数据库管理工具。它的设计和优化使其在处理大量时间序列数据时表现优异。<br><br>## 什么是构析函数（Destructor）？<br><br>析构函数是类的特殊方法，当对象被垃圾回收时调用。它用于清理资源（如关闭文件、释放内存）。析构函数的名称与类名相同，并且前面加上波浪号（`~`）。<br><br>#### 特点：<br><br>- 名称与类名相同，前面加上波浪号（`~`）。<br>- 没有参数和返回类型。<br>- 每个类最多只有一个析构函数，不能重载。<br>- 由垃圾回收器（GC）调用，不确定何时调用。<br><br>#### 示例：<br><br>```c#<br>public <span class="hljs-keyword">class</span> Resource<br>&#123;<br>    <span class="hljs-comment">// 析构函数</span><br>    ~Resource()<br>    &#123;<br>        <span class="hljs-comment">// 清理资源的代码</span><br>        Console.WriteLine(<span class="hljs-string">&quot;Destructor called&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="什么是OPC-UA"><a href="#什么是OPC-UA" class="headerlink" title="什么是OPC UA"></a>什么是OPC UA</h2><p>OPC UA（OPC Unified Architecture）是一个独立于平台、面向服务、开放和安全的通信架构。它被设计用来实现不同供应商的工业自动化设备、系统和软件应用之间的互操作性3。OPC UA信息模型定义了使用各种传输协议交换数据的编码规格3。</p>
<p>OPC UA的主要特点包括：</p>
<ol>
<li><strong>功能对等性</strong>：所有COM OPC Classic规范都映射到UA，包含数据访问、报警和事件以及历史数据访问等功能3。</li>
<li><strong>平台独立性</strong>：OPC UA可在从嵌入式微控制器到基于云的基础设施的任何平台上部署使用，不依赖于特定的操作系统或硬件平台23。</li>
<li><strong>安全性</strong>：提供信息加密、身份认证和审核等安全特性，确保数据传输的安全性23。</li>
<li><strong>可扩展性</strong>：能够添加新功能而不影响现有应用程序，支持新技术和方法的集成2。</li>
<li><strong>信息模型完整性</strong>：OPC UA信息建模框架将数据转换为信息，支持复杂信息的建模和扩展2。</li>
</ol>
<p>OPC UA广泛应用于工业自动化和物联网领域，如数据收集、设备集成、远程监控、历史数据访问等3。此外，OPC UA还支持发布&#x2F;订阅（PubSub）机制，允许通过不同的协议推送数据3。</p>
<h2 id="什么是执行器"><a href="#什么是执行器" class="headerlink" title="什么是执行器"></a>什么是执行器</h2><p>在软件开发中，<strong>执行器 (Executor)</strong> 通常是一个负责执行特定任务或操作的组件。执行器可以是一个函数、方法、脚本或任何能够执行特定逻辑的代码段。它通常与触发器结合使用，触发器负责监控某些条件或事件，当这些条件满足时，触发器会调用执行器来执行相应的操作。</p>
<h2 id="正则表达式的语法是什么样的？"><a href="#正则表达式的语法是什么样的？" class="headerlink" title="正则表达式的语法是什么样的？"></a>正则表达式的语法是什么样的？</h2><p>正则表达式由普通字符（例如字母和数字）和特殊字符组成。特殊字符包括：</p>
<ul>
<li><code>.</code>：点字符可以匹配任何单个字符（除了换行符）。</li>
<li><code>*</code>：星号表示前面的元素可以出现零次或多次。</li>
<li><code>+</code>：加号表示前面的元素至少出现一次。</li>
<li><code>?</code>：问号表示前面的元素可以出现零次或一次。</li>
<li><code>[]</code>：方括号定义一个字符集合，匹配其中的任意一个字符。</li>
<li><code>()</code>：圆括号用于分组，也用于捕获匹配的文本。</li>
<li><code>|</code>：竖线表示逻辑“或”，匹配两个或多个选项中的一个。</li>
<li><code>\d</code>：匹配任意数字，等同于 <code>[0-9]</code>。</li>
<li><code>\w</code>：匹配任意字母数字字符，包括下划线。</li>
<li><code>\s</code>：匹配任何空白字符（空格、制表符、换行符等）。</li>
</ul>
<h2 id="什么是程序设计的开闭原则？"><a href="#什么是程序设计的开闭原则？" class="headerlink" title="什么是程序设计的开闭原则？"></a>什么是程序设计的开闭原则？</h2><p>开闭原则（Open&#x2F;Closed Principle, OCP）是面向对象编程中的一个重要原则，它是SOLID设计原则中的第一个原则。开闭原则的核心思想是：软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。这意味着设计时应该使软件实体能够容易地扩展新功能，而不需要修改现有的代码。</p>
<p>具体来说，开闭原则包含以下几个要点：</p>
<ol>
<li><strong>对扩展开放</strong>：当需要增加新功能时，应该能够通过添加新的代码来实现，而不是修改现有的代码。</li>
<li><strong>对修改关闭</strong>：现有的代码应该是稳定的，不应该因为添加新功能而需要修改已有的代码。</li>
</ol>
<p>开闭原则的实现通常依赖于以下几个设计模式：</p>
<ul>
<li><strong>抽象</strong>：定义抽象层，使得扩展可以在不修改现有代码的情况下进行。</li>
<li><strong>多态</strong>：通过多态机制，可以在运行时根据对象的实际类型来调用相应的方法，从而实现功能的扩展。</li>
<li><strong>接口</strong>：使用接口来定义系统的契约，通过实现不同的接口来扩展功能。</li>
<li><strong>装饰者模式</strong>：允许用户在不修改对象结构的情况下，动态地给对象添加额外的职责。</li>
<li><strong>工厂模式</strong>：使用工厂模式来创建对象，可以在不修改现有代码的情况下增加新的对象类型。</li>
</ul>
<p>遵循开闭原则可以提高代码的可维护性和可扩展性，同时也有助于降低软件的复杂度和开发成本。</p>
<h2 id="什么是SOLID设计原则？"><a href="#什么是SOLID设计原则？" class="headerlink" title="什么是SOLID设计原则？"></a>什么是SOLID设计原则？</h2><p>SOLID设计原则是面向对象编程中的五个基本原则，它们提供了一种设计高质量软件的方法论。这些原则相互独立但又相互关联，共同指导开发者创建易于维护、扩展和理解的软件系统。以下是SOLID原则的简要介绍：</p>
<ol>
<li><p><strong>单一职责原则（Single Responsibility Principle, SRP）</strong>：</p>
<ul>
<li>一个类应该只有一个引起它变化的原因，即一个类只负责一项职责。</li>
</ul>
</li>
<li><p><strong>开闭原则（Open&#x2F;Closed Principle, OCP）</strong>：</p>
<ul>
<li>类应该对扩展开放，对修改关闭。这意味着设计时应该使软件实体能够容易地扩展新功能，而不需要修改现有的代码。</li>
</ul>
</li>
<li><p><strong>里氏替换原则（Liskov Substitution Principle, LSP）</strong>：</p>
<ul>
<li>子类对象必须能够替换掉它们的父类对象，并且不破坏系统的正确性。即基类可以被子类无缝替换，而不影响程序的行为。</li>
</ul>
</li>
<li><p><strong>接口隔离原则（Interface Segregation Principle, ISP）</strong>：</p>
<ul>
<li>不应该强迫客户依赖于它们不使用的方法。一个类不应该依赖于它不使用的接口，应该将大的接口拆分成小的、特定的接口。</li>
</ul>
</li>
<li><p><strong>依赖倒置原则（Dependency Inversion Principle, DIP）</strong>：</p>
<ul>
<li>高层模块不应该依赖于低层模块，两者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。</li>
</ul>
</li>
</ol>
<p>SOLID设计原则帮助开发者避免设计上的常见错误，比如过度耦合和脆弱的代码，从而提高代码的可维护性、可扩展性和可测试性。这些原则并不总是需要同时应用，而是根据具体情况灵活运用。</p>
<h2 id="什么是生成叙事？"><a href="#什么是生成叙事？" class="headerlink" title="什么是生成叙事？"></a>什么是生成叙事？</h2><p>你在游戏里和别的玩家交互，你被K了头，这个就是生成叙事。它是多人游戏特有的。</p>
<h2 id="ConcurrentDictionary是啥？"><a href="#ConcurrentDictionary是啥？" class="headerlink" title="ConcurrentDictionary是啥？"></a>ConcurrentDictionary是啥？</h2><p><code>ConcurrentDictionary</code> 是 .NET 中的一个线程安全的字典实现，属于 <code>System.Collections.Concurrent</code> 命名空间。它允许多个线程同时读写字典，而不需要额外的同步机制，因为它内部使用了细粒度锁定和其他并发控制技术来确保操作的原子性和线程安全。</p>
<p><code>ConcurrentDictionary</code> 提供了与 <code>Dictionary&lt;TKey,TValue&gt;</code> 类似的功能，但它更适合在高并发环境中使用。它支持以下特性：</p>
<ul>
<li><strong>线程安全</strong>：多个线程可以同时访问字典进行读取或更新操作，而不会互相干扰。</li>
<li><strong>高性能</strong>：通过减少锁定的粒度，<code>ConcurrentDictionary</code> 可以提供比传统的 <code>Dictionary</code> 更好的并发性能。</li>
<li><strong>灵活性</strong>：提供了多种添加、删除和查找元素的方法，包括返回默认值的选项，如果键不存在。</li>
<li><strong>扩展性</strong>：可以与其他并发集合一起使用，以构建复杂的并发数据结构。</li>
</ul>
<p>使用 <code>ConcurrentDictionary</code> 时，你不需要手动锁定字典的各个部分，因为 <code>ConcurrentDictionary</code> 已经为你管理了这些细节。这使得它成为多线程应用程序中的首选数据结构之一，特别是当你需要在多个线程之间共享和修改数据时。</p>
<h2 id="sortedset是什么类型？"><a href="#sortedset是什么类型？" class="headerlink" title="sortedset是什么类型？"></a>sortedset是什么类型？</h2><p><code>SortedSet&lt;T&gt;</code> 是 .NET 中的一个集合类型，属于 <code>System.Collections.Generic</code> 命名空间。它是一个基于红黑树的有序集合，提供了线程安全的添加、删除和搜索操作。以下是 <code>SortedSet&lt;T&gt;</code> 的一些关键特性：</p>
<ol>
<li><p><strong>有序性</strong>：<code>SortedSet&lt;T&gt;</code> 保证其中的元素按照特定的顺序排列。默认情况下，元素按照其自然排序顺序（即 <code>IComparable&lt;T&gt;</code> 接口定义的顺序）进行排序。如果元素类型不实现 <code>IComparable&lt;T&gt;</code>，或者你希望使用不同的排序方式，可以通过提供一个 <code>IComparer&lt;T&gt;</code> 实现来指定自定义的排序逻辑。</p>
</li>
<li><p><strong>唯一性</strong>：<code>SortedSet&lt;T&gt;</code> 中的元素是唯一的。如果尝试添加一个已经存在于集合中的元素，该元素不会被重复添加。</p>
</li>
<li><p><strong>效率</strong>：红黑树的实现确保了 <code>SortedSet&lt;T&gt;</code> 提供了高效的元素添加、删除和搜索操作。例如，添加、删除和查找操作通常都是对数时间复杂度（O(log n)）。</p>
</li>
<li><p><strong>范围查询</strong>：<code>SortedSet&lt;T&gt;</code> 支持高效的范围查询，可以快速找到在指定范围内的所有元素。</p>
</li>
<li><p><strong>并集、交集和差集操作</strong>：<code>SortedSet&lt;T&gt;</code> 提供了方便的方法来执行集合的并集、交集和差集操作。</p>
</li>
<li><p><strong>线程安全</strong>：虽然 <code>SortedSet&lt;T&gt;</code> 本身不是线程安全的，但是可以通过使用 <code>ConcurrentBag&lt;T&gt;</code> 或者通过外部同步机制来确保线程安全。</p>
</li>
</ol>
<p><code>SortedSet&lt;T&gt;</code> 适用于需要有序集合且元素唯一性的场景，例如，存储一组唯一项并保持它们有序，或者实现某些算法（如集合操作、范围搜索等）。</p>
<h2 id="Hashset不是一个键值对，而是一种用哈希表实现的便于查询的集合？"><a href="#Hashset不是一个键值对，而是一种用哈希表实现的便于查询的集合？" class="headerlink" title="Hashset不是一个键值对，而是一种用哈希表实现的便于查询的集合？"></a>Hashset不是一个键值对，而是一种用哈希表实现的便于查询的集合？</h2><p>是的，您的理解是正确的。<code>HashSet&lt;T&gt;</code> 不是键值对集合，而是一种基于哈希表实现的集合，它主要用于存储不重复的元素。以下是 <code>HashSet&lt;T&gt;</code> 的一些关键特性：</p>
<ol>
<li><p><strong>元素唯一性</strong>：<code>HashSet&lt;T&gt;</code> 保证所有元素都是唯一的。如果尝试添加一个已经存在的元素，该元素不会被添加到集合中。</p>
</li>
<li><p><strong>基于哈希表</strong>：<code>HashSet&lt;T&gt;</code> 的内部实现基于哈希表，这意味着它使用元素的哈希码来快速定位元素，从而提供高效的查找、插入和删除操作。</p>
</li>
<li><p><strong>无序性</strong>：与 <code>Dictionary&lt;TKey, TValue&gt;</code> 不同，<code>HashSet&lt;T&gt;</code> 不保证元素的顺序。元素的添加和遍历顺序可能与元素的实际存储顺序不同。</p>
</li>
<li><p><strong>高效操作</strong>：<code>HashSet&lt;T&gt;</code> 提供平均常数时间复杂度（O(1)）的添加、删除和查找操作。</p>
</li>
<li><p><strong>不包含键值对</strong>：与字典不同，<code>HashSet&lt;T&gt;</code> 只存储单一类型的元素，不包含键值对结构。每个元素既是键也是值。</p>
</li>
<li><p><strong>线程安全性</strong>：<code>HashSet&lt;T&gt;</code> 本身不是线程安全的。如果需要在多线程环境中使用，需要采取额外的同步措施。</p>
</li>
<li><p><strong>遍历能力</strong>：<code>HashSet&lt;T&gt;</code> 可以很容易地使用 <code>foreach</code> 循环进行遍历，因为 <code>IEnumerable&lt;T&gt;</code> 接口提供了迭代集合元素的能力。</p>
</li>
<li><p><strong>迭代器接口</strong>：<code>HashSet&lt;T&gt;</code> 实现了 <code>IEnumerable&lt;T&gt;</code> 和 <code>IEnumerable</code> 接口。这些接口要求实现一个名为 <code>GetEnumerator</code> 的方法，该方法返回一个实现了 <code>IEnumerator&lt;T&gt;</code> 或 <code>IEnumerator</code> 的对象。</p>
</li>
<li><p><strong>封装内部结构</strong>：<code>GetEnumerator</code> 方法封装了 <code>HashSet&lt;T&gt;</code> 的内部结构和元素的检索逻辑，使得用户无需了解哈希表的工作原理，就可以遍历集合中的所有元素。</p>
</li>
<li><p><strong>类型安全</strong>：由于 <code>HashSet&lt;T&gt;</code> 是泛型集合，它可以确保存储的元素类型是一致的。当你使用 <code>foreach</code> 遍历时，你可以直接声明变量 <code>a</code> 的类型为 <code>string</code>（如果 <code>HashSet&lt;T&gt;</code> 存储的是 <code>string</code> 类型的元素），并且知道 <code>foreach</code> 循环中的每个元素都将是 <code>string</code> 类型。</p>
</li>
<li><p><strong>性能</strong>：尽管 <code>HashSet&lt;T&gt;</code> 是基于哈希表实现的，但 <code>foreach</code> 遍历的性能通常与元素的数量成正比，而不是与哈希表的大小或复杂性成正比。这意味着即使哈希表很大，遍历集合的速度也很快。</p>
</li>
</ol>
<p><code>HashSet&lt;T&gt;</code> 非常适合用于需要快速查找和确保元素唯一性的场景，例如去重、集合操作（并集、交集、差集）等。</p>
<h2 id="什么是离岸公司"><a href="#什么是离岸公司" class="headerlink" title="什么是离岸公司"></a>什么是离岸公司</h2><p>离岸公司（Offshore Company）是指在特定的被称为离岸法区的国家和地区内成立的有限责任公司或股份有限公司，而这些公司并不在其注册地进行实质业务活动。这些地区通常是一些岛国，它们通过制定宽松的经济区域政策和公司法来吸引国际投资和注册公司，提供税收优惠、高度的商业隐私和保密性、以及外汇自由等优势。</p>
<p>离岸公司的主要特点包括：</p>
<ul>
<li>高度的保密性：股东资料、股权比例、收益状况等信息享有保密权利，通常不对外公开。</li>
<li>税收优惠：与一般公司相比，离岸公司通常只需支付年度管理费，而不需要缴纳其他税款，或享受其他税收减免政策。</li>
<li>外汇自由：资金转移没有太多限制，便于进行国际资金流动和交易。</li>
<li>法律环境宽松：离岸法区通常提供宽松的法律环境，有利于公司运营和资本运作。</li>
<li>运营地分离：离岸公司的注册地和实际经营地是分离的，它们主要在注册地以外的地区进行业务活动。</li>
</ul>
<p>常见的离岸法区包括英属维尔京群岛（BVI）、开曼群岛、巴哈马群岛、塞舌尔群岛、新加坡、香港等。这些地区因其政策优势，成为全球企业进行国际业务、资本运作和税务筹划的热门选择。</p>
<h2 id="MySQL安装过程中提到的两个数据库是什么？"><a href="#MySQL安装过程中提到的两个数据库是什么？" class="headerlink" title="MySQL安装过程中提到的两个数据库是什么？"></a>MySQL安装过程中提到的两个数据库是什么？</h2><h3 id="Sakila-数据库"><a href="#Sakila-数据库" class="headerlink" title="Sakila 数据库"></a>Sakila 数据库</h3><ul>
<li><strong>简介</strong>：Sakila 是一个电影租赁店的数据库。它的设计用于展示复杂的 SQL 查询和数据库功能。</li>
<li><strong>内容</strong>：包括表格如电影、演员、库存、客户和租赁记录等。</li>
<li><strong>用途</strong>：适用于学习和演示如何处理更复杂的关系数据库操作，例如多表连接、子查询、触发器、存储过程和视图等。</li>
</ul>
<h3 id="World-数据库"><a href="#World-数据库" class="headerlink" title="World 数据库"></a>World 数据库</h3><ul>
<li><strong>简介</strong>：World 数据库包含有关世界国家、城市和语言的地理和人口统计数据。</li>
<li><strong>内容</strong>：包括三个主要表：国家（country）、城市（city）和国家语言（countrylanguage）。</li>
<li><strong>用途</strong>：适用于进行简单的查询和数据操作，了解基本的数据库操作，例如选择、插入、更新和删除等。</li>
</ul>
<h3 id="下载和安装"><a href="#下载和安装" class="headerlink" title="下载和安装"></a>下载和安装</h3><p>这两个数据库可以从 MySQL 官方网站下载，并通过 MySQL Workbench 或命令行工具导入到你的 MySQL 服务器中。</p>
<h3 id="示例用途"><a href="#示例用途" class="headerlink" title="示例用途"></a>示例用途</h3><ul>
<li><strong>教育和学习</strong>：帮助学生和初学者了解如何设计和操作数据库。</li>
<li><strong>测试和开发</strong>：开发者可以使用这些数据进行功能测试和应用开发。</li>
<li><strong>查询示例</strong>：提供一系列示例查询，展示如何使用 SQL 进行数据操作和分析。</li>
</ul>
<h3 id="官方资源"><a href="#官方资源" class="headerlink" title="官方资源"></a>官方资源</h3><ul>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/sakila/en/">Sakila 数据库文档</a></li>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/index-other.html">World 数据库文档</a></li>
</ul>
<p>这些数据库为学习和演示 MySQL 的各种功能提供了良好的起点。</p>
<h1 id="进程间通信的方式都有什么？"><a href="#进程间通信的方式都有什么？" class="headerlink" title="进程间通信的方式都有什么？"></a>进程间通信的方式都有什么？</h1><ol>
<li><strong>管道（Pipes）</strong>：允许一个进程与另一个进程进行单向通信。</li>
<li><strong>命名管道（Named Pipes）</strong>：类似于管道，但是可以在不相关的进程之间进行通信。</li>
<li><strong>消息队列（Message Queues）</strong>：允许进程发送和接收消息。</li>
<li><strong>共享内存（Shared Memory）</strong>：允许多个进程访问同一块内存区域。</li>
<li><strong>套接字（Sockets）</strong>：支持进程在网络中的通信。</li>
<li><strong>信号（Signals）</strong>：是一种简单的通信方式，用于发送通知。</li>
<li><strong>信号量（Semaphores）</strong>：用于控制对共享资源的访问。</li>
<li><strong>文件映射（Memory-mapped Files）</strong>：将文件内容映射到内存中，允许多个进程通过读写文件来通信。</li>
</ol>
<h1 id="接口和抽象类的区别到底是啥？有的编程语言抽象类不能多继承吗？所有编程语言都支持接口多继承？接口的多继承就是所谓的优先使用组合而非继承？"><a href="#接口和抽象类的区别到底是啥？有的编程语言抽象类不能多继承吗？所有编程语言都支持接口多继承？接口的多继承就是所谓的优先使用组合而非继承？" class="headerlink" title="接口和抽象类的区别到底是啥？有的编程语言抽象类不能多继承吗？所有编程语言都支持接口多继承？接口的多继承就是所谓的优先使用组合而非继承？"></a>接口和抽象类的区别到底是啥？有的编程语言抽象类不能多继承吗？所有编程语言都支持接口多继承？接口的多继承就是所谓的优先使用组合而非继承？</h1><p>抽象类是一种可以支持实现一定方法并继承的接口</p>
<h1 id="NTP是啥"><a href="#NTP是啥" class="headerlink" title="NTP是啥"></a>NTP是啥</h1><p>NTP，即网络时间协议（Network Time Protocol），是一种用于同步网络中所有系统时钟以使用同一时间的协议。它确保了计算机系统之间的时间同步，这对于很多应用和服务来说是非常重要的，比如日志记录、数据库同步、网络安全协议等。</p>
<p>NTP 包括协议本身以及在网络计算机上运行的客户端和服务器程序。NTP 服务器可以安装在服务器上，而客户端程序可以安装在需要时间同步的任何计算机上。</p>
<p>要在服务器上安装 NTP 服务器程序，你可以按照以下步骤进行：</p>
<ol>
<li>更新系统软件包：<code>sudo apt update -y</code></li>
<li>安装 NTP 服务器：<code>sudo apt install ntp</code></li>
<li>（可选）验证安装：<code>sntp --version</code></li>
<li>配置 NTP 服务器使用最近的 NTP 服务器池，这通常通过编辑 <code>/etc/ntp.conf</code> 文件来完成，并添加或更改服务器池的地址。</li>
</ol>
<p>在 Ubuntu 系统上，一旦 NTP 服务器安装并配置好，你可以配置 NTP 客户端来与服务器同步时间。这可以通过安装 <code>ntpdate</code> 程序来实现，并确保客户端能够通过修改 <code>/etc/hosts</code> 文件来解析 NTP 服务器的主机名。</p>
<p>此外，如果 NTP 服务器需要从外部时间源获取时间，可以通过配置防火墙规则来允许传入的 NTP 流量，通常是在 UDP 端口 123 上。</p>
<p>总的来说，NTP 是确保网络中计算机时间一致性的关键工具，通过在服务器上安装 NTP 服务并在客户端上进行相应的配置，可以轻松实现时间的同步。</p>
<h1 id="extern-partial字段都是什么意思？为什么他俩和abstract字段标记可以没有方法主体？"><a href="#extern-partial字段都是什么意思？为什么他俩和abstract字段标记可以没有方法主体？" class="headerlink" title="extern,partial字段都是什么意思？为什么他俩和abstract字段标记可以没有方法主体？"></a>extern,partial字段都是什么意思？为什么他俩和abstract字段标记可以没有方法主体？</h1><h1 id="回调函数是啥？有什么用？"><a href="#回调函数是啥？有什么用？" class="headerlink" title="回调函数是啥？有什么用？"></a>回调函数是啥？有什么用？</h1><h3 id="什么是回调函数？"><a href="#什么是回调函数？" class="headerlink" title="什么是回调函数？"></a><strong>什么是回调函数？</strong></h3><p>回调函数（Callback Function）是一种编程技术，是指将一个函数作为参数传递给另一个函数，当某些特定事件发生或某个操作完成时，由这个函数（即回调函数）被调用，从而实现动态执行逻辑。</p>
<p>通俗地讲，回调函数就像是一种“预约机制”，你告诉某个函数：“一旦发生某件事情，记得调用我传给你的这个函数。”</p>
<hr>
<h3 id="回调函数的特点"><a href="#回调函数的特点" class="headerlink" title="回调函数的特点"></a><strong>回调函数的特点</strong></h3><ol>
<li><strong>延迟执行</strong>：回调函数不是立即执行，而是在某个事件发生或条件满足后才被调用。</li>
<li><strong>动态行为</strong>：主函数的行为可以根据传入的回调函数不同而发生变化。</li>
<li><strong>解耦设计</strong>：通过回调函数，可以将主逻辑与特定行为分离，增强代码的可扩展性。</li>
</ol>
<hr>
<h3 id="回调函数的应用场景"><a href="#回调函数的应用场景" class="headerlink" title="回调函数的应用场景"></a><strong>回调函数的应用场景</strong></h3><ol>
<li><p>异步操作</p>
<p>：</p>
<ul>
<li>例如文件读取完成后，通知用户数据已经准备好。</li>
</ul>
</li>
<li><p>事件驱动编程</p>
<p>：</p>
<ul>
<li>鼠标点击、按键触发等。</li>
</ul>
</li>
<li><p>算法设计</p>
<p>：</p>
<ul>
<li>例如排序算法中自定义比较逻辑。</li>
</ul>
</li>
<li><p>框架与库设计</p>
<p>：</p>
<ul>
<li>通过回调函数，用户可以在库函数执行时插入自己的逻辑。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="C-中的回调函数实现"><a href="#C-中的回调函数实现" class="headerlink" title="C# 中的回调函数实现"></a><strong>C# 中的回调函数实现</strong></h3><p>在 C# 中，回调函数通常通过以下三种方式实现：</p>
<ol>
<li><strong>委托（Delegate）</strong></li>
<li><strong>匿名函数（Anonymous Method）和 Lambda 表达式</strong></li>
<li><strong>接口（Interface）</strong></li>
</ol>
<hr>
<h4 id="1-使用委托实现回调"><a href="#1-使用委托实现回调" class="headerlink" title="1. 使用委托实现回调"></a><strong>1. 使用委托实现回调</strong></h4><p>委托是 C# 中的一个类型，用于封装方法。它是实现回调函数最常见的方式。</p>
<p><strong>示例：用委托实现简单回调</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-comment">// 定义一个委托</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CallbackDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>;<br><br>    <span class="hljs-comment">// 主函数：接受回调函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoSomething</span>(<span class="hljs-params">CallbackDelegate callback</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;开始执行操作...&quot;</span>);<br>        <span class="hljs-comment">// 模拟操作完成后调用回调函数</span><br>        callback(<span class="hljs-string">&quot;操作已完成！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 定义回调函数</span><br>        CallbackDelegate myCallback = (message) =&gt; Console.WriteLine(<span class="hljs-string">$&quot;回调消息：<span class="hljs-subst">&#123;message&#125;</span>&quot;</span>);<br><br>        <span class="hljs-comment">// 将回调函数传递给主函数</span><br>        DoSomething(myCallback);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>运行结果</strong>：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang">开始执行操作...<br>回调消息：操作已完成！<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="2-使用匿名方法或-Lambda-表达式实现回调"><a href="#2-使用匿名方法或-Lambda-表达式实现回调" class="headerlink" title="2. 使用匿名方法或 Lambda 表达式实现回调"></a><strong>2. 使用匿名方法或 Lambda 表达式实现回调</strong></h4><p>在 C# 中，匿名方法和 Lambda 表达式可以用作回调函数，语法更简洁。</p>
<p><strong>示例：用 Lambda 表达式实现回调</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CallbackDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoSomething</span>(<span class="hljs-params">CallbackDelegate callback</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;执行一些操作...&quot;</span>);<br>        callback(<span class="hljs-string">&quot;操作完成，Lambda 表达式回调成功！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 使用 Lambda 表达式直接传递回调</span><br>        DoSomething((message) =&gt; Console.WriteLine(<span class="hljs-string">$&quot;回调消息：<span class="hljs-subst">&#123;message&#125;</span>&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="3-使用接口实现回调"><a href="#3-使用接口实现回调" class="headerlink" title="3. 使用接口实现回调"></a><strong>3. 使用接口实现回调</strong></h4><p>通过接口实现回调是一种面向对象的方式，通常用于设计更复杂的场景。</p>
<p><strong>示例：用接口实现回调</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title">ICallback</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnComplete</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ICallback _callback;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Worker</span>(<span class="hljs-params">ICallback callback</span>)</span><br>    &#123;<br>        _callback = callback;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoWork</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;正在工作...&quot;</span>);<br>        <span class="hljs-comment">// 模拟工作完成后调用回调</span><br>        _callback.OnComplete(<span class="hljs-string">&quot;工作完成，接口回调成功！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span> : <span class="hljs-title">ICallback</span><br>&#123;<br>    <span class="hljs-comment">// 实现回调接口</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnComplete</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;回调收到消息：<span class="hljs-subst">&#123;message&#125;</span>&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 创建回调实现类</span><br>        Program program = <span class="hljs-keyword">new</span> Program();<br><br>        <span class="hljs-comment">// 创建 Worker 并传入回调</span><br>        Worker worker = <span class="hljs-keyword">new</span> Worker(program);<br><br>        <span class="hljs-comment">// 执行任务</span><br>        worker.DoWork();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>运行结果</strong>：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang">正在工作...<br>回调收到消息：工作完成，接口回调成功！<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="4-使用-Action-和-Func-简化回调"><a href="#4-使用-Action-和-Func-简化回调" class="headerlink" title="4. 使用 Action 和 Func 简化回调"></a><strong>4. 使用 <code>Action</code> 和 <code>Func</code> 简化回调</strong></h4><p>在 C# 中，<code>Action</code> 和 <code>Func</code> 是内置的委托类型，通常用于更简洁的回调函数定义。</p>
<p><strong>示例：使用 <code>Action</code> 实现回调</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoSomething</span>(<span class="hljs-params">Action&lt;<span class="hljs-built_in">string</span>&gt; callback</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;操作进行中...&quot;</span>);<br>        callback(<span class="hljs-string">&quot;使用 Action 进行回调&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        DoSomething((message) =&gt; Console.WriteLine(<span class="hljs-string">$&quot;回调消息：<span class="hljs-subst">&#123;message&#125;</span>&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>示例：使用 <code>Func</code> 实现回调</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Execute</span>(<span class="hljs-params">Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; operation</span>)</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> result = operation(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;计算结果：<span class="hljs-subst">&#123;result&#125;</span>&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 使用 Func 定义回调</span><br>        Execute((x, y) =&gt; x + y);  <span class="hljs-comment">// 输出：计算结果：30</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><strong>回调函数</strong>是通过动态传递逻辑来实现程序灵活性和解耦的重要工具。</li>
<li>在 C# 中，回调函数可以通过委托、Lambda 表达式、接口等方式实现。</li>
<li><code>Action</code> 和 <code>Func</code> 提供了更加简洁的回调机制，非常适合现代开发场景。</li>
<li>根据需求选择合适的实现方式，委托适合简单场景，接口适合复杂设计，而 <code>Action</code> 和 <code>Func</code> 更加高效便捷。</li>
</ul>
<h1 id="委托是个什么设定？"><a href="#委托是个什么设定？" class="headerlink" title="委托是个什么设定？"></a>委托是个什么设定？</h1><p>虽然委托一开始创建的时候是要传入一个函数的，但并不一定的不空的，如果空的话可以直接&#x3D;&#x3D;null的</p>
<h1 id="RESTful-Web-API-是什么？"><a href="#RESTful-Web-API-是什么？" class="headerlink" title="RESTful Web API 是什么？"></a>RESTful Web API 是什么？</h1><p>RESTful Web API（Representational State Transferful Web API）是一种基于REST（Representational State Transfer，表现层状态转移）原则构建的Web API，它定义了客户端和服务器之间交互数据的方式。REST是一种软件架构风格，用于设计网络应用程序，使得它们可以通过标准的HTTP协议进行通信。</p>
<p>RESTful Web API 通常具有以下特点：</p>
<ol>
<li><p><strong>无状态（Stateless）</strong>：每个请求从客户端到服务器都包含所有必要的信息来理解和处理请求。服务器不会存储任何客户端请求之间的信息。</p>
</li>
<li><p><strong>统一接口（Uniform Interface）</strong>：通过定义一组标准的HTTP方法（如GET、POST、PUT、DELETE等），客户端可以对资源进行操作。</p>
</li>
<li><p><strong>可缓存（Cacheable）</strong>：数据被标记为可缓存或不可缓存。如果数据是可缓存的，客户端可以存储数据副本以提高性能。</p>
</li>
<li><p><strong>分层系统（Layered System）</strong>：客户端通常不知道它们是直接与服务器通信，还是与中间层（如代理、网关）通信。</p>
</li>
<li><p><strong>通过超媒体作为应用状态的引擎（HATEOAS）</strong>：API应该提供足够的信息，使得用户可以发现下一步可以执行的操作。</p>
</li>
</ol>
<p>在RESTful Web API中，资源（如用户、产品、文章等）通过URI（统一资源标识符）进行标识，并且通过HTTP方法进行操作：</p>
<ul>
<li><strong>GET</strong>：用于检索资源。</li>
<li><strong>POST</strong>：用于创建新资源。</li>
<li><strong>PUT</strong>：用于更新现有资源。</li>
<li><strong>DELETE</strong>：用于删除资源。</li>
</ul>
<p>RESTful Web API的设计使得它们易于理解和使用，同时也便于与其他基于HTTP的应用程序集成。这种API风格在现代Web开发中非常流行，因为它简单、灵活且易于扩展。</p>
<h1 id="什么是强类型语法？"><a href="#什么是强类型语法？" class="headerlink" title="什么是强类型语法？"></a>什么是强类型语法？</h1><h1 id="抽象类和接口的区别是什么？"><a href="#抽象类和接口的区别是什么？" class="headerlink" title="抽象类和接口的区别是什么？"></a>抽象类和接口的区别是什么？</h1><p>接口只规定不实现，抽象类可以实现，而且还带访问封装，接口没有封装。</p>
<p>设计理念<br>接口的设计理念：<br>•	契约导向：接口强调的是行为契约，任何实现接口的类都必须提供接口中定义的方法。<br>•	解耦和灵活性：接口使得代码更加解耦和灵活，便于单元测试和依赖注入。<br>抽象类的设计理念：<br>•	代码复用：抽象类允许在基类中提供一些默认的实现，从而减少代码重复。<br>•	层次结构：抽象类适用于具有层次结构的场景，提供了一种在基类和派生类之间共享代码的方式。<br>选择指南<br>•	使用接口：当你需要定义一组不相关类的共同行为，或者需要实现多重继承时。<br>•	使用抽象类：当你需要为一组相关类提供一个共同的基类，并且希望在基类中提供一些默认的实现时。</p>
<h1 id="所谓的便携wifi实际上是对手机热点功能的一种模拟？还是说是反过来的-手机热点功能是对便携wifi功能的一种模拟"><a href="#所谓的便携wifi实际上是对手机热点功能的一种模拟？还是说是反过来的-手机热点功能是对便携wifi功能的一种模拟" class="headerlink" title="所谓的便携wifi实际上是对手机热点功能的一种模拟？还是说是反过来的?手机热点功能是对便携wifi功能的一种模拟?"></a>所谓的便携wifi实际上是对手机热点功能的一种模拟？还是说是反过来的?手机热点功能是对便携wifi功能的一种模拟?</h1><p>便携 WiFi 和手机热点功能的核心原理确实相似，但从发展历史上来看，是手机热点功能对便携 WiFi 的一种模拟。</p>
<h3 id="便携-WiFi（独立设备）的发展在前"><a href="#便携-WiFi（独立设备）的发展在前" class="headerlink" title="便携 WiFi（独立设备）的发展在前"></a>便携 WiFi（独立设备）的发展在前</h3><p>便携 WiFi（例如 MiFi 设备）通常是一个独立的硬件设备，内置了 SIM 卡槽，能够直接连接移动运营商的网络，并将此连接通过 WiFi 分享给其他设备。早期的便携 WiFi 是设计用来为笔记本电脑、平板等设备提供互联网连接，最早的便携 WiFi 距今已有十多年历史。</p>
<h3 id="手机热点功能的出现"><a href="#手机热点功能的出现" class="headerlink" title="手机热点功能的出现"></a>手机热点功能的出现</h3><p>随着智能手机的发展和移动互联网的普及，手机具备了较强的处理能力并支持移动数据连接，因此将手机变为“便携 WiFi”成为了可能。手机热点功能就是利用手机内置的 WiFi 模块，将移动网络共享给其他设备。这个功能可以看作对便携 WiFi 的一种“模拟”，因为它在原理上是类似的：连接移动网络并创建 WiFi 热点供其他设备连接。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>虽然两者的实现方式略有不同，但本质上手机热点是在模仿便携 WiFi 的工作方式，提供了一种便捷的解决方案。</p>
<h1 id="多个点的质心或者说中心点有什么特性"><a href="#多个点的质心或者说中心点有什么特性" class="headerlink" title="多个点的质心或者说中心点有什么特性"></a>多个点的质心或者说中心点有什么特性</h1><p>质心（centroid）或中心点是指多个点的 “平均位置”。在几何学和物理学中，质心是一个集合的质量中心，对于一组给定的点，它是所有点的加权平均位置。如果这些点在同一平面或空间中，质心就是这些点坐标的平均值。</p>
<h3 id="质心的基本定义"><a href="#质心的基本定义" class="headerlink" title="质心的基本定义"></a>质心的基本定义</h3><p>对于一组 (n) 个点，点的坐标为$ (x_1, y_1), (x_2, y_2), …, (x_n, y_n)$，其质心 $G &#x3D; (x_c, y_c) $可以通过以下方式计算：<br>$$<br>x_c &#x3D; \frac{1}{n} \sum_{i&#x3D;1}^{n} x_i<br>$$</p>
<p>$$<br>y_c &#x3D; \frac{1}{n} \sum_{i&#x3D;1}^{n} y_i<br>$$</p>
<p>对于三维空间中的点，质心的计算公式类似：</p>
<p>$$<br>x_c &#x3D; \frac{1}{n} \sum_{i&#x3D;1}^{n} x_i<br>$$<br>$$<br>y_c &#x3D; \frac{1}{n} \sum_{i&#x3D;1}^{n} y_i<br>$$<br>$$<br>z_c &#x3D; \frac{1}{n} \sum_{i&#x3D;1}^{n} z_i<br>$$</p>
<p>即，质心是所有点在各个坐标轴上的平均坐标。</p>
<h3 id="质心的特性"><a href="#质心的特性" class="headerlink" title="质心的特性"></a>质心的特性</h3><ol>
<li><p><strong>位置是各点坐标的平均值</strong>：<br>质心是所有点在每个坐标轴上的坐标的算术平均值。</p>
</li>
<li><p><strong>不依赖于点的权重</strong>（假设所有点的质量相等）：<br>如果每个点都有相同的质量，那么质心就是这些点的算术平均位置。</p>
<p>如果不同点的质量不同，则质心的计算应考虑点的质量。对于带权重的情况，质心是加权平均数：</p>
<p>$$<br>x_c &#x3D; \frac{\sum_{i&#x3D;1}^{n} m_i \cdot x_i}{\sum_{i&#x3D;1}^{n} m_i}<br>$$<br>$$<br>y_c &#x3D; \frac{\sum_{i&#x3D;1}^{n} m_i \cdot y_i}{\sum_{i&#x3D;1}^{n} m_i}<br>$$</p>
<p>其中 (m_i) 是第 (i) 个点的质量，(x_i) 和 (y_i) 是第 (i) 个点的坐标。</p>
</li>
<li><p><strong>质心是平衡点</strong>：<br>如果你在二维平面上画一个图形，并将这个图形按质心进行平衡，它应该是平衡的。也就是说，如果在质心的位置上放一个支点，那么这个图形就不会倾斜。</p>
</li>
<li><p><strong>质心与几何形状有关</strong>：<br>对于规则形状（如正多边形、圆形等），质心位于形状的对称中心。对于不规则形状，它可能位于形状内部或外部，取决于点的分布。</p>
</li>
<li><p><strong>质心不一定在已知的点集内</strong>：<br>在某些情况下，质心可能位于给定点集之外，特别是在计算多边形的质心时。对于一个简单的凸多边形，质心通常位于该多边形内部，但对于复杂的凹形状，质心可能位于多边形外部。</p>
</li>
<li><p><strong>具有旋转对称性</strong>：<br>对于一个平面上的对称图形（如圆形、正多边形等），质心通常位于其对称中心。</p>
</li>
<li><p><strong>计算简单且高效</strong>：<br>质心的计算方法通常非常简单，只需要计算所有点的坐标的平均值即可。对于大多数应用而言，这种计算的时间复杂度为 (O(n))，其中 (n) 是点的数量。</p>
</li>
</ol>
<h3 id="质心的应用"><a href="#质心的应用" class="headerlink" title="质心的应用"></a>质心的应用</h3><ul>
<li><strong>物理学</strong>：质心概念用于描述物体的质量中心，特别是在分析物体的运动时（例如转动惯量）。</li>
<li><strong>计算几何</strong>：在图形处理中，质心用于寻找图形的几何中心，广泛应用于碰撞检测、分割和配准等任务。</li>
<li><strong>图像处理</strong>：在图像中，质心可以用来描述形状或物体的重心，常用于形状分析、目标追踪和图像分割。</li>
<li><strong>计算机图形学</strong>：质心用于计算模型的中心点，帮助进行模型对齐和变换。</li>
</ul>
<h3 id="质心计算的例子"><a href="#质心计算的例子" class="headerlink" title="质心计算的例子"></a>质心计算的例子</h3><ol>
<li><p><strong>二维点集的质心计算</strong>：</p>
<p>给定四个点：<br>$$<br>(1, 2), (4, 6), (7, 8), (10, 12)<br>$$</p>
<p>质心的计算：<br>$$<br>x_c &#x3D; \frac{1 + 4 + 7 + 10}{4} &#x3D; 5.5<br>$$<br>$$<br>y_c &#x3D; \frac{2 + 6 + 8 + 12}{4} &#x3D; 7<br>$$</p>
<p>所以质心为 ((5.5, 7))。</p>
</li>
<li><p><strong>三维点集的质心计算</strong>：</p>
<p>给定三个点：<br>$$<br>(1, 2, 3), (4, 5, 6), (7, 8, 9)<br>$$</p>
<p>质心的计算：<br>$$<br>x_c &#x3D; \frac{1 + 4 + 7}{3} &#x3D; 4<br>$$<br>$$<br>y_c &#x3D; \frac{2 + 5 + 8}{3} &#x3D; 5<br>$$<br>$$<br>z_c &#x3D; \frac{3 + 6 + 9}{3} &#x3D; 6<br>$$</p>
<p>所以质心为 ((4, 5, 6))。</p>
</li>
</ol>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>质心是多个点的“平均位置”，通常用于表示一组点的几何中心。在计算时，质心是各点坐标的算术平均值，对于带有不同质量的点集合，质心可以通过加权平均计算。质心在物理学、计算几何、图像处理等领域有广泛的应用。</p>
<h1 id="为什么在MAUI应用中使用Process-GetProcesses-方法无法获得所有的进程信息"><a href="#为什么在MAUI应用中使用Process-GetProcesses-方法无法获得所有的进程信息" class="headerlink" title="为什么在MAUI应用中使用Process.GetProcesses()方法无法获得所有的进程信息?"></a>为什么在MAUI应用中使用Process.GetProcesses()方法无法获得所有的进程信息?</h1><p>在 Android 设备上使用 <code>Process.GetProcesses()</code> 只能获取到<strong>自己所在的进程</strong>或是非常有限的信息，这是由 Android 的沙盒和权限机制所决定的。和传统桌面或服务器环境的 .NET 不同，Android 并不允许普通应用程序访问系统中所有进程的详细信息。</p>
<h2 id="为什么会这样？"><a href="#为什么会这样？" class="headerlink" title="为什么会这样？"></a>为什么会这样？</h2><ol>
<li><strong>Android 沙盒机制</strong><br> 每个 Android 应用都运行在自己的“应用沙盒”中，进程之间隔离很严格。应用无权直接访问其他进程的信息，除非拥有系统级权限或特定的授权。</li>
<li><strong>权限限制</strong><br> Android 并没有对普通第三方应用开放类似于在桌面系统上遍历所有进程的接口。即使你调用了 <code>Process.GetProcesses()</code>，最终底层的实现也只能让你看到自己进程的基本信息。</li>
<li><strong>安全策略</strong><br> 出于安全和隐私的考虑，Android 系统对进程、文件等访问做了严格的限制，防止不同应用之间互相窥探或干扰。</li>
</ol>
<h2 id="如果想获取所有进程信息，该怎么做？"><a href="#如果想获取所有进程信息，该怎么做？" class="headerlink" title="如果想获取所有进程信息，该怎么做？"></a>如果想获取所有进程信息，该怎么做？</h2><p>一般来说，在<strong>非 Root 环境</strong>下，普通应用几乎没有办法获取系统中所有进程的详细信息。以下是一些可能但并不一定可行的途径：</p>
<ol>
<li><strong>Root 权限</strong><ul>
<li>如果设备已经 Root，那么可以通过访问 <code>/proc</code> 文件系统或使用一些系统级命令（如 <code>ps</code>、<code>top</code> 等）来获取所有进程信息。</li>
<li>但是这会导致应用只能在 Root 后的设备上运行，并且在官方应用商店上架会遇到限制。</li>
</ul>
</li>
<li><strong>系统签名 &#x2F; 定制 ROM</strong><ul>
<li>如果你在开发系统应用（即使用了与系统相同的签名）或是开发针对定制 ROM 的特权应用，则可以使用 Android 的系统 API（如 <code>ActivityManagerService</code>）来获取所有进程信息。</li>
<li>这通常只适用于设备厂商或在特殊场景（比如企业、特定硬件项目）下定制的 Android 系统。</li>
</ul>
</li>
<li><strong>ActivityManager APIs（有限信息）</strong><ul>
<li>有些情况下，可以用 <code>Android.App.ActivityManager</code>（Java &#x2F; Xamarin.Android）获取<strong>部分</strong>正在运行的任务&#x2F;服务信息，不过从 Android 5.0 开始，能获取到的信息也变得非常有限，且通常只能拿到应用层级的概览（比如包名、进程计数），而非完整进程列表。</li>
</ul>
</li>
<li><strong>Shell 命令（有限，且受权限限制）</strong><ul>
<li>即使你执行类似 <code>Runtime.getRuntime().exec(&quot;ps&quot;)</code> 的命令，若没有 Root 权限，也只能查看到<strong>自己所在应用</strong>及部分系统可见的进程。</li>
</ul>
</li>
</ol>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul>
<li><strong>在普通的 Android 应用环境下，无法用 <code>Process.GetProcesses()</code> 获取所有进程。</strong></li>
<li>这并不是 .NET 或 C# 的问题，而是 Android 操作系统本身的安全沙盒设计导致的行为。</li>
<li>如果确有需要（比如做系统工具、ROM 定制、设备管理等），就必须获得更高权限（Root 或系统签名），然后才能使用系统底层接口或 Shell 命令来获取全部进程信息。</li>
</ul>
<p>因此，如果只是做一般的 App 开发，往往只能获取到<strong>自己</strong>的进程信息，这在移动平台上是标准且合规的行为。</p>
<h1 id="热更新热重载是怎么做到的-是什么原理"><a href="#热更新热重载是怎么做到的-是什么原理" class="headerlink" title="热更新热重载是怎么做到的?是什么原理?"></a>热更新热重载是怎么做到的?是什么原理?</h1><p>“热更新”(Hot Update) 或“热重载”(Hot Reload) 指的是在应用程序<strong>运行时</strong>，对代码或资源文件的修改能够<strong>实时</strong>(或接近实时) 地在应用中生效，而<strong>无需完全重启</strong>应用的技术。不同的平台和框架有不同的实现方式，但总体思路是一致的：<strong>监听到代码或资源文件有改动，就把改动后的部分重新加载并替换原有的逻辑或内容</strong>，从而使运行中的程序能即时应用新代码。</p>
<p>下面以常见的场景来举例说明原理。</p>
<hr>
<h2 id="一、在-NET-C-中的-Hot-Reload-原理"><a href="#一、在-NET-C-中的-Hot-Reload-原理" class="headerlink" title="一、在 .NET &#x2F; C# 中的 Hot Reload 原理"></a>一、在 .NET &#x2F; C# 中的 Hot Reload 原理</h2><h3 id="1-“编辑并继续”-Edit-and-Continue-技术的演进"><a href="#1-“编辑并继续”-Edit-and-Continue-技术的演进" class="headerlink" title="1. “编辑并继续”(Edit and Continue) 技术的演进"></a>1. “编辑并继续”(Edit and Continue) 技术的演进</h3><p>早在 Visual Studio 里就有 “Edit and Continue” 功能：当你在调试（Debug）过程中修改了某些 C# 代码，VS 会尝试把修改过的<strong>方法体</strong>重新编译成 IL(中间语言)，并把它<strong>注入</strong>到正在调试的进程中，从而实现“无需停止调试就能应用新代码”的效果。</p>
<p>.NET 6+ 将此功能推广为更通用的 “Hot Reload”：</p>
<ol>
<li><strong>实时监视源码文件变动</strong>：VS&#x2F;CLI 的监视器(FileWatcher)发现文件更新后触发事件。</li>
<li><strong>重新编译仅修改的部分</strong>：只编译你刚改的类或方法，得到新的 IL。</li>
<li><strong>将新 IL 注入到运行中的程序</strong>：.NET 运行时（通过元数据和IL定位）找到对应的类或方法，替换其方法体。</li>
</ol>
<p><strong>局限</strong>：</p>
<ul>
<li>只能修改<strong>方法的实现</strong>、局部变量、表达式等；</li>
<li><strong>无法</strong>轻易修改方法签名、类的继承结构、泛型定义等较大范围的结构性更改；</li>
<li>如果改动超出“Hot Reload”可处理的范围，就需要重启或重新编译整个应用。</li>
</ul>
<h3 id="2-XAML-Hot-Reload-WPF-Xamarin-MAUI"><a href="#2-XAML-Hot-Reload-WPF-Xamarin-MAUI" class="headerlink" title="2. XAML Hot Reload (WPF &#x2F; Xamarin &#x2F; MAUI)"></a>2. XAML Hot Reload (WPF &#x2F; Xamarin &#x2F; MAUI)</h3><ul>
<li>针对 UI 层(XAML)的修改，如调整控件布局、样式等，也可以在运行时注入新的 XAML 资源，刷新 UI 视图。</li>
<li>实现思路：监听到 XAML 文件改动，重新编译 XAML-&gt;BAML(或生成 C# UI 代码)，调用运行时的刷新机制来动态更新界面树。</li>
</ul>
<hr>
<h2 id="二、在前端框架中的-Hot-Reload-Hot-Module-Replacement"><a href="#二、在前端框架中的-Hot-Reload-Hot-Module-Replacement" class="headerlink" title="二、在前端框架中的 Hot Reload &#x2F; Hot Module Replacement"></a>二、在前端框架中的 Hot Reload &#x2F; Hot Module Replacement</h2><h3 id="1-Webpack-的-HMR-Hot-Module-Replacement"><a href="#1-Webpack-的-HMR-Hot-Module-Replacement" class="headerlink" title="1. Webpack 的 HMR (Hot Module Replacement)"></a>1. Webpack 的 HMR (Hot Module Replacement)</h3><ul>
<li>前端构建工具（如 Webpack、Vite）会在开发模式下启动一个 <strong>dev server</strong> 并监控(<code>watch</code>) 源文件的变动。</li>
<li>一旦检测到文件更新，会<strong>只重新编译改动的模块</strong>，并通过 WebSocket 等方式将“更新的模块包”推送到浏览器。</li>
<li>浏览器端有一个运行时（HMR Runtime），会<strong>替换</strong>对应模块的旧代码，而无需刷新整个网页。</li>
<li>对于 React&#x2F;Vue 等框架，如果能保持组件状态，就可实现真正“局部更新、不刷新、不丢失状态”的热重载。</li>
</ul>
<h3 id="2-React-Refresh-Vue-Hot-Reload"><a href="#2-React-Refresh-Vue-Hot-Reload" class="headerlink" title="2. React Refresh &#x2F; Vue Hot Reload"></a>2. React Refresh &#x2F; Vue Hot Reload</h3><ul>
<li>React Refresh 利用 Babel 在编译时给组件插桩(instrument)，在运行时检测到代码更新后<strong>只替换对应组件的渲染逻辑</strong>。</li>
<li>Vue 的单文件组件(.vue)编译后也带有 HMR hook，检测到更新就只替换该组件的部分，不用刷新整页。</li>
</ul>
<hr>
<h2 id="三、在移动端的-Hot-Reload-React-Native-Flutter"><a href="#三、在移动端的-Hot-Reload-React-Native-Flutter" class="headerlink" title="三、在移动端的 Hot Reload (React Native &#x2F; Flutter)"></a>三、在移动端的 Hot Reload (React Native &#x2F; Flutter)</h2><h3 id="1-React-Native"><a href="#1-React-Native" class="headerlink" title="1. React Native"></a>1. React Native</h3><ul>
<li>Metro bundler 监听 JavaScript&#x2F;TypeScript 文件更新，重新打包相应模块，利用 “Fast Refresh” (类似 HMR) 向运行中的 APP 注入。</li>
<li>RN 遍历组件树，只重绘受影响的组件，不用重启整个原生应用。</li>
</ul>
<h3 id="2-Flutter"><a href="#2-Flutter" class="headerlink" title="2. Flutter"></a>2. Flutter</h3><ul>
<li>Dart VM 提供了 “hot reload&#x2F;hot restart” 能力。</li>
<li><strong>hot reload</strong>：在 Dart 层可以将修改过的代码注入到正在运行的 Dart VM 中，Flutter 框架会重建 widget 树并渲染更新，但不会丢失原有状态(如变量、路由栈)。</li>
<li><strong>hot restart</strong>：比 hot reload范围更大，会完全重启 Dart isolate，但依旧不需要重新启动整个原生进程。</li>
</ul>
<hr>
<h2 id="四、总体机制与原理"><a href="#四、总体机制与原理" class="headerlink" title="四、总体机制与原理"></a>四、总体机制与原理</h2><p>无论是后端(.NET Java)、前端(Webpack、Vite)还是移动端(Flutter、RN)，它们的做法可归纳为：</p>
<ol>
<li><strong>监控源码或资源文件改动</strong>：文件系统监听(File System Watcher)或特殊插件(DevServer)发现你保存了文件。</li>
<li><strong>局部编译&#x2F;增量编译</strong>：只编译改动过的源码模块&#x2F;方法&#x2F;资源，得到新的字节码(IL、JS bundle)或UI资源(XAML、CSS)。</li>
<li><strong>动态加载并替换</strong>：将新编译的结果注入到内存中，替换掉原有的部分。</li>
<li><strong>框架层做状态管理</strong>：许多框架会尽可能保持原来的运行状态(变量值、组件状态等)，只更新逻辑或视图，从而达到“热更新”效果。</li>
</ol>
<h3 id="核心要点"><a href="#核心要点" class="headerlink" title="核心要点"></a>核心要点</h3><ul>
<li><strong>编译器或打包器层面</strong>支持增量编译。</li>
<li><strong>运行时</strong>需要可以“热插拔”新的代码或资源。</li>
<li>有些变化（比如大范围结构性修改）必须要重新启动，因为运行时无法动态地“改血统、改签名”。</li>
<li>很多框架为了让开发体验更好，会尽可能地支持“状态保留”，这样你就不必每次改完代码后重新手动执行一系列操作(如登录、跳到某个流程等)。</li>
</ul>
<hr>
<h2 id="五、Cookie-效果之类的常见误解"><a href="#五、Cookie-效果之类的常见误解" class="headerlink" title="五、Cookie 效果之类的常见误解"></a>五、Cookie 效果之类的常见误解</h2><ul>
<li>“热重载”是针对应用本身的代码或资源进行替换，与<strong>Cookie&#x2F;Session</strong>这类网络状态无关。</li>
<li>如果应用中维护某些会话或数据状态，只要运行时不会被重启，这些状态就可被保留。在做前端 HMR&#x2F;后端 Hot Reload 时，Cookie&#x2F;Session 信息仍然可以在请求中正常传递。</li>
</ul>
<hr>
<h2 id="六、小结"><a href="#六、小结" class="headerlink" title="六、小结"></a>六、小结</h2><p><strong>热更新、热重载的本质</strong>：在<strong>不重启进程</strong>(或者不刷新整个页面&#x2F;应用)的前提下，<strong>动态替换</strong>部分已编译（或已加载）的代码&#x2F;资源，以实现更快的开发调试迭代。</p>
<ul>
<li>在 <strong>.NET</strong> 中，主要利用了 <strong>Edit and Continue</strong> &#x2F; <strong>Hot Reload</strong> 的机制来对方法体或 XAML 进行动态更新；</li>
<li>在 <strong>Web</strong> 前端，主要利用 **HMR(Hot Module Replacement)**，通过增量打包+运行时替换来只更新改动的模块；</li>
<li>在 <strong>Flutter &#x2F; React Native</strong> 中，利用虚拟机或 bundler 的能力将修改后的 Dart&#x2F;JS 代码注入运行时，并进行局部重渲染。</li>
</ul>
<p><strong>收益</strong>：开发者可以<strong>大大减少编译、启动、登录等步骤</strong>，快速看到最新修改的效果，提高开发效率。</p>
<p>这就是热更新&#x2F;热重载“能做到且如何做到”的基本原理。</p>
<h1 id="什么是ROS"><a href="#什么是ROS" class="headerlink" title="什么是ROS?"></a>什么是ROS?</h1><h1 id="为什么GC是独立组件-通用框架又是什么-什么又是规则引擎"><a href="#为什么GC是独立组件-通用框架又是什么-什么又是规则引擎" class="headerlink" title="为什么GC是独立组件?通用框架又是什么?什么又是规则引擎?"></a>为什么GC是独立组件?通用框架又是什么?什么又是规则引擎?</h1><h1 id="关于GC、通用框架和规则引擎的解释"><a href="#关于GC、通用框架和规则引擎的解释" class="headerlink" title="关于GC、通用框架和规则引擎的解释"></a>关于GC、通用框架和规则引擎的解释</h1><h2 id="为什么GC-垃圾回收-是独立组件？"><a href="#为什么GC-垃圾回收-是独立组件？" class="headerlink" title="为什么GC(垃圾回收)是独立组件？"></a>为什么GC(垃圾回收)是独立组件？</h2><p>GC(垃圾回收)作为独立组件存在有几个重要原因：</p>
<ol>
<li><strong>关注点分离</strong>：GC专注于内存管理这一单一职责，与程序的核心逻辑分离</li>
<li><strong>复杂性封装</strong>：垃圾回收算法复杂(如标记-清除、分代收集等)，独立封装便于维护</li>
<li><strong>可替换性</strong>：不同应用场景可能需要不同的GC策略(如实时系统用增量GC，服务器用并行GC)</li>
<li><strong>跨语言通用性</strong>：类似JVM、.NET CLR等运行时环境可以共享GC组件</li>
</ol>
<h2 id="什么是通用框架？"><a href="#什么是通用框架？" class="headerlink" title="什么是通用框架？"></a>什么是通用框架？</h2><p>通用框架是指为解决某一类问题而设计的基础软件结构，具有以下特点：</p>
<ol>
<li><strong>可扩展性</strong>：通过继承、组合等方式扩展功能</li>
<li><strong>可配置性</strong>：通过参数或配置文件调整行为</li>
<li><strong>重用性</strong>：为多个具体应用提供共用基础</li>
<li><strong>控制反转</strong>：框架控制程序流程，开发者填充具体逻辑</li>
</ol>
<p>例如：Spring(Java)、Django(Python)、React(前端)等都是通用框架</p>
<h2 id="什么是规则引擎？"><a href="#什么是规则引擎？" class="headerlink" title="什么是规则引擎？"></a>什么是规则引擎？</h2><p>规则引擎是一种将业务规则与应用程序代码分离的系统，特点包括：</p>
<ol>
<li><strong>业务逻辑外部化</strong>：规则通常存储在数据库或配置文件中</li>
<li><strong>声明式编程</strong>：关注”做什么”而非”如何做”</li>
<li><strong>推理引擎</strong>：使用算法(如Rete)高效匹配和执行规则</li>
<li><strong>动态更新</strong>：无需重新部署即可修改规则</li>
</ol>
<p>常见规则引擎：Drools、Jess、IBM ODM等</p>
<p>三者关系：GC保障内存安全，通用框架提供应用基础结构，规则引擎处理灵活的业务逻辑，它们共同构建健壮的软件系统。</p>
<h1 id="为什么try-catch-throw-不是一个好的做法"><a href="#为什么try-catch-throw-不是一个好的做法" class="headerlink" title="为什么try{}catch{throw}不是一个好的做法?"></a>为什么try{}catch{throw}不是一个好的做法?</h1><p><img src="/../images/%E9%97%AE%E9%A2%98&%E8%A7%A3%E5%86%B3/image-20250329231632185.png" srcset="/img/loading.gif" lazyload alt="image-20250329231632185"></p>
<p><img src="/../images/%E9%97%AE%E9%A2%98&%E8%A7%A3%E5%86%B3/image-20250329231714549.png" srcset="/img/loading.gif" lazyload alt="image-20250329231714549"></p>
<p><img src="/../images/%E9%97%AE%E9%A2%98&%E8%A7%A3%E5%86%B3/image-20250329231736194.png" srcset="/img/loading.gif" lazyload alt="image-20250329231736194"></p>
<p>KVS key value store</p>
<h1 id="什么是Mock和Fake对象"><a href="#什么是Mock和Fake对象" class="headerlink" title="什么是Mock和Fake对象?"></a>什么是Mock和Fake对象?</h1><p>这两个概念主要用于单元测试，用于替代真实依赖，方便测试和验证。</p>
<ul>
<li>Mock（模拟对象）：用来验证行为，比如“这个方法有没有被调用、调用了几次、参数是什么”。常用 Moq、NSubstitute 等库生成。</li>
<li>Fake（伪对象）：有简单实现的假对象，能返回预设数据，但不验证行为。比如内存数据库、内存队列等。</li>
</ul>
<h1 id="设计模式描述的是一种逻辑上的关系，并不关心具体实现，我的这个理解对吗"><a href="#设计模式描述的是一种逻辑上的关系，并不关心具体实现，我的这个理解对吗" class="headerlink" title="设计模式描述的是一种逻辑上的关系，并不关心具体实现，我的这个理解对吗?"></a>设计模式描述的是一种逻辑上的关系，并不关心具体实现，我的这个理解对吗?</h1><p>你的理解是正确的。<br>设计模式（Design Pattern）本质上描述的是一种通用的、可复用的解决方案，用于应对特定场景下常见的软件设计问题。它关注的是对象之间的协作关系、职责分配和交互方式，而不是具体的代码实现或技术细节。</p>
<ul>
<li><p>设计模式强调的是“结构”、“意图”和“约定”，而不是“怎么写代码”。</p>
</li>
<li><p>具体实现可以因语言、框架、项目需求而异，但模式背后的思想和逻辑关系是通用的。</p>
</li>
</ul>
<p>举例说明：</p>
<ul>
<li><p>观察者模式（Observer Pattern）描述的是“一个对象状态变化时，通知所有依赖它的对象”，但不规定你用事件、回调还是消息队列实现。</p>
</li>
<li><p>单例模式（Singleton Pattern）描述的是“全局唯一实例”，但不关心你用静态变量、懒加载还是线程安全锁。<br>总结：<br>设计模式关注的是抽象的设计思想和对象关系，而不是具体实现细节。你的理解完全正确。</p>
</li>
</ul>
<h1 id="给我讲讲，图片的hsv是什么东西-为什么视觉识别需要用到这个"><a href="#给我讲讲，图片的hsv是什么东西-为什么视觉识别需要用到这个" class="headerlink" title="给我讲讲，图片的hsv是什么东西?为什么视觉识别需要用到这个?"></a>给我讲讲，图片的hsv是什么东西?为什么视觉识别需要用到这个?</h1><p>HSV是一种常用的颜色空间，全称是<strong>Hue（色相）、Saturation（饱和度）、Value（明度）</strong>。<br>它和我们常见的RGB（红绿蓝）颜色空间不同，HSV更符合人类对颜色的感知方式。</p>
<ul>
<li><strong>H（色相）</strong>：表示颜色的类型，比如红色、绿色、蓝色等，取值范围一般是0~360度。</li>
<li><strong>S（饱和度）</strong>：表示颜色的纯度，越高颜色越鲜艳，越低越灰白。</li>
<li><strong>V（明度）</strong>：表示颜色的亮度，越高越亮，越低越暗。</li>
</ul>
<h3 id="为什么视觉识别常用HSV？"><a href="#为什么视觉识别常用HSV？" class="headerlink" title="为什么视觉识别常用HSV？"></a>为什么视觉识别常用HSV？</h3><ol>
<li><strong>抗光照变化能力强</strong><br>HSV空间把颜色和亮度分开了，光照变化主要影响V（明度），而H（色相）和S（饱和度）基本不变，这样可以更稳定地识别颜色。</li>
<li><strong>颜色分割更直观</strong><br>在RGB空间下，同一种颜色在不同光照下RGB值变化很大，而在HSV空间下，色相（H）基本不变，便于用阈值分割出特定颜色区域。</li>
<li><strong>更接近人眼感知</strong><br>HSV空间的表示方式更符合人类对颜色的理解，比如我们说“红色”“绿色”其实就是色相（H）。</li>
</ol>
<h3 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h3><p>比如你要识别红色物体，在HSV空间下只需要判断H在红色范围内即可，而不用关心光照强弱带来的V变化。</p>
<hr>
<p><strong>总结：</strong><br>HSV让颜色识别更简单、更稳定，是视觉识别中特别常用的颜色空间。</p>
<h1 id="什么是哈希加盐"><a href="#什么是哈希加盐" class="headerlink" title="什么是哈希加盐?"></a>什么是哈希加盐?</h1><p><strong>加盐（Salting）</strong>就是给原始密码**添加一段随机字符串**，然后再进行哈希，以增加破解的难度。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">plaintext复制编辑原始密码：<span class="hljs-number">123456</span><br>随机盐：  x7!@K2<br><br>加盐后：  <span class="hljs-string">&quot;123456x7!@K2&quot;</span><br>哈希值：  MD5(<span class="hljs-string">&quot;123456x7!@K2&quot;</span>) =&gt; <span class="hljs-number">9</span>f1a3e...（不同了）<br></code></pre></td></tr></table></figure>

<ul>
<li>盐是<strong>每个用户随机生成的</strong>，并和哈希值一起存储在数据库中。</li>
<li>即使两个用户用相同密码，因为盐不同，最终哈希值也不同。</li>
</ul>
<hr>
<h2 id="✅-四、加盐哈希的好处"><a href="#✅-四、加盐哈希的好处" class="headerlink" title="✅ 四、加盐哈希的好处"></a>✅ 四、加盐哈希的好处</h2><table>
<thead>
<tr>
<th>问题</th>
<th>加盐能解决吗？</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>彩虹表攻击</td>
<td>✅ 防止</td>
<td>因为每次加盐都不同，彩虹表无法预制所有组合</td>
</tr>
<tr>
<td>相同密码哈希相同</td>
<td>✅ 防止</td>
<td>即使密码一样，加了不同的盐也会得出不同哈希</td>
</tr>
<tr>
<td>被盗哈希后能反推密码</td>
<td>❌ 不能完全防止</td>
<td>加盐只是增加破解难度，不能让哈希变得可逆</td>
</tr>
</tbody></table>
<hr>
<h2 id="🛠-五、哈希加盐的存储方式"><a href="#🛠-五、哈希加盐的存储方式" class="headerlink" title="🛠 五、哈希加盐的存储方式"></a>🛠 五、哈希加盐的存储方式</h2><p>数据库通常会<strong>同时存盐和哈希值</strong>：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">plaintext复制编辑用户名 |<span class="hljs-string"> 盐（Salt） </span>|<span class="hljs-string"> 哈希值</span><br><span class="hljs-string">-------</span>|<span class="hljs-string">------------</span>|<span class="hljs-string">----------------------------</span><br><span class="hljs-string">Alice  </span>|<span class="hljs-string"> x7!@K2     </span>|<span class="hljs-string"> 9f1a3ec1d...</span><br><span class="hljs-string">Bob    </span>|<span class="hljs-string"> Pz#09d     </span>|<span class="hljs-string"> 3ae2b1e3f...</span><br></code></pre></td></tr></table></figure>

<p>验证密码时：</p>
<ol>
<li>拿出用户的盐</li>
<li>拼接输入的密码</li>
<li>再哈希</li>
<li>和数据库中哈希值对比</li>
</ol>
<h1 id="syncthing这种软件到底是什么原理-在没有我提供公网Ip的情况下它是怎么进行文件同步的"><a href="#syncthing这种软件到底是什么原理-在没有我提供公网Ip的情况下它是怎么进行文件同步的" class="headerlink" title="syncthing这种软件到底是什么原理?在没有我提供公网Ip的情况下它是怎么进行文件同步的?"></a>syncthing这种软件到底是什么原理?在没有我提供公网Ip的情况下它是怎么进行文件同步的?</h1><p>Syncthing 是一种 <strong>去中心化</strong> 的文件同步工具，其核心原理是 <strong>点对点（P2P）传输</strong>，不依赖中央服务器，而是直接在设备之间建立连接进行文件同步。即使在 <strong>没有公网 IP</strong> 的情况下，它仍然可以通过以下机制实现同步：</p>
<hr>
<h3 id="1-设备发现机制（Discovery-Server）"><a href="#1-设备发现机制（Discovery-Server）" class="headerlink" title="1. 设备发现机制（Discovery Server）"></a><strong>1. 设备发现机制（Discovery Server）</strong></h3><p>Syncthing 使用 <strong>全球发现服务器（Global Discovery Server）</strong> 来帮助设备找到彼此：</p>
<ul>
<li>每个设备在启动时，会向发现服务器注册自己的 <strong>设备 ID</strong> 和 <strong>网络信息</strong>（如内网 IP 和端口）。</li>
<li>当另一台设备尝试连接时，它会查询发现服务器，获取目标设备的 <strong>最新网络位置</strong>，然后尝试直接建立连接。</li>
<li>如果设备在同一个局域网内，Syncthing 还能通过 <strong>本地广播（LAN Discovery）</strong> 自动发现彼此，无需依赖外部服务器。</li>
</ul>
<hr>
<h3 id="2-NAT-穿透（P2P-直连）"><a href="#2-NAT-穿透（P2P-直连）" class="headerlink" title="2. NAT 穿透（P2P 直连）"></a><strong>2. NAT 穿透（P2P 直连）</strong></h3><p>如果设备位于不同的局域网（如家庭 Wi-Fi 和公司网络），Syncthing 会尝试 <strong>NAT 穿透（打洞）</strong>：</p>
<ul>
<li>使用 <strong>UDP 打洞（UDP Hole Punching）</strong> 技术，让两个设备通过协商后的端口直接通信。</li>
<li>如果 NAT 类型支持（如 Full Cone NAT），设备可以直接建立 P2P 连接，无需第三方服务器中转。</li>
</ul>
<hr>
<h3 id="3-中继服务器（Relay-Server）"><a href="#3-中继服务器（Relay-Server）" class="headerlink" title="3. 中继服务器（Relay Server）"></a><strong>3. 中继服务器（Relay Server）</strong></h3><p>如果 <strong>NAT 穿透失败</strong>（如严格型 NAT），Syncthing 会使用 <strong>中继服务器（Relay Server）</strong> 进行数据中转：</p>
<ul>
<li>官方提供了一些公共中继服务器（如 <code>relays.syncthing.net</code>），用户也可以 <strong>自建私有中继</strong>。</li>
<li>数据经过中继时仍然是 <strong>端到端加密（TLS）</strong> 的，中继服务器无法解密文件内容。</li>
</ul>
<hr>
<h3 id="4-数据同步协议（BEP）"><a href="#4-数据同步协议（BEP）" class="headerlink" title="4. 数据同步协议（BEP）"></a><strong>4. 数据同步协议（BEP）</strong></h3><p>Syncthing 使用 <strong>Block Exchange Protocol（BEP）</strong> 进行文件同步：</p>
<ul>
<li>文件被分成 <strong>块（Blocks）</strong>，仅传输变化的块，提高效率。</li>
<li>采用 <strong>版本控制</strong>，可以保留历史版本，防止误删或冲突。</li>
</ul>
<hr>
<h3 id="5-安全性保障"><a href="#5-安全性保障" class="headerlink" title="5. 安全性保障"></a><strong>5. 安全性保障</strong></h3><ul>
<li><strong>设备认证</strong>：每个设备有唯一的 <strong>加密证书（Device ID）</strong>，只有授权的设备才能同步。</li>
<li><strong>端到端加密（TLS）</strong>：所有传输的数据都经过加密，即使经过中继服务器也无法窥探。</li>
<li><strong>无中央存储</strong>：文件不会上传到任何服务器，仅在用户设备之间传输。</li>
</ul>
<hr>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>Syncthing 在没有公网 IP 的情况下，仍然可以通过 <strong>发现服务器 + NAT 穿透 + 中继备份</strong> 的方式实现文件同步。它的去中心化设计使其在 <strong>隐私性、安全性和灵活性</strong> 上优于传统的云存储服务（如 Dropbox 或 Resilio Sync）。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%AC%94%E8%AE%B0/" class="category-chain-item">笔记</a>
  
  
    <span>></span>
    
  <a href="/categories/%E7%AC%94%E8%AE%B0/%E9%97%AE%E9%A2%98/" class="category-chain-item">问题</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>问题&amp;解决</div>
      <div>https://homovexillues.github.io/2024/03/29/问题&amp;解决/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Homo vexillues</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年3月29日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/03/29/C-sharp%E5%9F%BA%E7%A1%80/" title="C#基础">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">C#基础</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/03/27/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8-1-%E8%BD%AF%E4%BB%B6%E5%88%9B%E5%BB%BA/" title="代码大全-1-软件创建">
                        <span class="hidden-mobile">代码大全-1-软件创建</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
