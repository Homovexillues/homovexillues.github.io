<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>自动控制理论相关问题</title>
    <link href="/2025/06/04/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <url>/2025/06/04/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是闭环控制-什么是开环控制"><a href="#什么是闭环控制-什么是开环控制" class="headerlink" title="什么是闭环控制?什么是开环控制?"></a>什么是闭环控制?什么是开环控制?</h1><p><strong>闭环控制</strong>（Closed-loop control）是指系统在运行过程中，通过检测输出结果，并将其与期望值进行比较，根据偏差自动调整输入，从而实现对输出的精确控制。常见例子有空调的温度自动调节、自动驾驶等。</p><p><strong>开环控制</strong>（Open-loop control）则是指系统的输入不依赖于输出结果，控制器按照预定的程序或信号进行控制，不根据实际输出进行调整。比如普通的定时灌溉系统、微波炉加热等。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自动控制理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机视觉相关问题</title>
    <link href="/2025/05/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <url>/2025/05/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机视觉识别任务具体指啥"><a href="#计算机视觉识别任务具体指啥" class="headerlink" title="计算机视觉识别任务具体指啥?"></a>计算机视觉识别任务具体指啥?</h1><p>在计算机科学领域，使用OpenCV等工具进行的视觉识别，专业术语通常称为<strong>计算机视觉（Computer Vision）</strong>。具体到识别任务，还可以细分为：</p><ul><li><strong>目标检测（Object Detection）</strong>：识别图像或视频中所有目标的位置和类别。</li><li><strong>目标识别&#x2F;分类（Object Recognition&#x2F;Classification）</strong>：判断图像中目标的具体类别。</li><li><strong>图像分割（Image Segmentation）</strong>：将图像划分为有意义的区域，常见有语义分割和实例分割。</li><li><strong>特征提取（Feature Extraction）</strong>：从图像中提取关键特征（如边缘、角点、颜色直方图、SIFT、SURF等）。</li><li><strong>模式识别（Pattern Recognition）</strong>：识别图像中的特定模式或结构。</li><li><strong>图像处理（Image Processing）</strong>：对图像进行预处理、增强、变换等操作，为后续识别做准备。</li></ul><p>这些任务都属于<strong>计算机视觉</strong>的范畴，OpenCV是实现这些任务的常用开源库。</p><h1 id="图片的hsv是什么东西-为什么视觉识别需要用到这个"><a href="#图片的hsv是什么东西-为什么视觉识别需要用到这个" class="headerlink" title="图片的hsv是什么东西?为什么视觉识别需要用到这个?"></a>图片的hsv是什么东西?为什么视觉识别需要用到这个?</h1><p>HSV是一种常用的颜色空间，全称是<strong>Hue（色相）、Saturation（饱和度）、Value（明度）</strong>。<br>它和我们常见的RGB（红绿蓝）颜色空间不同，HSV更符合人类对颜色的感知方式。</p><ul><li><strong>H（色相）</strong>：表示颜色的类型，比如红色、绿色、蓝色等，取值范围一般是0~360度。</li><li><strong>S（饱和度）</strong>：表示颜色的纯度，越高颜色越鲜艳，越低越灰白。</li><li><strong>V（明度）</strong>：表示颜色的亮度，越高越亮，越低越暗。</li></ul><h3 id="为什么视觉识别常用HSV？"><a href="#为什么视觉识别常用HSV？" class="headerlink" title="为什么视觉识别常用HSV？"></a>为什么视觉识别常用HSV？</h3><ol><li><strong>抗光照变化能力强</strong><br>HSV空间把颜色和亮度分开了，光照变化主要影响V（明度），而H（色相）和S（饱和度）基本不变，这样可以更稳定地识别颜色。</li><li><strong>颜色分割更直观</strong><br>在RGB空间下，同一种颜色在不同光照下RGB值变化很大，而在HSV空间下，色相（H）基本不变，便于用阈值分割出特定颜色区域。</li><li><strong>更接近人眼感知</strong><br>HSV空间的表示方式更符合人类对颜色的理解，比如我们说“红色”“绿色”其实就是色相（H）。</li></ol><h3 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h3><p>比如你要识别红色物体，在HSV空间下只需要判断H在红色范围内即可，而不用关心光照强弱带来的V变化。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理相关问题</title>
    <link href="/2025/05/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <url>/2025/05/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="给我解释一下，GPIO上的TXD和RXD是什么"><a href="#给我解释一下，GPIO上的TXD和RXD是什么" class="headerlink" title="给我解释一下，GPIO上的TXD和RXD是什么?"></a>给我解释一下，GPIO上的TXD和RXD是什么?</h1><p>在树莓派的GPIO引脚中，<strong>TXD</strong> 和 <strong>RXD</strong> 分别指的是串口通信（UART）的<strong>发送端</strong>和<strong>接收端</strong>：</p><ul><li><p><strong>TXD（Transmit Data，发送数据）</strong><br>也叫 TX，树莓派通过这个引脚把数据“发出去”。在图中是 **GPIO 14 (TXD)**，引脚编号为 <strong>8</strong>。</p></li><li><p><strong>RXD（Receive Data，接收数据）</strong><br>也叫 RX，树莓派通过这个引脚“接收”外部设备发来的数据。在图中是 **GPIO 15 (RXD)**，引脚编号为 <strong>10</strong>。</p></li></ul><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ul><li>这两个引脚组成了树莓派的<strong>硬件串口（UART）</strong>，常用于和其他单片机、模块（如GPS、蓝牙、MCU等）进行串口通信。</li><li>通常<strong>TXD接对方的RXD，RXD接对方的TXD</strong>，实现数据互通。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>TXD</strong>：树莓派发数据出去的引脚</li><li><strong>RXD</strong>：树莓派收数据进来的引脚</li><li>主要用于串口通信（UART）</li></ul><h1 id="UART是什么的缩写-串口通信又是啥-什么原理-为什么我见到的有的串口是一个type-c的接口而不是一根针"><a href="#UART是什么的缩写-串口通信又是啥-什么原理-为什么我见到的有的串口是一个type-c的接口而不是一根针" class="headerlink" title="UART是什么的缩写?串口通信又是啥?什么原理?为什么我见到的有的串口是一个type-c的接口而不是一根针?"></a>UART是什么的缩写?串口通信又是啥?什么原理?为什么我见到的有的串口是一个type-c的接口而不是一根针?</h1><h1 id="01010101在Utf-8编码下是什么意思"><a href="#01010101在Utf-8编码下是什么意思" class="headerlink" title="01010101在Utf-8编码下是什么意思?"></a>01010101在Utf-8编码下是什么意思?</h1><p>01010101 是一个二进制数，转换为十进制是 85。<br>在 UTF-8 编码下，01010101 代表的字节是 0x55。</p><p>在 ASCII 表中，0x55 对应的字符是大写字母 <strong>U</strong>。</p><p>所以，01010101 在 UTF-8 编码下表示字符 <strong>U</strong>。</p><h1 id="所以，常见的Utf-8编码下，一个字符是8个比特也就是一个字节的"><a href="#所以，常见的Utf-8编码下，一个字符是8个比特也就是一个字节的" class="headerlink" title="所以，常见的Utf-8编码下，一个字符是8个比特也就是一个字节的?"></a>所以，常见的Utf-8编码下，一个字符是8个比特也就是一个字节的?</h1><p>不是所有字符在 UTF-8 编码下都是 8 个比特（1 个字节）。<br>UTF-8 是一种变长编码方式：</p><ul><li>英文等基本拉丁字符（ASCII 范围，U+0000 ~ U+007F）：<strong>1 个字节（8 位）</strong></li><li>欧洲等扩展字符（U+0080 ~ U+07FF）：<strong>2 个字节</strong></li><li>常用汉字等（U+0800 ~ U+FFFF）：<strong>3 个字节</strong></li><li>更高的 Unicode 字符（U+10000 ~ U+10FFFF）：<strong>4 个字节</strong></li></ul><p>所以，只有 ASCII 字符在 UTF-8 下是 1 个字节，其他字符会占用 2~4 个字节。</p><h1 id="那么，当面对一个32个比特的二进制数字的时候，utf-8编码又是怎么知道这是一个汉字还是四个字母的呢"><a href="#那么，当面对一个32个比特的二进制数字的时候，utf-8编码又是怎么知道这是一个汉字还是四个字母的呢" class="headerlink" title="那么，当面对一个32个比特的二进制数字的时候，utf-8编码又是怎么知道这是一个汉字还是四个字母的呢?"></a>那么，当面对一个32个比特的二进制数字的时候，utf-8编码又是怎么知道这是一个汉字还是四个字母的呢?</h1><p>这是 UTF-8 的一个重要特性：<strong>自描述性</strong>。<br>UTF-8 通过每个字节的高位（前缀位）来标识一个字符的长度和类型。</p><h3 id="具体原理"><a href="#具体原理" class="headerlink" title="具体原理"></a>具体原理</h3><ul><li><strong>单字节字符（ASCII）</strong>：最高位是 <code>0</code>，如 <code>0xxxxxxx</code>，只占 1 字节。</li><li>多字节字符：第一个字节有特定前缀，后续字节以10开头。<ul><li>2 字节：<code>110xxxxx 10xxxxxx</code></li><li>3 字节：<code>1110xxxx 10xxxxxx 10xxxxxx</code></li><li>4 字节：<code>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</code></li></ul></li></ul><h3 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h3><p>当解析一串二进制数据时，UTF-8 解码器会<strong>逐字节读取</strong>，根据每个字节的前缀判断当前字符占用多少字节，然后组合起来还原成字符。</p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>假设有 32 位二进制数据：</p><ul><li>如果是 <code>01010101 01010101 01010101 01010101</code>，每个字节高位都是 0，表示 4 个 ASCII 字符。</li><li>如果是 <code>11100101 10111000 10101101 01100001</code>，第一个字节以 <code>1110</code> 开头，表示 3 字节字符，后面跟着 2 个 <code>10</code> 开头的字节，最后一个字节高位是 0，表示 1 个 ASCII 字符。</li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><strong>UTF-8 通过每个字节的前缀位，自动区分字符边界和长度。</strong><br>所以，面对 32 位二进制数据，UTF-8 能准确区分是 4 个 ASCII 字符，还是 1 个汉字+1 个字母，还是其他组合。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面包店算法</title>
    <link href="/2025/04/27/%E9%9D%A2%E5%8C%85%E5%BA%97%E7%AE%97%E6%B3%95/"/>
    <url>/2025/04/27/%E9%9D%A2%E5%8C%85%E5%BA%97%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="莱斯利·兰伯特的面包店算法（Bakery-Algorithm）"><a href="#莱斯利·兰伯特的面包店算法（Bakery-Algorithm）" class="headerlink" title="莱斯利·兰伯特的面包店算法（Bakery Algorithm）"></a>莱斯利·兰伯特的面包店算法（Bakery Algorithm）</h1><p>莱斯利·兰伯特（Leslie Lamport）是一位著名的计算机科学家，他因在分布式系统和并发控制领域的杰出贡献而获得了2013年的图灵奖。他提出的面包店算法（Bakery Algorithm）是解决互斥问题的一个经典算法。</p><h2 id="面包店算法的背景"><a href="#面包店算法的背景" class="headerlink" title="面包店算法的背景"></a>面包店算法的背景</h2><p>面包店算法的灵感来源于现实生活中面包店的排队系统：顾客进入面包店时会拿一个号码牌，然后按照号码的顺序依次接受服务。这种简单而有效的机制被兰伯特应用到了计算机科学中，用于解决多进程或多线程环境下的互斥访问问题。</p><h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>面包店算法的核心思想包括：</p><ol><li><strong>取号阶段</strong>：当一个进程想要进入临界区时，它会获取一个比当前所有其他进程的号码都大的号码。</li><li><strong>比较阶段</strong>：进程会比较自己的号码与其他进程的号码，只有当自己的号码是最小的（或在号码相同的情况下，进程ID最小），才能进入临界区。</li><li><strong>释放阶段</strong>：进程离开临界区后，将自己的号码重置为0，表示不再需要访问临界区。</li></ol><h2 id="算法伪代码"><a href="#算法伪代码" class="headerlink" title="算法伪代码"></a>算法伪代码</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 初始化</span><br>choosing[i] = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 进程i是否正在选择号码</span><br><span class="hljs-built_in">number</span>[i] = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 进程i的号码，0表示不在队列中</span><br><br><span class="hljs-comment">// 进程i请求进入临界区</span><br>entering_critical_section(i):<br>    choosing[i] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 表示进程i正在选择号码</span><br>    <br>    <span class="hljs-comment">// 选择一个比所有其他进程号码都大的号码</span><br>    <span class="hljs-built_in">number</span>[i] = <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(<span class="hljs-built_in">number</span>[<span class="hljs-number">0</span>], <span class="hljs-built_in">number</span>[<span class="hljs-number">1</span>], ..., <span class="hljs-built_in">number</span>[n<span class="hljs-number">-1</span>]);<br>    <br>    choosing[i] = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 选号完成</span><br>    <br>    <span class="hljs-comment">// 等待所有其他进程完成选号</span><br>    <span class="hljs-keyword">for</span> j = <span class="hljs-number">0</span> to n<span class="hljs-number">-1</span>:<br>        <span class="hljs-keyword">while</span> choosing[j]:<br>            <span class="hljs-comment">// 等待进程j完成选号</span><br>            <br>    <span class="hljs-comment">// 等待轮到自己（号码最小的进程先进入）</span><br>    <span class="hljs-keyword">for</span> j = <span class="hljs-number">0</span> to n<span class="hljs-number">-1</span>:<br>        <span class="hljs-keyword">if</span> j != i:<br>            <span class="hljs-comment">// 等待直到进程j不在队列中，或者进程i的号码小于进程j的号码</span><br>            <span class="hljs-comment">// 或者号码相同但进程i的ID小于进程j的ID</span><br>            <span class="hljs-keyword">while</span> <span class="hljs-built_in">number</span>[j] != <span class="hljs-number">0</span> and (<span class="hljs-built_in">number</span>[i] &gt; <span class="hljs-built_in">number</span>[j] or <br>                  (<span class="hljs-built_in">number</span>[i] == <span class="hljs-built_in">number</span>[j] and i &gt; j)):<br>                <span class="hljs-comment">// 等待</span><br>    <br>    <span class="hljs-comment">// 现在进程i可以进入临界区了</span><br>    <br><span class="hljs-comment">// 进程i离开临界区</span><br>leaving_critical_section(i):<br>    <span class="hljs-built_in">number</span>[i] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 表示进程i不再需要访问临界区</span><br></code></pre></td></tr></table></figure><h2 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h2><ol><li><strong>公平性</strong>：面包店算法保证了先到先服务的公平性，避免了饥饿问题。</li><li><strong>无需硬件支持</strong>：不像其他一些互斥算法，面包店算法不需要特殊的硬件支持，可以纯软件实现。</li><li><strong>可扩展性</strong>：算法可以扩展到任意数量的进程。</li><li><strong>无死锁</strong>：算法保证不会发生死锁。</li><li><strong>无需中央协调者</strong>：是一种完全分布式的算法。</li></ol><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>面包店算法在以下场景中有重要应用：</p><ul><li>操作系统中的进程调度</li><li>分布式系统中的资源分配</li><li>数据库系统中的并发控制</li><li>多线程程序中的互斥访问</li></ul><h2 id="历史意义"><a href="#历史意义" class="headerlink" title="历史意义"></a>历史意义</h2><p>面包店算法是分布式计算领域的一个重要里程碑，它展示了如何在没有中央协调者的情况下实现公平的互斥访问。这一算法的思想影响了后来许多分布式算法的设计，也是莱斯利·兰伯特在分布式系统领域贡献的重要一部分，这些贡献最终使他获得了计算机科学的最高荣誉——图灵奖。</p><p>​        </p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浏览器快捷键</title>
    <link href="/2025/03/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2025/03/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="清理浏览器缓存"><a href="#清理浏览器缓存" class="headerlink" title="清理浏览器缓存"></a>清理浏览器缓存</h3><h4 id="Ctrl-Shift-Delete"><a href="#Ctrl-Shift-Delete" class="headerlink" title="Ctrl+Shift+Delete"></a>Ctrl+Shift+Delete</h4><p>适用于:</p><ul><li>Edge</li><li>Chrome</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快捷键</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟机的网络连接方式</title>
    <link href="/2025/03/07/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F/"/>
    <url>/2025/03/07/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>好的，我现在要帮用户理解VMware虚拟机、WSL虚拟机和Docker虚拟机的网络原理，以及它们如何与主机相连。首先，我需要回顾这些虚拟化技术的网络配置方式，确保自己理解正确，然后组织成用户容易理解的语言。<br>首先，用户可能对这些虚拟化工具的网络机制不太清楚，想了解它们各自的网络工作原理和连接方式。用户可能有使用这些工具的需求，或者在开发、测试环境中遇到网络问题需要解决。我需要分步骤解释每个虚拟机的网络类型，然后比较它们的异同。<br>首先，VMware虚拟机的网络模式，我记得主要有NAT、桥接、仅主机等模式。NAT是通过主机的IP进行转换，桥接是直接连接到物理网络，而仅主机则是内部网络。需要详细说明每种模式的原理，以及如何与主机通信。<br>然后是WSL。WSL2基于Hyper-V，默认使用NAT网络，但用户可能通过版本更新或者配置改变网络模式。WSL2的网络和主机之间是通过虚拟交换机连接的，可能涉及NAT和localhost转发。需要解释vEthernet适配器的作用，以及如何从主机访问WSL中的服务，比如端口转发。<br>接下来是Docker。Docker在Windows上通常使用Hyper-V，网络模式有bridge、host、none等。默认的bridge网络下，容器通过docker0虚拟网桥与主机通信，而端口映射通过iptables或Windows的类似机制实现。需要说明Docker的网络结构，包括NAT和端口转发，以及如何让容器与主机或其他容器通信。<br>用户可能还想知道这些虚拟机之间的互通性，比如是否能在VMware虚拟机中访问WSL或Docker中的服务，或者反之。这时候需要分析不同虚拟化技术的网络配置是否允许跨虚拟网络通信，比如是否在同一网段，或者需要配置路由规则。<br>另外，用户可能关心性能、安全性或配置复杂度的问题。比如，桥接模式虽然方便但可能暴露虚拟机到外部网络，NAT模式则更安全但配置稍复杂。需要指出各自的优缺点。<br>在整理回答时，应该先分别介绍每个虚拟机的网络原理，再进行比较总结。可能需要使用类比，比如将NAT比作路由器，桥接比作直接连接，帮助用户理解。<br>需要注意用户的技术水平，避免使用过多专业术语，用通俗的语言解释。同时，提供典型场景的例子，比如开发环境中如何配置网络让服务互通，或者如何解决常见的网络连接问题。<br>最后，检查是否有遗漏的部分，比如WSL1和WSL2的区别，或者Docker在Linux和Windows下的不同实现，但用户的问题可能集中在Windows环境下的情况，所以可以侧重这方面的解释。<br>总结下来，回答的结构应该是：分别解释VMware、WSL、Docker的网络原理，每种如何与主机相连，然后比较它们的异同点，最后给出常见应用场景或配置建议。确保逻辑清晰，层次分&#x2F;明，帮助用户全面理解。</p></blockquote><h3 id="VMware"><a href="#VMware" class="headerlink" title="VMware"></a>VMware</h3><h3 id="WSL-Hyper-v"><a href="#WSL-Hyper-v" class="headerlink" title="WSL(Hyper-v)"></a>WSL(Hyper-v)</h3><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><h3 id="Proxmox"><a href="#Proxmox" class="headerlink" title="Proxmox"></a>Proxmox</h3>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>虚拟机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#安装</title>
    <link href="/2025/03/07/C-Sharp%E5%AE%89%E8%A3%85/"/>
    <url>/2025/03/07/C-Sharp%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h4 id="SDK和Runtimes的区别是什么"><a href="#SDK和Runtimes的区别是什么" class="headerlink" title="SDK和Runtimes的区别是什么?"></a>SDK和Runtimes的区别是什么?</h4><ul><li><p><strong>SDK 即 Software Development Kit,软件开发工具包</strong></p></li><li><p><strong>Runtime 即运行时环境</strong></p></li><li><p>如果需要 <strong>开发</strong> 应用程序，应安装 <strong>SDK</strong>，因为它<strong>包含</strong>了**运行时环境(Runtime)<strong>和</strong>开发工具(SDK)**。</p></li><li><p>如果只需要 <strong>运行</strong> 已编译的应用程序，安装 <strong>Runtime</strong> 即可。</p></li></ul><p>比如:</p><ol><li><strong>JAVA</strong><ul><li><strong>SDK</strong>：Java Development Kit（JDK），包含编译器（<code>javac</code>）、运行时环境（JRE）和开发工具。</li><li><strong>Runtime</strong>：Java Runtime Environment（JRE），用于运行 Java 应用程序。</li></ul></li><li><strong>Python</strong>：<ul><li><strong>SDK</strong>：Python 安装包通常包含解释器、标准库和开发工具。</li><li><strong>Runtime</strong>：Python 解释器（如 CPython），用于运行 Python 脚本。</li></ul></li><li><strong>Node.js</strong>：<ul><li><strong>SDK</strong>：Node.js 安装包包含 <code>npm</code>（包管理工具）和运行时环境。</li><li><strong>Runtime</strong>：V8 引擎，用于运行 JavaScript 代码。</li></ul></li></ol><h4 id="在Windows上安装"><a href="#在Windows上安装" class="headerlink" title="在Windows上安装"></a>在Windows上安装</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">winget install Microsoft.DotNet.SDK.<span class="hljs-number">9</span> Microsoft.DotNet.AspNetCore.<span class="hljs-number">9</span> <br></code></pre></td></tr></table></figure><h4 id="在Linux上安装"><a href="#在Linux上安装" class="headerlink" title="在Linux上安装"></a>在Linux上安装</h4><p>经过多次尝试，使用给apt添加源的方式太慢了，tuna等国内镜像不包含dotnet，用snap安装位置不对且对dotnet tool的支持不好，最后发现还不如用微软官方的脚本安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://dot.net/v1/dotnet-install.sh -O dotnet-install.sh<br><span class="hljs-built_in">chmod</span> +x ./dotnet-install.sh<br>./dotnet-install.sh --version latest<br></code></pre></td></tr></table></figure><p>安装之后如果想要用csharprepl的话要编辑.bashrc或者你自己用的shell程序，吧dotnet tool安装的工具添加到环境变量中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$HOME</span>/.dotnet/tools<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ros2基础知识</title>
    <link href="/2025/02/21/Ros2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2025/02/21/Ros2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>详细中文教程详见此网站:<a href="http://dev.ros2.fishros.com/doc/Tutorials.html"> ROS 2 文档</a></p><h4 id="创建一个新的包"><a href="#创建一个新的包" class="headerlink" title="创建一个新的包"></a>创建一个新的包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># python</span><br>ros2 pkg create --build-type ament_python &lt;package_name&gt;<br><span class="hljs-comment"># C++</span><br>ros2 pkg create --build-type ament_cmake &lt;package_name&gt;<br></code></pre></td></tr></table></figure><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 编译所有包</span><br>colcon build<br><span class="hljs-comment"># 编译特定包</span><br>colcon build --packages-select &lt;package_name&gt;<br></code></pre></td></tr></table></figure><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ros2 run &lt;package_name&gt; &lt;node_name&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>微分与积分</title>
    <link href="/2025/02/17/%E5%BE%AE%E5%88%86%E4%B8%8E%E7%A7%AF%E5%88%86/"/>
    <url>/2025/02/17/%E5%BE%AE%E5%88%86%E4%B8%8E%E7%A7%AF%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p>在数学中，<strong>微分</strong>和<strong>积分</strong>是微积分学中的两个基本概念，它们描述了函数变化的不同方面，并且通过基本定理密切相关。</p><h3 id="1-微分"><a href="#1-微分" class="headerlink" title="1. 微分"></a>1. 微分</h3><p><strong>微分</strong>描述的是函数在某一点处的瞬时变化率。设有函数 $f(x)$，如果在点 $x$ 处存在下列极限：</p><p>$f’(x) &#x3D; \lim_{h \to 0} \frac{f(x+h)-f(x)}{h}$</p><p>则称 $f$ 在 $x$处可微，而 $f’(x)$ 就是 $f$ 的导数。导数反映了函数图像在某点的切线斜率，也就是函数变化的“速度”。</p><h3 id="2-积分"><a href="#2-积分" class="headerlink" title="2. 积分"></a>2. 积分</h3><p><strong>积分</strong>描述的是函数在某一区间内的累积量。常见的定积分定义如下：如果 f(x)f(x) 在闭区间 [a,b][a, b] 上连续，那么其定积分定义为</p><p>$\int_a^b f(x) , dx &#x3D; \lim_{n\to\infty} \sum_{i&#x3D;1}^{n} f(\xi_i) \Delta x$</p><p>这里我们将区间 [a,b][a, b] 分成 $n$ 个小区间，每个小区间的长度为 $\Delta x$（当 $n\to\infty$ 时 $\Delta x \to 0$），其中 $\xi_i$ 是每个小区间内的任意一点。定积分给出了函数 $f$ 在区间 [a,b][a, b] 上的“面积”或“累积量”。</p><h3 id="3-微分与积分之间的关系"><a href="#3-微分与积分之间的关系" class="headerlink" title="3. 微分与积分之间的关系"></a>3. 微分与积分之间的关系</h3><p><strong>微积分基本定理</strong>揭示了微分与积分之间的深刻联系，其内容可以分为两个部分：</p><ul><li><p><strong>第一部分</strong>：设 $f(x)$ 在 [a,b][a,b] 上连续，定义一个函数</p><p>$F(x) &#x3D; \int_a^x f(t) , dt.$</p><p>则 $F(x)$ 在 $(a, b)$ 内可微，且有</p><p>$F’(x) &#x3D; f(x).$</p><p>这说明积分运算实际上是“反微分”的过程，也就是说，对一个函数进行积分得到的累积函数 FF 的导数就是原来的函数 $f$。</p></li><li><p><strong>第二部分</strong>：如果 $f(x)$ 在 [a,b][a,b] 上连续，且 $F(x)$ 是 $f(x)$ 的一个原函数（即 $F’(x)&#x3D;f(x)$），那么有</p><p>$\int_a^b f(x) , dx &#x3D; F(b) - F(a).$</p><p>这就把定积分与反微分联系在了一起，表明计算定积分实际上可以通过求一个原函数来实现。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>微分</strong>（求导）揭示了函数的瞬时变化率，是局部性质的描述；</li><li><strong>积分</strong>（求积）则描述了函数在一个区间内的累积效应，是整体性质的描述；</li><li>微积分基本定理表明，积分和微分是互为逆运算：积分可以看作是“累积微分”而微分可以“还原”积分的结果。</li></ul><p>这就是微分与积分的基本概念及其内在关系。</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>知识点</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>电学的一些基本常识</title>
    <link href="/2025/02/17/%E7%94%B5%E5%AD%A6%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/"/>
    <url>/2025/02/17/%E7%94%B5%E5%AD%A6%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>“电度”实际上是指电能消耗量，是通过电功率随时间的积分来计算的。简单来说：</p><ul><li><p><strong>电功率</strong>：表示单位时间内电能的使用速率，单位是瓦（W）或千瓦（kW）。</p></li><li><p><strong>电能（电度）</strong>：是电功率在一段时间内的累计消耗，计算公式为 </p><p>​$$\text{电能} &#x3D; \text{电功率} \times \text{时间}$$</p></li><li><p>如果电功率用千瓦表示，时间用小时表示，那么得到的电能单位就是千瓦时（kWh）。</p></li></ul><p>例如，如果一个电器的功率为1千瓦（1 kW），使用2小时，那么它消耗的电能就是：</p><p>​$$1,\text{kW} \times 2,\text{h} &#x3D; 2,\text{kWh}$$</p><ul><li><strong>千瓦时（kWh）</strong>：是一个电能单位，表示1千瓦功率连续运行1小时所消耗的电能。它与焦耳（J）之间的换算关系为：$1,\text{kWh} &#x3D; 3.6 \times 10^6,\text{J}$</li></ul><p>总结一下：</p><ul><li><strong>电度</strong>（电能）是电功率（能量转换的速率）乘以时间得到的能量量。</li><li><strong>电功率</strong>决定了电能消耗的“快慢”，而电能（电度）则是电功率持续作用一段时间后的累计结果。</li><li><strong>千瓦时</strong>就是描述这种累计能量的单位。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows 网络共享文件</title>
    <link href="/2025/02/17/Windows%E7%BD%91%E7%BB%9C%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6/"/>
    <url>/2025/02/17/Windows%E7%BD%91%E7%BB%9C%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">net</span> user username password /add<br></code></pre></td></tr></table></figure><p>用此命令添加一个新的本地用户，在文件夹属性中选择网络共享，添加这个你新添加的本地用户，然后在内网中共享</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>Windows</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>四元数</title>
    <link href="/2025/02/14/%E5%9B%9B%E5%85%83%E6%95%B0/"/>
    <url>/2025/02/14/%E5%9B%9B%E5%85%83%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="四元数（Quaternions）简介"><a href="#四元数（Quaternions）简介" class="headerlink" title="四元数（Quaternions）简介"></a>四元数（Quaternions）简介</h3><p>四元数是一种扩展复数的数学概念，用于表示三维空间中的旋转。它们由 <strong>威廉·哈密顿（William Rowan Hamilton）</strong> 于 1843 年发明，主要用于计算机图形学、机器人学、航空航天等领域，以避免欧拉角和旋转矩阵的局限性（如万向节锁问题）。</p><hr><h3 id="1-四元数的定义"><a href="#1-四元数的定义" class="headerlink" title="1. 四元数的定义"></a>1. <strong>四元数的定义</strong></h3><p>四元数是一个四维的超复数，通常表示为：<br>$$<br>q &#x3D; a + b\mathbf{i} + c\mathbf{j} + d\mathbf{k}<br>$$<br>其中：</p><ul><li><p>$a$ 是实部（标量部分）。</p></li><li><p>$b\mathbf{i} + c\mathbf{j} + d\mathbf{k}$ 是虚部（向量部分）。</p></li><li><p>$\mathbf{i}, \mathbf{j}, \mathbf{k}$是虚数单位，满足以下关系：</p><p>$$<br>\mathbf{i}^2 &#x3D; \mathbf{j}^2 &#x3D; \mathbf{k}^2 &#x3D; \mathbf{i}\mathbf{j}\mathbf{k} &#x3D; -1<br>$$</p><p>$$<br>\mathbf{i}\mathbf{j} &#x3D; \mathbf{k}, \quad \mathbf{j}\mathbf{k} &#x3D; \mathbf{i}, \quad \mathbf{k}\mathbf{i} &#x3D; \mathbf{j}<br>$$</p><p>$$<br>\mathbf{j}\mathbf{i} &#x3D; -\mathbf{k}, \quad \mathbf{k}\mathbf{j} &#x3D; -\mathbf{i}, \quad \mathbf{i}\mathbf{k} &#x3D; -\mathbf{j}<br>$$</p></li></ul><p>四元数也可以写成向量形式：<br>$$<br>q &#x3D; [a, \mathbf{v}]<br>$$</p><p>其中 $\mathbf{v} &#x3D; (b, c, d)$是一个三维向量。</p><hr><h3 id="2-四元数的性质"><a href="#2-四元数的性质" class="headerlink" title="2. 四元数的性质"></a>2. <strong>四元数的性质</strong></h3><ol><li><p><strong>模长（Norm）</strong>：<br>四元数的模长定义为：<br>$$<br>|q| &#x3D; \sqrt{a^2 + b^2 + c^2 + d^2}<br>$$</p><p>如果 (|q| &#x3D; 1)，则称 (q) 为单位四元数。</p></li><li><p><strong>共轭四元数</strong>：<br>四元数的共轭定义为：<br>$$<br>q^* &#x3D; a - b\mathbf{i} - c\mathbf{j} - d\mathbf{k}<br>$$</p></li><li><p><strong>逆四元数</strong>：<br>如果 (q) 是一个非零四元数，则其逆为：</p><p>$$<br>q^{-1} &#x3D; \frac{q^*}{|q|^2}<br>$$<br>对于单位四元数，$q^{-1} &#x3D; q^*$。</p></li><li><p><strong>四元数乘法</strong>：<br>四元数乘法不满足交换律，即 $q_1 q_2 \neq q_2 q_1$。乘法规则由虚数单位的关系决定。</p></li></ol><hr><h3 id="3-四元数与旋转"><a href="#3-四元数与旋转" class="headerlink" title="3. 四元数与旋转"></a>3. <strong>四元数与旋转</strong></h3><p>四元数在三维空间中的旋转表示中非常有用。一个单位四元数可以表示绕一个轴旋转一定角度。</p><ol><li><p><strong>旋转表示</strong>：<br>给定旋转轴 $\mathbf{u} &#x3D; (u_x, u_y, u_z)$（单位向量）和旋转角度 (\theta)，对应的四元数为：<br>$$<br>q &#x3D; \cos\left(\frac{\theta}{2}\right) + \sin\left(\frac{\theta}{2}\right)(u_x\mathbf{i} + u_y\mathbf{j} + u_z\mathbf{k})<br>$$</p></li><li><p><strong>旋转操作</strong>：<br>对于一个点 (\mathbf{p} &#x3D; (x, y, z))，其旋转后的点 (\mathbf{p}’) 可以通过四元数乘法计算：<br>$$<br>\mathbf{p}’ &#x3D; q \mathbf{p} q^{-1}<br>$$</p><p>其中 (\mathbf{p}) 被表示为纯四元数 (0 + x\mathbf{i} + y\mathbf{j} + z\mathbf{k})。</p></li></ol><hr><h3 id="4-四元数的优点"><a href="#4-四元数的优点" class="headerlink" title="4. 四元数的优点"></a>4. <strong>四元数的优点</strong></h3><ol><li><strong>避免万向节锁（Gimbal Lock）</strong>：<br>欧拉角在特定情况下会导致万向节锁，而四元数没有这个问题。</li><li><strong>插值平滑</strong>：<br>四元数可以方便地进行球面线性插值（SLERP），用于平滑的动画过渡。</li><li><strong>计算效率高</strong>：<br>与旋转矩阵相比，四元数的存储和计算更高效。</li></ol><hr><h3 id="5-四元数的应用"><a href="#5-四元数的应用" class="headerlink" title="5. 四元数的应用"></a>5. <strong>四元数的应用</strong></h3><ol><li><strong>计算机图形学</strong>：<ul><li>用于表示和插值三维对象的旋转。</li><li>在游戏引擎（如Unity、Unreal Engine）中广泛使用。</li></ul></li><li><strong>机器人学</strong>：<ul><li>用于描述机器人的姿态和运动。</li></ul></li><li><strong>航空航天</strong>：<ul><li>用于飞行器的姿态控制。</li></ul></li><li><strong>虚拟现实（VR）和增强现实（AR）</strong>：<ul><li>用于头部和手部跟踪。</li></ul></li></ol><hr><h3 id="6-四元数与欧拉角、旋转矩阵的对比"><a href="#6-四元数与欧拉角、旋转矩阵的对比" class="headerlink" title="6. 四元数与欧拉角、旋转矩阵的对比"></a>6. <strong>四元数与欧拉角、旋转矩阵的对比</strong></h3><table><thead><tr><th>特性</th><th>四元数</th><th>欧拉角</th><th>旋转矩阵</th></tr></thead><tbody><tr><td><strong>表示方式</strong></td><td>4 个数（标量 + 向量）</td><td>3 个角度（如 roll, pitch, yaw）</td><td>3x3 矩阵</td></tr><tr><td><strong>万向节锁</strong></td><td>无</td><td>有</td><td>无</td></tr><tr><td><strong>插值</strong></td><td>平滑（SLERP）</td><td>不自然</td><td>不直接支持</td></tr><tr><td><strong>计算效率</strong></td><td>高</td><td>低</td><td>中等</td></tr><tr><td><strong>存储空间</strong></td><td>4 个浮点数</td><td>3 个浮点数</td><td>9 个浮点数</td></tr></tbody></table><hr><h3 id="7-示例：四元数旋转"><a href="#7-示例：四元数旋转" class="headerlink" title="7. 示例：四元数旋转"></a>7. <strong>示例：四元数旋转</strong></h3><p>假设我们有一个点 $\mathbf{p} &#x3D; (1, 0, 0)$，我们希望绕 (y) 轴旋转 90 度。</p><ol><li><p><strong>构造四元数</strong>：<br>旋转轴 (\mathbf{u} &#x3D; (0, 1, 0))，角度 (\theta &#x3D; 90^\circ)。<br>$$<br>q &#x3D; \cos\left(\frac{90^\circ}{2}\right) + \sin\left(\frac{90^\circ}{2}\right)(0\mathbf{i} + 1\mathbf{j} + 0\mathbf{k}) &#x3D; \frac{\sqrt{2}}{2} + \frac{\sqrt{2}}{2}\mathbf{j}<br>$$</p></li><li><p><strong>旋转点</strong>：<br>将 (\mathbf{p}) 表示为纯四元数 (0 + 1\mathbf{i} + 0\mathbf{j} + 0\mathbf{k})，计算：<br>$$<br>\mathbf{p}’ &#x3D; q \mathbf{p} q^{-1}<br>$$</p><p>结果为 (\mathbf{p}’ &#x3D; (0, 0, 1))。</p></li></ol><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>四元数是一种强大的数学工具，特别适合表示和计算三维空间中的旋转。它们避免了欧拉角的局限性，同时比旋转矩阵更高效。如果你对机器人、游戏开发或计算机图形学感兴趣，四元数是一个必须掌握的概念！</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PID控制器算法</title>
    <link href="/2025/02/12/PID%E6%8E%A7%E5%88%B6%E5%99%A8%E7%AE%97%E6%B3%95/"/>
    <url>/2025/02/12/PID%E6%8E%A7%E5%88%B6%E5%99%A8%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>PID算法（<strong>Proportional-Integral-Derivative</strong> 控制器）是工业控制中最常用的一种反馈控制算法。PID控制器通过计算误差并生成相应的控制输出，从而使系统的输出跟随目标值。PID控制器广泛应用于机器人控制、自动化控制、温度控制等领域。</p><h3 id="PID控制器的原理"><a href="#PID控制器的原理" class="headerlink" title="PID控制器的原理"></a>PID控制器的原理</h3><p>PID控制器基于三个主要的控制项来调整输出：</p><ol><li><strong>比例控制（P）</strong>：根据当前误差大小进行调整。</li><li><strong>积分控制（I）</strong>：根据历史误差的累积进行调整，解决持续的小误差问题。</li><li><strong>微分控制（D）</strong>：根据误差变化的速率进行调整，预测误差的趋势，提前做出响应，防止系统超调。</li></ol><h4 id="数学表达式"><a href="#数学表达式" class="headerlink" title="数学表达式"></a>数学表达式</h4><p>PID控制器的控制输出 $u(t)$ 可以表示为以下公式：<br>$$<br>u(t) &#x3D; K_p e(t) + K_i \int_{0}^{t} e(\tau) , d\tau + K_d \frac{de(t)}{dt}<br>$$</p><ul><li><p>$e(t)$ 是系统的<strong>误差</strong>，即目标值与当前值之间的差异：<br>$$<br>e(t) &#x3D; \text{目标值} - \text{实际值}<br>$$</p></li><li><p>$K_p$ 是比例增益，决定了比例控制的强度。</p></li><li><p>$K_i$ 是积分增益，决定了积分控制的强度。</p></li><li><p>$K_d$ 是微分增益，决定了微分控制的强度。</p></li></ul><h3 id="各个控制项的作用"><a href="#各个控制项的作用" class="headerlink" title="各个控制项的作用"></a>各个控制项的作用</h3><ol><li><p><strong>比例（P）控制</strong>：</p><ul><li>比例项是根据当前的误差 $e(t)$ 来调整输出。比例控制的目标是使得误差减小到最小。比例控制的输出与误差成正比，比例常数 $K_p$ 控制了误差与输出的关系。</li><li>当误差较大时，比例控制会快速地调整系统输出，以减少误差。</li></ul><p><strong>优点</strong>：反应迅速，可以有效减少大误差。</p><p><strong>缺点</strong>：可能导致系统有静态偏差（即误差不完全为零）。</p></li><li><p><strong>积分（I）控制</strong>：</p><ul><li>积分项是对误差进行积分计算。它考虑了误差随时间的累积，并通过将误差的历史信息纳入计算来纠正长期存在的小误差。</li><li>积分控制的作用是消除长期积累的小误差，使得系统能够最终达到目标值。</li></ul><p><strong>优点</strong>：可以消除长期误差（如静态偏差）。</p><p><strong>缺点</strong>：过多的积分作用可能导致系统过度反应，产生震荡。</p></li><li><p><strong>微分（D）控制</strong>：</p><ul><li>微分项是对误差变化速率的反应。微分控制预测误差的变化趋势，从而对系统输出做出提前反应，防止超调或震荡。</li><li>微分控制的作用是减少系统的响应时间，尤其是减少超调。</li></ul><p><strong>优点</strong>：可以有效减少系统的超调，改善系统稳定性。</p><p><strong>缺点</strong>：噪声可能会导致微分项不稳定，需要合适的滤波来处理。</p></li></ol><h3 id="PID控制器的工作流程"><a href="#PID控制器的工作流程" class="headerlink" title="PID控制器的工作流程"></a>PID控制器的工作流程</h3><p>PID控制器的基本工作流程如下：</p><ol><li><strong>测量误差</strong>：系统的输出与期望目标值之间的误差。</li><li><strong>计算比例项</strong>：将误差乘以比例增益 $K_p$，得到比例项。</li><li><strong>计算积分项</strong>：将误差进行积分并乘以积分增益 $K_i$，得到积分项。</li><li><strong>计算微分项</strong>：计算误差的变化率并乘以微分增益 $K_d$，得到微分项。</li><li><strong>加权求和</strong>：将三个项（比例项、积分项、微分项）加权求和，得到最终的控制输出。</li></ol><h3 id="调整PID参数"><a href="#调整PID参数" class="headerlink" title="调整PID参数"></a>调整PID参数</h3><p>PID控制器的关键是选择合适的 $K_p、K_i和 K_d$参数。不同的应用场景需要不同的参数设置。常见的调参方法有：</p><ul><li><strong>手动调节</strong>：通过实验和经验手动调整三个参数，直到系统表现出满意的控制效果。</li><li><strong>Ziegler-Nichols 方法</strong>：一种经典的调参方法，通过试探得到系统的临界增益和临界周期来计算合适的 PID 参数。</li><li><strong>自动调参</strong>：一些高级控制系统使用自动化调参算法来实时调整 PID 参数，以适应不同的系统行为。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>PID控制器通过实时计算误差并根据比例、积分、微分控制项来调整系统输出。比例项迅速反应误差，积分项消除静态误差，微分项预测未来趋势并减少超调。PID控制器广泛应用于许多自动化控制系统中，具有很强的鲁棒性和灵活性。</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vmware Tools灰色无法安装问题如何解决</title>
    <link href="/2025/02/07/VMware%20Tools%E7%81%B0%E8%89%B2%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3/"/>
    <url>/2025/02/07/VMware%20Tools%E7%81%B0%E8%89%B2%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<p>这个老哥的内容不错，Windows端可以这么解决<br><a href="https://blog.csdn.net/MelyLenient/article/details/109204228">VMware Tools灰色，无法直接安装解决办法【亲测有效】_vmware虚拟机安装虚拟机是灰色-CSDN博客</a></p><p>Linux端的话可以直接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install open-vm-tools<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>虚拟机</category>
      
      <category>Vmware</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一些数学概念</title>
    <link href="/2024/12/25/%E4%B8%80%E4%BA%9B%E6%95%B0%E5%AD%A6%E6%A6%82%E5%BF%B5/"/>
    <url>/2024/12/25/%E4%B8%80%E4%BA%9B%E6%95%B0%E5%AD%A6%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="闭式解"><a href="#闭式解" class="headerlink" title="闭式解"></a>闭式解</h2><p><strong>闭式解</strong>（Closed-form solution）是指通过有限次的基本数学运算（如加法、减法、乘法、除法、指数、对数等）以及常见的数学函数（如三角函数、指数函数、对数函数等）表示出来的解。简单来说，闭式解是可以直接写出且可以通过常规数学运算计算的精确解，而不是通过迭代、数值方法或求解过程来逼近的解。</p><h3 id="闭式解的特点："><a href="#闭式解的特点：" class="headerlink" title="闭式解的特点："></a>闭式解的特点：</h3><ol><li><strong>解析性</strong>：闭式解是一个明确的、通常通过有限步数即可得到的表达式。</li><li><strong>可计算性</strong>：闭式解提供了一个直接的公式，通过它可以立刻计算出解，而不需要进一步的求解过程。</li><li><strong>准确性</strong>：闭式解通常是精确的解，而不是近似解。</li></ol><h3 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h3><ol><li><p><strong>代数方程的闭式解</strong>： 例如，对于一元二次方程 ax2+bx+c&#x3D;0ax^2 + bx + c &#x3D; 0，可以通过求根公式直接得到闭式解：</p><p>x&#x3D;−b±b2−4ac2ax &#x3D; \frac{-b \pm \sqrt{b^2 - 4ac}}{2a}</p><p>这是一个典型的闭式解。</p></li><li><p><strong>微分方程的闭式解</strong>： 对于一些常见的微分方程，可以得到闭式解。例如，解一阶常微分方程 dydx&#x3D;ky\frac{dy}{dx} &#x3D; ky 的闭式解是：</p><p>y&#x3D;Cekxy &#x3D; C e^{kx}</p><p>其中 CC 是常数，kk 是常数。</p></li></ol><h3 id="非闭式解："><a href="#非闭式解：" class="headerlink" title="非闭式解："></a>非闭式解：</h3><p>与闭式解相对的概念是<strong>非闭式解</strong>或<strong>数值解</strong>。一些复杂的方程或问题可能无法通过有限的基本数学运算得到明确的解析解，这时我们通常采用数值方法来近似求解。</p><p>例如，某些微分方程或非线性方程的解可能无法通过简单的公式来表示，此时只能通过数值方法（如迭代法、有限差分法等）来求解。</p><h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h3><p>闭式解是问题的一个精确、直接的解，它以一个明确的数学表达式形式呈现，方便计算和理解。对于某些数学问题，闭式解存在且非常有效；而对于其他更复杂的问题，可能需要采用数值解法来近似解。</p><h2 id="两点间距离"><a href="#两点间距离" class="headerlink" title="两点间距离"></a>两点间距离</h2><h3 id="曼哈顿距离（Manhattan-Distance）"><a href="#曼哈顿距离（Manhattan-Distance）" class="headerlink" title="曼哈顿距离（Manhattan Distance）"></a>曼哈顿距离（Manhattan Distance）</h3><ul><li>又称“城市街区距离”或“L1范数”。</li><li>计算方式：两点在各坐标轴上的距离之和。</li><li>公式（二维）：<br><code>d = |x1 - x2| + |y1 - y2|</code></li><li>适用场景：只能沿坐标轴方向移动（如城市街道网格）。</li></ul><hr><h3 id="欧几里得距离（Euclidean-Distance）"><a href="#欧几里得距离（Euclidean-Distance）" class="headerlink" title="欧几里得距离（Euclidean Distance）"></a>欧几里得距离（Euclidean Distance）</h3><ul><li>又称“直线距离”或“L2范数”。</li><li>计算方式：两点之间的直线距离（勾股定理）。</li><li>公式（二维）：<br><code>d = sqrt((x1 - x2)^2 + (y1 - y2)^2)</code></li><li>适用场景：可以沿任意方向移动。</li></ul><hr><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h3><ul><li>曼哈顿距离：只能“拐弯”走格子。</li><li>欧几里得距离：直线最短距离。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>知识点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>英语短语</title>
    <link href="/2024/12/07/%E8%8B%B1%E8%AF%AD%E7%9F%AD%E8%AF%AD/"/>
    <url>/2024/12/07/%E8%8B%B1%E8%AF%AD%E7%9F%AD%E8%AF%AD/</url>
    
    <content type="html"><![CDATA[<ul><li><strong>formal parameter</strong> 形式参数</li><li><strong>call function</strong> 调用函数</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>English</tag>
      
      <tag>短语</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS61A笔记</title>
    <link href="/2024/12/02/CS61A%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/12/02/CS61A%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="Expression-Tree"><a href="#Expression-Tree" class="headerlink" title="Expression Tree"></a>Expression Tree</h3><p><img src="/../images/CS61A%E7%AC%94%E8%AE%B0/image-20241201164009726.png" alt="image-20241201164009726"></p><h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><p>python和C#的最大区别就是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br><span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>f = <span class="hljs-built_in">max</span><br></code></pre></td></tr></table></figure><p>函数是python这门语言的<strong>第一类对象</strong></p><p><strong>第一类对象</strong>（First-Class Objects）是指在编程语言中，可以像其他数据类型一样操作的对象，具备以下特性：</p><ol><li><p><strong>可以赋值给变量</strong>：你可以将它们赋值给一个变量。<code>f=max</code></p></li><li><p><strong>可以作为参数传递给函数</strong>：你可以将它们作为参数传递给函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">output_f</span>(<span class="hljs-params">f</span>):<br><span class="hljs-meta">... </span><span class="hljs-keyword">return</span> f(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>output_f(f)<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure></li><li><p><strong>可以作为返回值从函数返回</strong>：你可以将它们作为函数的返回值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_f</span>():<br><span class="hljs-meta">... </span>   <span class="hljs-keyword">return</span> f<br><span class="hljs-meta">&gt;&gt;&gt; </span>get_f()(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure></li><li><p><strong>可以存储在数据结构中</strong>：你可以将它们存储在数组、列表、字典等数据结构中。<code>f_list = [f,f]</code></p></li></ol><p>而在C#中，类和对象则是<strong>第一类对象</strong>,或者在有类的语言中这么说怪怪的，也许可以叫<strong>第一个公民</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123;<span class="hljs-keyword">get</span>;<span class="hljs-keyword">set</span>;&#125;<br>&#125;<br>Func&lt;<span class="hljs-built_in">string</span>,Person&gt; CreatePerson = (name)=&gt;<span class="hljs-keyword">new</span> Person &#123; Name = name &#125;;<br>Person p = CreatePerson(<span class="hljs-string">&quot;Alice&quot;</span>);<br>Console.WriteLine(p.Name);<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">f(x)=y<br>f(x)=<span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Hello,<span class="hljs-subst">&#123;x&#125;</span>&quot;</span>)<br>f(<span class="hljs-string">&quot;World&quot;</span>)=<span class="hljs-string">&quot;Hello,World&quot;</span><br><span class="hljs-comment">#so F word is Hello World</span><br><span class="hljs-comment">#用这个写法能让一个不懂编程的人最直观的明白什么是编程</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#frame 栈帧</span><br><span class="hljs-comment">#为什么下面这个写法可以执行</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">f</span>)<br><span class="hljs-meta">... </span><span class="hljs-keyword">return</span> mul(f,f)<br><span class="hljs-meta">&gt;&gt;&gt; </span>f(<span class="hljs-number">2</span>)<br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><img src="/../images/CS61A%E7%AC%94%E8%AE%B0/image-20241207181602537.png" alt="image-20241207181602537"></p><p>一个<strong>环境</strong>是一系列的<strong>帧</strong></p><p>一个帧是<strong>名称</strong>和<strong>值</strong>之间的绑定，在<strong>环境图</strong>中的一个方框，一个<strong>环境</strong>是这些<strong>帧</strong>的<strong>序列</strong>，可以是<strong>本地帧</strong>，后面跟着<strong>全局帧</strong>，一个<strong>名称</strong>，在求职时，会得到绑定到该名称的值，是在当前环境中该名称被发现的最早的帧中的值</p><p>如上面的那个例子，在执行<strong>f(2)<strong>的时候，先在方形函数的主题中查找某个名称，首先在本地帧中查找，找到</strong>f</strong>，将其绑定到2上，如果找不到，就在全局环境中找，发现<strong>mul</strong>在全局中对应的函数，然后传入<strong>f</strong>的值<strong>2</strong>进行操作，返回<strong>4</strong>，然后<strong>f(2)<strong>返回</strong>4</strong>。</p><p><img src="/../images/CS61A%E7%AC%94%E8%AE%B0/image-20241207181746252.png" alt="image-20241207181746252"></p><p><img src="/../images/CS61A%E7%AC%94%E8%AE%B0/image-20241207181839460.png" alt="image-20241207181839460"></p><p><img src="/../images/CS61A%E7%AC%94%E8%AE%B0/image-20241207222052970.png" alt="image-20241207222052970"></p><p><img src="/../images/CS61A%E7%AC%94%E8%AE%B0/image-20241207222256748.png" alt="image-20241207222256748"></p><p><img src="/../images/CS61A%E7%AC%94%E8%AE%B0/image-20241208163627095.png" alt="image-20241208163627095"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#为什么不能用</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">if_</span>(<span class="hljs-params">c,t,f</span>):<br>    <span class="hljs-keyword">if</span> c:<br>        <span class="hljs-keyword">return</span> t<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> f<br><span class="hljs-comment">#来代替</span><br><span class="hljs-keyword">if</span> x&gt;=<span class="hljs-number">0</span>:<br>    <span class="hljs-keyword">return</span> sqrt(x)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-comment">#？</span><br><span class="hljs-comment">#看看这两种实现，用于计算一个负数或者虚数的平方根</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">real_sqrt1</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> if_(x&gt;=<span class="hljs-number">0</span>,sqrt(x),<span class="hljs-number">0</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">real_sqrt2</span>(<span class="hljs-params">x</span>):<br>     <span class="hljs-keyword">if</span> x&gt;=<span class="hljs-number">0</span>:<br>         <span class="hljs-keyword">return</span> sqrt(x)<br>     <span class="hljs-keyword">else</span>:<br>         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-comment">#如果执行</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>real_sqrt(-<span class="hljs-number">16</span>)<br><span class="hljs-comment">#会发生什么?</span><br><span class="hljs-comment">#real_sqrt1</span><br>---&gt; <span class="hljs-number">10</span>     <span class="hljs-keyword">return</span> if_(x&gt;=<span class="hljs-number">0</span>,sqrt(x),<span class="hljs-number">0</span>)<br>ValueError: math domain error<br><span class="hljs-comment">#real_sqrt2</span><br><span class="hljs-number">0</span><br><span class="hljs-comment">#为什么?</span><br></code></pre></td></tr></table></figure><p>因为在定义函数的时候，函数主体是不会被计算或者说执行的，if-else的模式确保了当x为负数的时候你不会去计算它的平方根，**但是!**当sqrt(x)定义在参数里的话就不一样了，调用表达式不允许你跳过对调用表达式的部分进行评估，你会先计算<code>x&gt;=0</code>,<code>sqrt(x)</code>和<code>0</code>，然后自然而然的抛异常报错。</p><p><strong>这种将所有分支选项写在参数里的做法实际上相当于在执行的时候都执行了一遍</strong></p><h3 id="Higher-Order-Functions"><a href="#Higher-Order-Functions" class="headerlink" title="Higher-Order Functions"></a>Higher-Order Functions</h3><p>高阶函数实际上就像是OOP中的继承一样，为了解决代码复用的问题，如下图所示</p><p><img src="/../images/CS61A%E7%AC%94%E8%AE%B0/image-20241208231440673.png" alt="引用自码农翻身的函数式编程圣经"></p><p>但是要注意的是，高阶函数主要注重的是<strong>行为</strong>的复用，而不像是OOP一样，通过对象继承了<strong>状态</strong></p><p>现在是具体的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#下面这三个函数都计算总和</span><br><span class="hljs-comment">#计算到n为止的自然数的和</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum_naturals</span>(<span class="hljs-params">n</span>):<br>    total , k = <span class="hljs-number">0</span> , <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> k &lt;= n:<br>        total , k  = total + k , k + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> total<br><span class="hljs-comment">#计算到n为止的自然数的立方和</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum_cubes</span>(<span class="hljs-params">n</span>):<br>    total , k = <span class="hljs-number">0</span> , <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> k &lt;= n:<br>        total , k  = total + <span class="hljs-built_in">pow</span>(k,<span class="hljs-number">3</span>) , k + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> total<br><span class="hljs-comment">#计算这个式子的和</span><br><span class="hljs-comment">#8/(1*3)+8/(5*7)+8/(9*11)+...</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum_pi</span>(<span class="hljs-params">n</span>):<br>    total , k = <span class="hljs-number">0</span> , <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> k &lt;= n:<br>        total , k  = total + <span class="hljs-number">8</span>/(k*(k+<span class="hljs-number">2</span>)) , k + <span class="hljs-number">4</span><br>    <span class="hljs-keyword">return</span> total<br><span class="hljs-comment">#可以发现其中都复用了这个模式:</span><br><span class="hljs-keyword">def</span> &lt;name&gt;(x):<br>    total, k = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> k &lt;= x:<br>        total, k = total + &lt;term&gt;(k), &lt;<span class="hljs-built_in">next</span>&gt;(k)<br>    <span class="hljs-keyword">return</span> total<br></code></pre></td></tr></table></figure><p>这里引用一段翻译过后的书中原文:</p><blockquote><p>这个例子说明了计算机科学中两个相关的重要思想：首先，<strong>命名和函数</strong>使我们能将大量的复杂事物进行抽象。虽然每个函数定义都很简单，但我们的求解程序触发的计算过程非常复杂。其次，正是由于我们对 Python 语言有一个极其<strong>通用的求解过程</strong>，小的组件才能组合成复杂的程序。理解这解释程序的求解过程会有便于我们验证和检查我们创建的程序。</p></blockquote><p>这里的两个概念就涉及到了在编程中最经常遇到的两个问题:命名和顺序，起名字代表你思考好了这个函数或者这个变量的抽象，它代表的是什么东西，它会起到什么作用，理逻辑代表了你想清楚了你要如何使用你定义好的这些函数才能实现你想要的功能。</p><h3 id="Data-Abstraction"><a href="#Data-Abstraction" class="headerlink" title="Data Abstraction"></a>Data Abstraction</h3><p>将逻辑抽象成行为和方法，然后定义数据类型或者结构</p><p>在抽象定义方法的时候，有一个<strong>抽象屏障</strong>原则，即只抽象一层，下一层的抽象由下一层的方法去做，比如:</p><p>计算两个分数的乘法，就应该是<code>mul(x,y)</code>处理两个数的乘法和<code>ralation(x)</code>处理一个分数或者返回一个分数的方法的组合，而不是定义一个方法，这个方法直接处理两个特定格式的数据，它们是分数，然后做乘法。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS61A</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>历法知识</title>
    <link href="/2024/11/10/%E5%8E%86%E6%B3%95%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/11/10/%E5%8E%86%E6%B3%95%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<ol><li><strong>黄白赤道面</strong><ol><li>地球绕太阳转是在黄道平面上进行的</li><li>月亮绕地球转是在白道平面上进行的</li><li>地球自转是在赤道平面上进行的</li></ol></li><li><strong>当前历法</strong> <ol><li>公历(格里高利历):2024&#x2F;11&#x2F;11</li><li>农历:十月十一<ul><li>一种阴阳合历</li></ul></li></ol></li></ol><p>历法根据制定方式分为三种，</p><ul><li>阳历<ul><li>靠太阳</li></ul></li><li>阴历<ul><li>靠月亮</li><li>月亮从刚能看到叫望，最满叫朔，消失叫晦</li></ul></li><li>星辰历  <ul><li>靠北斗七星</li></ul></li></ul><p>公历的发展是这么个过程:</p><ul><li>罗马旧历<ul><li>阴历</li></ul></li><li>儒略历</li><li>格里高利历</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>历法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GPT4o问答-编程篇</title>
    <link href="/2024/11/05/GPT4o%E9%97%AE%E7%AD%94-%E7%BC%96%E7%A8%8B%E7%AF%87/"/>
    <url>/2024/11/05/GPT4o%E9%97%AE%E7%AD%94-%E7%BC%96%E7%A8%8B%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="我想知道的是，C-，C-，Rust，lua，Lisp来写这句话分别-coords-i-coords-i-1-for-i-in-range-0-len-coords-2-要怎么写"><a href="#我想知道的是，C-，C-，Rust，lua，Lisp来写这句话分别-coords-i-coords-i-1-for-i-in-range-0-len-coords-2-要怎么写" class="headerlink" title="我想知道的是，C#，C++，Rust，lua，Lisp来写这句话分别[(coords[i], coords[i + 1]) for i in range(0, len(coords), 2)]要怎么写?"></a>我想知道的是，C#，C++，Rust，lua，Lisp来写这句话分别[(coords[i], coords[i + 1]) for i in range(0, len(coords), 2)]要怎么写?</h2><p>你希望将以下 Python 代码片段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[(coords[i], coords[i + <span class="hljs-number">1</span>]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(coords), <span class="hljs-number">2</span>)]<br></code></pre></td></tr></table></figure><p>转化为不同语言的等效写法。这个 Python 代码实现的是：从 <code>coords</code> 列表中，每隔一个元素取两个元素，返回一个元组的列表。</p><p>让我们分别看一下在 C#、C++、Rust、Lua 和 Lisp 中如何实现相同的功能。</p><hr><h3 id="1-C"><a href="#1-C" class="headerlink" title="1. C#"></a>1. <strong>C#</strong></h3><p>在 C# 中，我们可以使用 <code>LINQ</code> 或手动循环来实现这个功能：</p><h4 id="使用-LINQ"><a href="#使用-LINQ" class="headerlink" title="使用 LINQ:"></a>使用 LINQ:</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Linq;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> coords = <span class="hljs-keyword">new</span>[] &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span> &#125;;<br>        <span class="hljs-keyword">var</span> result = coords.Where((<span class="hljs-keyword">value</span>, index) =&gt; index % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>                           .Select((<span class="hljs-keyword">value</span>, index) =&gt; (<span class="hljs-keyword">value</span>, coords[index + <span class="hljs-number">1</span>]))<br>                           .Where(tuple =&gt; tuple.Item2 != <span class="hljs-number">0</span>)<br>                           .ToList();<br><br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> pair <span class="hljs-keyword">in</span> result)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;(<span class="hljs-subst">&#123;pair.Item1&#125;</span>, <span class="hljs-subst">&#123;pair.Item2&#125;</span>)&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用循环"><a href="#使用循环" class="headerlink" title="使用循环:"></a>使用循环:</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> coords = <span class="hljs-keyword">new</span>[] &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span> &#125;;<br>        <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">new</span> List&lt;(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>)&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; coords.Length; i += <span class="hljs-number">2</span>)<br>        &#123;<br>            result.Add((coords[i], coords[i + <span class="hljs-number">1</span>]));<br>        &#125;<br><br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> pair <span class="hljs-keyword">in</span> result)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;(<span class="hljs-subst">&#123;pair.Item1&#125;</span>, <span class="hljs-subst">&#123;pair.Item2&#125;</span>)&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="2-C"><a href="#2-C" class="headerlink" title="2. C++"></a>2. <strong>C++</strong></h3><p>在 C++ 中，我们可以使用 <code>std::vector</code> 来存储结果，手动迭代并创建 <code>std::pair</code> 来模拟元组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; coords = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;;<br>    std::vector&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; result;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; coords.<span class="hljs-built_in">size</span>(); i += <span class="hljs-number">2</span>) &#123;<br>        result.<span class="hljs-built_in">push_back</span>(&#123;coords[i], coords[i + <span class="hljs-number">1</span>]&#125;);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pair : result) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="hljs-string">&quot;)\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="3-Rust"><a href="#3-Rust" class="headerlink" title="3. Rust"></a>3. <strong>Rust</strong></h3><p>在 Rust 中，我们可以使用 <code>chunks</code> 和 <code>map</code> 来实现类似的功能。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">coords</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span>: <span class="hljs-type">Vec</span>&lt;(<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>)&gt; = coords.<span class="hljs-title function_ invoke__">chunks</span>(<span class="hljs-number">2</span>)<br>        .<span class="hljs-title function_ invoke__">map</span>(|chunk| (chunk[<span class="hljs-number">0</span>], chunk[<span class="hljs-number">1</span>]))<br>        .<span class="hljs-title function_ invoke__">collect</span>();<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">pair</span> <span class="hljs-keyword">in</span> result &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;(&#123;&#125;, &#123;&#125;)&quot;</span>, pair.<span class="hljs-number">0</span>, pair.<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="4-Lua"><a href="#4-Lua" class="headerlink" title="4. Lua"></a>4. <strong>Lua</strong></h3><p>在 Lua 中，我们可以手动遍历数组，并使用表（tables）来存储结果。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua">coords = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;<br>result = &#123;&#125;<br><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, #coords, <span class="hljs-number">2</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">table</span>.<span class="hljs-built_in">insert</span>(result, &#123;coords[i], coords[i+<span class="hljs-number">1</span>]&#125;)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">for</span> _, pair <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(result) <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;(&quot;</span> .. pair[<span class="hljs-number">1</span>] .. <span class="hljs-string">&quot;, &quot;</span> .. pair[<span class="hljs-number">2</span>] .. <span class="hljs-string">&quot;)&quot;</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><hr><h3 id="5-Lisp-Common-Lisp"><a href="#5-Lisp-Common-Lisp" class="headerlink" title="5. Lisp (Common Lisp)"></a>5. <strong>Lisp (Common Lisp)</strong></h3><p>在 Lisp 中，我们可以通过递归或循环来处理列表，并返回一个新的列表。下面是使用 <code>loop</code> 来处理的示例。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lisp">(<span class="hljs-name">defun</span> pair-coordinates (<span class="hljs-name">coords</span>)<br>  (<span class="hljs-name">loop</span> for i from <span class="hljs-number">0</span> to (<span class="hljs-name">length</span> coords) by <span class="hljs-number">2</span><br>        collect (<span class="hljs-name">list</span> (<span class="hljs-name">nth</span> i coords) (<span class="hljs-name">nth</span> (<span class="hljs-number">1</span>+ i) coords))))<br><br>(<span class="hljs-name">let</span> ((<span class="hljs-name">coords</span> &#x27;(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span>)))<br>  (<span class="hljs-name">dolist</span> (<span class="hljs-name">pair</span> (<span class="hljs-name">pair-coordinates</span> coords))<br>    (<span class="hljs-name">format</span> <span class="hljs-literal">t</span> <span class="hljs-string">&quot;(&amp;A, &amp;A)~%&quot;</span> (<span class="hljs-name">first</span> pair) (<span class="hljs-name">second</span> pair))))<br></code></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>每种语言的实现方式略有不同，但基本思想是相同的：遍历 <code>coords</code> 数组，每次取两个元素组成一个元组（或相应类型的值）。Python 的列表推导式在其他语言中没有直接的等价物，通常会使用循环或集合方法（如 <code>map</code>、<code>filter</code> 或 <code>chunks</code>）来实现。</p><h2 id="我听到过这样一种说法，编程的本质是lambda代数，这个说法是否正确-这是什么意思？什么是lambda代数？在上面这个例子中又如何体现"><a href="#我听到过这样一种说法，编程的本质是lambda代数，这个说法是否正确-这是什么意思？什么是lambda代数？在上面这个例子中又如何体现" class="headerlink" title="我听到过这样一种说法，编程的本质是lambda代数，这个说法是否正确?这是什么意思？什么是lambda代数？在上面这个例子中又如何体现?"></a>我听到过这样一种说法，编程的本质是lambda代数，这个说法是否正确?这是什么意思？什么是lambda代数？在上面这个例子中又如何体现?</h2><h3 id="1-编程的本质是-λ-演算（Lambda-Calculus）吗？"><a href="#1-编程的本质是-λ-演算（Lambda-Calculus）吗？" class="headerlink" title="1. 编程的本质是 λ 演算（Lambda Calculus）吗？"></a>1. <strong>编程的本质是 λ 演算（Lambda Calculus）吗？</strong></h3><p>这个说法在某种程度上是正确的，尤其是在描述函数式编程范式时。编程的本质并不完全是 λ 演算，但 λ 演算的确为现代编程语言的理论基础提供了许多重要概念。特别是在函数式编程语言（如 Haskell、Lisp、Scala）中，λ 演算的概念更加突出，函数和操作可以作为一等公民。</p><h3 id="2-什么是-λ-演算？"><a href="#2-什么是-λ-演算？" class="headerlink" title="2. 什么是 λ 演算？"></a>2. <strong>什么是 λ 演算？</strong></h3><p>λ 演算（Lambda Calculus）是一种基于函数定义和应用的形式系统。它是计算机科学中描述计算和算法的一个理论模型。λ 演算的基本构成有：</p><ul><li><strong>变量</strong>：例如 <code>x</code>。</li><li><strong>抽象（函数定义）</strong>：<code>λx.x+1</code> 表示一个接受参数 <code>x</code> 并返回 <code>x + 1</code> 的函数。<code>λ</code>（lambda）是一个符号，用来表示函数抽象。</li><li><strong>应用</strong>：函数应用是将一个值传递给函数。例如，<code>(λx.x+1) 3</code> 表示应用函数 <code>λx.x+1</code> 给 3，结果是 <code>4</code>。</li></ul><p>λ 演算可以通过组合这些简单的规则来表示任何计算过程。虽然它看起来比较简洁，但它非常强大，可以模拟所有可计算的过程。</p><h4 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h4><ul><li><code>λx.x+1</code> 是一个简单的函数，它把输入 <code>x</code> 加 1。</li><li><code>(λx.x+1) 3</code> 就是将数字 <code>3</code> 作为参数传给该函数，结果是 <code>4</code>。</li></ul><h3 id="3-为什么说编程的本质是-λ-演算？"><a href="#3-为什么说编程的本质是-λ-演算？" class="headerlink" title="3. 为什么说编程的本质是 λ 演算？"></a>3. <strong>为什么说编程的本质是 λ 演算？</strong></h3><p>编程语言（尤其是函数式编程语言）在底层可以通过 λ 演算来理解。现代编程语言的许多概念，如匿名函数（lambda）、闭包、函数作为一等公民等，实际上都与 λ 演算密切相关。λ 演算描述了如何定义和操作函数，而编程语言中的许多操作（尤其是函数式编程语言）就是在执行类似 λ 演算的规则。</p><p>举例来说：</p><ul><li><strong>匿名函数</strong>（也称为 <strong>lambda 函数</strong>）在现代编程语言中广泛使用，实际上就是 λ 演算的一个直接体现。</li><li><strong>高阶函数</strong>（接受或返回函数的函数）也是 λ 演算的基本概念之一。</li><li><strong>函数应用</strong>：在 λ 演算中，函数应用（即将值传递给函数）是计算的核心，而大部分编程语言中的函数调用都可以用 λ 演算来解释。</li></ul><h3 id="4-λ-演算在上面示例中的体现"><a href="#4-λ-演算在上面示例中的体现" class="headerlink" title="4. λ 演算在上面示例中的体现"></a>4. <strong>λ 演算在上面示例中的体现</strong></h3><p>在你给出的 Python 示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[(coords[i], coords[i + <span class="hljs-number">1</span>]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(coords), <span class="hljs-number">2</span>)]<br></code></pre></td></tr></table></figure><p>这段代码本质上体现了 <strong>高阶函数</strong> 和 <strong>函数应用</strong> 的概念，和 λ 演算中的思想非常接近。</p><ul><li><p><strong><code>(coords[i], coords[i + 1])</code></strong> 部分是一个 <strong>元组构造函数</strong>，它接受 <code>i</code> 和 <code>i + 1</code> 作为输入，并返回一个包含这两个值的元组。这是一个 <strong>匿名函数</strong> 或 <strong>lambda 表达式</strong> 的形式。</p></li><li><p><strong><code>for i in range(0, len(coords), 2)</code></strong> 是对 <code>coords</code> 列表的迭代，类似于应用了某种 <strong>映射函数</strong>。如果你把它转化为 λ 演算的形式，可以理解为：</p><ul><li><code>λcoords. map(λi. (coords[i], coords[i+1]))</code>。<br>这里，<code>map</code> 表示对 <code>coords</code> 列表应用一个函数，这个函数对每一对相邻元素执行 <code>(coords[i], coords[i+1])</code>。</li></ul></li></ul><p>可以把这段 Python 代码想象成在进行 <strong>函数应用</strong>，每次你将一个索引值 <code>i</code> 应用到匿名函数 <code>λi.(coords[i], coords[i+1])</code> 上，得到的是一个包含坐标对的元组。</p><h3 id="5-总结：编程与-λ-演算的关系"><a href="#5-总结：编程与-λ-演算的关系" class="headerlink" title="5. 总结：编程与 λ 演算的关系"></a>5. <strong>总结：编程与 λ 演算的关系</strong></h3><ul><li><strong>编程语言</strong>，尤其是 <strong>函数式编程语言</strong>，通常在设计时就借鉴了 λ 演算的理论。很多概念（如匿名函数、高阶函数、闭包）都来源于 λ 演算。</li><li>λ 演算不仅是编程语言的理论基础，也为编程提供了简洁、灵活的表达方式。在 C#、C++、Rust、Lua 和 Lisp 等语言中，函数式编程的概念经常可以与 λ 演算的形式相联系。</li><li><strong>匿名函数</strong> 和 <strong>函数应用</strong> 是 λ 演算的核心概念。在你的例子中，列表推导式和使用 <code>map</code> 等高阶函数正是这些概念的体现。</li></ul><p>所以，<strong>编程的本质是 λ 演算</strong> 这个说法是有一定道理的，尤其是在函数式编程中，λ 演算的概念被广泛应用。它帮助我们理解函数、变量、应用等概念，尤其是在处理复杂的计算和数据转换时。</p><h2 id="那么面向对象编程和它又是什么关系呢-那些对于对象，类，实例的定义"><a href="#那么面向对象编程和它又是什么关系呢-那些对于对象，类，实例的定义" class="headerlink" title="那么面向对象编程和它又是什么关系呢?那些对于对象，类，实例的定义?"></a>那么面向对象编程和它又是什么关系呢?那些对于对象，类，实例的定义?</h2><p>你的理解是非常正确的，实际上编程语言和编程范式之间的关系确实是你所描述的那样。让我们从更深入的角度来探讨这个问题：</p><h3 id="1-编程范式的出现"><a href="#1-编程范式的出现" class="headerlink" title="1. 编程范式的出现"></a>1. <strong>编程范式的出现</strong></h3><p>编程范式（Programming Paradigms）是一种指导我们如何解决计算问题的思想方法或思维模式。在计算机科学的发展中，编程范式的演变通常是根据人类对如何设计、组织和管理程序的理解逐步演进的。因此，<strong>编程语言</strong> 是为了实现这些编程范式的理念而出现的。</p><p>最早的编程语言（如汇编、Fortran、C）主要聚焦于过程化编程，也就是通过函数或过程来描述问题的解决过程。随着时间的推移，程序员们逐渐意识到如何通过更高层次的抽象来更好地组织代码、提高可重用性和扩展性，逐步催生了 <strong>面向对象编程（OOP）</strong>、<strong>函数式编程（FP）</strong>、<strong>逻辑编程</strong> 等范式。</p><h3 id="2-编程语言对范式的实现"><a href="#2-编程语言对范式的实现" class="headerlink" title="2. 编程语言对范式的实现"></a>2. <strong>编程语言对范式的实现</strong></h3><p>不同的编程语言是按照各自的设计目标和历史背景来实现不同编程范式的，它们通过语法、特性和构造来提供对特定范式的支持。<strong>编程语言的特性逐步实现了对不同编程范式的适应</strong>，并且有些语言本身可能是多范式的，允许程序员根据需求选择合适的范式。</p><p>例如：</p><ul><li><strong>C 语言</strong>：最初是过程化语言，专注于通过一组函数或过程来组织程序。它的设计哲学非常接近于 <strong>结构化编程</strong>，它本身并不直接支持面向对象编程（OOP）特性。</li><li>**C++**：在 C 语言的基础上，添加了对面向对象编程的支持，如类、继承、多态等，支持 <strong>面向对象编程</strong>。</li><li><strong>Java</strong>：从一开始就是面向对象的语言，所有代码都需要在类内部进行。</li><li><strong>Python</strong>：最初是支持面向过程编程的，但后来也加入了对面向对象编程、函数式编程（如 lambda、map、filter 等）等范式的支持，成为多范式语言。</li><li><strong>Lisp 和 Haskell</strong>：这些语言更强调 <strong>函数式编程（FP）</strong>，并允许更高层次的抽象，如高阶函数和递归。</li></ul><h3 id="3-编程语言的抽象思想"><a href="#3-编程语言的抽象思想" class="headerlink" title="3. 编程语言的抽象思想"></a>3. <strong>编程语言的抽象思想</strong></h3><p>无论是哪种编程范式，核心的抽象思想始终是 <strong>如何组织计算过程和数据</strong>。每种范式都有它自己的抽象模型，用来帮助开发者更清晰、简洁、易扩展地解决问题。</p><ul><li><strong>过程式编程</strong>：核心思想是通过一系列顺序执行的步骤（函数或过程）来描述问题的解决过程。抽象的单位是函数。</li><li><strong>面向对象编程（OOP）</strong>：核心思想是通过对象来模拟现实世界的实体，类和对象是抽象的单位。OOP 强调封装、继承和多态，用类和对象来组织数据和行为。</li><li><strong>函数式编程（FP）</strong>：核心思想是通过不可变数据和纯函数来表达计算过程。函数是抽象的基本单位，强调通过组合函数来构建复杂的计算。</li><li><strong>声明式编程</strong>：关注 “做什么” 而非 “如何做”，强调通过声明数据或行为的性质来描述计算目标，而不是控制流程。SQL 和逻辑编程（如 Prolog）都是声明式编程的例子。</li></ul><h3 id="4-编程语言的演进过程"><a href="#4-编程语言的演进过程" class="headerlink" title="4. 编程语言的演进过程"></a>4. <strong>编程语言的演进过程</strong></h3><p>编程语言的演进通常是为了更好地满足开发者对高层次抽象的需求。从最初的 <strong>机器语言</strong> 和 <strong>汇编语言</strong>，到 <strong>结构化编程</strong>（如 C 语言），再到 <strong>面向对象编程</strong>（如 C++、Java），再到 <strong>函数式编程</strong>（如 Haskell、Scala、F#），每一种新的范式通常都是对前一种范式的扩展或补充，提供了更强的抽象能力和更灵活的方式来处理程序中的复杂问题。</p><p>例如，C 语言虽然是一种面向过程的语言，但它并没有内建类和对象的概念。为了引入面向对象的特性，C++ 作为 C 的超集引入了类（Class）、继承（Inheritance）、多态（Polymorphism）等 OOP 特性。Java 和 C# 则是在 C++ 的基础上进一步发展，强化了 OOP 的特性，加入了垃圾回收和跨平台特性，成为了面向对象的语言。</p><p>与此同时，随着计算机科学的发展和对抽象能力需求的提升， <strong>函数式编程</strong> 和 <strong>逻辑编程</strong> 也逐渐被重视，语言设计者开始注重如何让程序员更加便捷地使用高阶函数、递归、不可变数据等概念。</p><h3 id="5-编程范式和编程语言的关系是互相促进的"><a href="#5-编程范式和编程语言的关系是互相促进的" class="headerlink" title="5. 编程范式和编程语言的关系是互相促进的"></a>5. <strong>编程范式和编程语言的关系是互相促进的</strong></h3><ul><li><strong>范式的提出推动了语言的演进</strong>：编程范式（如 OOP、FP）为如何组织代码提供了新的思路，促使新的编程语言特性和工具的诞生。</li><li><strong>编程语言实现范式的特性</strong>：语言设计者会根据当时的技术需求和理论研究，逐步将这些范式融入到语言的设计中，提供新的语法和语义支持。</li><li><strong>范式的选择根据问题的需求</strong>：当你面对一个问题时，选择一种编程范式是基于你对问题的理解和对代码组织的需求。面向对象适用于需要复杂数据结构和行为建模的问题，函数式编程适用于需要高阶函数和不可变数据流的场景，而过程式编程适用于简洁直观的顺序执行问题。</li></ul><h3 id="6-核心思想的统一"><a href="#6-核心思想的统一" class="headerlink" title="6. 核心思想的统一"></a>6. <strong>核心思想的统一</strong></h3><p>虽然不同的编程语言有不同的实现方式，但它们的核心思想实际上是类似的：通过抽象来简化问题的解决过程。编程范式的关键是通过一种更适合问题本质的方式来组织代码、进行计算和管理状态。不同的范式给出了不同的解法，但它们都在追求程序可维护性、可扩展性、可理解性以及高效性。</p><h3 id="7-举例：面向对象与函数式的融合"><a href="#7-举例：面向对象与函数式的融合" class="headerlink" title="7. 举例：面向对象与函数式的融合"></a>7. <strong>举例：面向对象与函数式的融合</strong></h3><p>现代编程语言（如 <strong>Scala</strong>、<strong>Python</strong>、<strong>C#</strong> 等）已经允许开发者使用不同的编程范式来解决问题。例如：</p><ul><li><strong>Python</strong> 支持面向对象、函数式编程、命令式编程等多种范式。你可以在同一程序中混合使用类和对象、函数、生成器、装饰器等特性。</li><li><strong>C#</strong> 也是多范式的，支持 OOP 和 FP 特性，如 LINQ 使得在 C# 中可以进行类似函数式编程的操作，而类和对象仍然是其基础。</li></ul><p>这些语言之所以能做到这一点，是因为它们已经积累了不同编程范式的设计经验，并逐步将其抽象成可组合的语言特性，提供给开发者灵活的编程模型。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>编程范式</strong> 是解决问题的一种思维方式，它帮助程序员组织和构建程序。</li><li><strong>编程语言</strong> 是为了实现这些范式的思想和概念而设计的，语言通过提供不同的语法和特性来支持这些范式。</li><li>虽然不同的语言在实现细节上有所不同，但它们的核心思想是相通的：通过抽象和组织计算来解决实际问题。</li></ul><h2 id="泛型实际上是一种函数式编程的思想吗"><a href="#泛型实际上是一种函数式编程的思想吗" class="headerlink" title="泛型实际上是一种函数式编程的思想吗?"></a>泛型实际上是一种函数式编程的思想吗?</h2><p>泛型（Generics）与函数式编程之间确实有一些思想上的联系，但它们并不完全相同。我们可以通过几个角度来分析它们之间的关系。</p><h3 id="1-类型抽象与多态"><a href="#1-类型抽象与多态" class="headerlink" title="1. 类型抽象与多态"></a>1. <strong>类型抽象与多态</strong></h3><p>泛型主要关注的是类型的抽象，它允许我们编写能够处理不同类型的代码，而无需为每种类型单独编写代码。通过泛型，我们可以在定义数据结构或算法时，保持对类型的高度抽象，从而实现类型安全、重用性和灵活性。</p><p>而函数式编程强调的是函数的高阶抽象，它提倡通过函数的组合来处理计算，并且通常关注不可变数据和纯函数。泛型和函数式编程的共同点在于，它们都强调 <strong>抽象</strong> 和 <strong>多态性</strong>，泛型通过类型的抽象来实现多态性，函数式编程通过高阶函数和函数组合来实现灵活的多态操作。</p><h3 id="2-高阶函数与类型参数"><a href="#2-高阶函数与类型参数" class="headerlink" title="2. 高阶函数与类型参数"></a>2. <strong>高阶函数与类型参数</strong></h3><p>在函数式编程中，<strong>高阶函数</strong>（Higher-Order Functions）是非常重要的概念。高阶函数指的是能够接受其他函数作为参数或返回值的函数。泛型也可以看作是一种类似的抽象，允许函数接受或返回不同类型的数据。例如，在一些语言中，泛型和高阶函数有一定的相似性，因为我们可以定义一种接受或返回“泛型类型”的函数，从而达到代码复用和灵活性的目的。</p><p>例如，函数式编程中的 <code>map</code> 函数通常是一个高阶函数，它接受一个函数作为参数，应用到列表中的每一个元素。而如果你使用一个支持泛型的语言，比如 TypeScript 或 Java，<code>map</code> 函数的参数类型就可以是泛型的，这使得 <code>map</code> 可以作用于任何类型的集合，提供类型安全的操作。</p><h3 id="3-不可变性与类型安全"><a href="#3-不可变性与类型安全" class="headerlink" title="3. 不可变性与类型安全"></a>3. <strong>不可变性与类型安全</strong></h3><p>函数式编程强调不可变性（immutable data），即数据一旦创建就不能更改。泛型并不直接与不可变性相关，但在函数式编程中，通常会使用不可变数据结构与泛型类型进行配合，以确保类型的安全性和一致性。例如，在一些函数式编程语言中，你可能会用泛型定义一个不可变的容器类型，使得容器中的元素类型是抽象的，但一旦类型被确定，容器本身是不可修改的。</p><h3 id="4-类型系统与推导"><a href="#4-类型系统与推导" class="headerlink" title="4. 类型系统与推导"></a>4. <strong>类型系统与推导</strong></h3><p>现代语言中的泛型往往与类型推导密切相关，而函数式编程语言的类型系统通常也非常强大，能够支持复杂的类型推导和类型推理（如 Haskell）。因此，泛型和函数式编程语言的类型系统常常是紧密联系的，尤其在支持类型推导的语言中，泛型和函数式编程的思想会更有交集。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>泛型与函数式编程的确有思想上的重合，特别是在抽象、灵活性和代码重用方面。但泛型本身并不完全等同于函数式编程，它是一个更广泛的概念，主要侧重于类型层面的抽象。而函数式编程则更关注于如何使用纯函数、不可变数据、以及高阶函数等编程范式来组织和处理计算。二者在某些现代语言中可能互相交融，共同推动了更简洁、安全和灵活的代码设计。</p><h2 id="听你这个描述，泛型好像与类型这个系统更相关，那么我应该认为它属于面向对象编程的这个领域吗"><a href="#听你这个描述，泛型好像与类型这个系统更相关，那么我应该认为它属于面向对象编程的这个领域吗" class="headerlink" title="听你这个描述，泛型好像与类型这个系统更相关，那么我应该认为它属于面向对象编程的这个领域吗?"></a>听你这个描述，泛型好像与类型这个系统更相关，那么我应该认为它属于面向对象编程的这个领域吗?</h2><p>你可以说泛型在某种程度上与面向对象编程（OOP）有联系，但它并不局限于 OOP 的范畴，实际上，泛型作为一种编程概念和工具，已经在多种编程范式中得到了应用，包括面向对象编程、函数式编程，甚至是一些混合型语言中。让我们从几个角度来探讨这个问题：</p><h3 id="1-泛型与面向对象编程"><a href="#1-泛型与面向对象编程" class="headerlink" title="1. 泛型与面向对象编程"></a>1. <strong>泛型与面向对象编程</strong></h3><p>在传统的面向对象编程中，泛型确实有很强的联系，尤其是在 Java、C# 等语言中，泛型的使用通常与面向对象编程紧密结合。泛型使得面向对象编程更具灵活性和类型安全。</p><ul><li><p><strong>类型参数化</strong>：在 OOP 中，泛型允许你创建类型安全的数据结构或类，而不需要在编写类时明确指定类型。例如，在 Java 中，你可以定义一个 <code>List&lt;T&gt;</code> 类，而不需要指定具体的数据类型，<code>T</code> 就是一个类型参数，表示可以是任意类型。这样的类型参数化让代码能够同时处理不同类型的对象，又不失去类型安全。</p></li><li><p><strong>继承与多态</strong>：泛型与 OOP 的继承和多态机制可以很好地结合。你可以在类或接口中使用泛型来增强多态性，同时也能保证类型安全。例如，你可以创建一个泛型的 <code>Comparable&lt;T&gt;</code> 接口，它要求实现该接口的类能够与其他相同类型的对象进行比较，而具体的类型 <code>T</code> 会在实现时确定。</p></li></ul><p>这种模式在面向对象编程中非常常见，尤其是在需要高度重用和灵活性的场景下，泛型能够让开发者以更加通用的方式来设计类和方法。</p><h3 id="2-泛型与函数式编程"><a href="#2-泛型与函数式编程" class="headerlink" title="2. 泛型与函数式编程"></a>2. <strong>泛型与函数式编程</strong></h3><p>尽管泛型与 OOP 密切相关，但它并不仅限于面向对象编程。泛型也广泛应用于函数式编程中，特别是在现代编程语言（如 Haskell、Scala、F# 等）中。</p><ul><li><p><strong>类型抽象</strong>：在函数式编程中，泛型也经常用于类型抽象。比如，Haskell 中的 <code>Functor</code> 类型类，就可以理解为一种泛型容器，可以把某个类型包裹起来并对其中的值进行操作。类似地，<code>Option&lt;T&gt;</code> 或 <code>Either&lt;T&gt;</code> 类型也是泛型的，它们在处理可能的失败或缺失值时提供了一种安全的抽象方式。</p></li><li><p><strong>高阶类型</strong>：函数式编程中，除了高阶函数（接受函数作为参数或返回值的函数），还有高阶类型（接受类型作为参数或返回类型的类型）。这与泛型非常相似，因为泛型是实现高阶类型的一种方式。</p></li></ul><p>例如，在 Haskell 中，你可以定义一个泛型的 <code>map</code> 函数，它接受一个泛型容器（比如一个 List）和一个函数，将该函数应用于容器中的每个元素：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">map</span> :: <span class="hljs-type">Functor</span> f =&gt; (a -&gt; b) -&gt; f a -&gt; f b<br></code></pre></td></tr></table></figure><p>这个函数接受一个函数 <code>(a -&gt; b)</code> 和一个泛型容器 <code>f a</code>，并返回一个相同类型的容器 <code>f b</code>，其中 <code>f</code> 就是一个类型构造子，可以表示任何容器类型。</p><h3 id="3-泛型的跨范式应用"><a href="#3-泛型的跨范式应用" class="headerlink" title="3. 泛型的跨范式应用"></a>3. <strong>泛型的跨范式应用</strong></h3><p>由于泛型本质上是关于 <strong>类型抽象</strong> 的，它不依赖于特定的编程范式，因此在 OOP 和函数式编程中都能有效地应用。在 OOP 中，泛型通常用于创建灵活且类型安全的类和方法；而在函数式编程中，泛型则常常用来表达对不同类型容器和数据结构的抽象操作。</p><p>一些现代的语言，如 <strong>Scala</strong> 和 <strong>Swift</strong>，都结合了 OOP 和函数式编程的特点，并支持泛型。这使得开发者可以在同一语言中充分利用这两种范式，并且泛型成为它们共同的语言特性。</p><h3 id="4-泛型与模块化编程"><a href="#4-泛型与模块化编程" class="headerlink" title="4. 泛型与模块化编程"></a>4. <strong>泛型与模块化编程</strong></h3><p>此外，泛型在模块化编程、类型系统设计以及模板编程（如 C++）中都有着重要应用。它并不仅限于面向对象或函数式编程，而是一种广泛用于处理不同类型数据的通用工具。</p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>虽然泛型在面向对象编程中得到了广泛应用，它不仅属于 OOP 的一部分，泛型更是跨范式的概念。在 OOP 中，泛型使得代码更加灵活和类型安全，增强了多态性；在函数式编程中，泛型则用于类型的抽象和高阶操作。现代编程语言往往会结合 OOP 和函数式编程的优点，因此你可以在多种编程范式中看到泛型的身影。</p><p>所以，泛型并不仅仅属于面向对象编程，它是一个通用的编程概念，可以在不同的编程范式中使用。</p><h2 id="我是否可以这么理解，所谓的泛型方法，实际上就是将类的类型作为了一个参数输入进了函数中"><a href="#我是否可以这么理解，所谓的泛型方法，实际上就是将类的类型作为了一个参数输入进了函数中" class="headerlink" title="我是否可以这么理解，所谓的泛型方法，实际上就是将类的类型作为了一个参数输入进了函数中?"></a>我是否可以这么理解，所谓的泛型方法，实际上就是将类的类型作为了一个参数输入进了函数中?</h2><p>是的，你的理解是正确的！<strong>泛型方法</strong>的核心思想，正是通过将类型作为参数传递给函数（或方法），从而实现 <strong>类型参数化</strong>，使得方法能够适用于不同的类型。</p><p>让我们进一步细化这个概念：</p><h3 id="1-泛型方法的定义"><a href="#1-泛型方法的定义" class="headerlink" title="1. 泛型方法的定义"></a>1. <strong>泛型方法的定义</strong></h3><p>在大多数支持泛型的编程语言中，泛型方法是指一种方法，它的参数类型（或者返回类型）不是预先固定的，而是通过类型参数（通常由用户在调用时指定）来动态确定的。</p><p>换句话说，<strong>泛型方法</strong>可以看作是把类型作为一种“参数”传递给方法，让方法可以在不同的类型上执行，而无需重复编写多个不同类型的实现。</p><h3 id="2-泛型方法的工作原理"><a href="#2-泛型方法的工作原理" class="headerlink" title="2. 泛型方法的工作原理"></a>2. <strong>泛型方法的工作原理</strong></h3><p>当你定义一个泛型方法时，你不仅是在定义方法的行为，还在定义<strong>一种模板</strong>，这个模板能够根据调用时提供的类型，自动适配不同的类型实例。</p><p>例如，在 Java 中，你可以这样定义一个泛型方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">(T[] array)</span> &#123;<br>    <span class="hljs-keyword">for</span> (T element : array) &#123;<br>        System.out.println(element);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>&lt;T&gt;</code> 就是泛型类型参数，它代表了一个 <strong>类型占位符</strong>，在方法执行时，<code>T</code> 会被具体的类型所替代。<code>T[] array</code> 表示这个方法接受一个数组类型的参数，但该数组的元素类型并没有预先固定，而是由调用者传入时决定的。</p><h3 id="3-泛型类型作为参数"><a href="#3-泛型类型作为参数" class="headerlink" title="3. 泛型类型作为参数"></a>3. <strong>泛型类型作为参数</strong></h3><p>可以看到，这个方法中，类型 <code>T</code> 作为一个<strong>类型参数</strong>传递给了方法。当你调用 <code>printArray</code> 方法时，类型 <code>T</code> 会被你传入的实际类型（如 <code>Integer</code>、<code>String</code> 等）替代。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer[] intArray = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>String[] strArray = &#123;<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>&#125;;<br><br>printArray(intArray);  <span class="hljs-comment">// T 被替换为 Integer</span><br>printArray(strArray);  <span class="hljs-comment">// T 被替换为 String</span><br></code></pre></td></tr></table></figure><p>这里，<code>T</code> 的值是由调用者提供的，因此我们可以在同一个 <code>printArray</code> 方法中处理不同类型的数组。</p><h3 id="4-类类型作为参数"><a href="#4-类类型作为参数" class="headerlink" title="4. 类类型作为参数"></a>4. <strong>类类型作为参数</strong></h3><p>你提到“将类的类型作为一个参数输入进了函数中”，这在泛型的实际应用中也是成立的，尤其是当我们处理<strong>类型本身</strong>（而不仅仅是数据值）时。例如，Java 中有时会传递 <code>Class&lt;T&gt;</code> 类型，来获取关于某个类型的信息，或动态地创建类型实例。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">createInstance</span><span class="hljs-params">(Class&lt;T&gt; clazz)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">return</span> clazz.getDeclaredConstructor().newInstance();<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法接收一个 <code>Class&lt;T&gt;</code> 类型的参数，<code>T</code> 就是类的类型（即类型的占位符）。通过 <code>clazz</code> 参数，你可以动态创建 <code>T</code> 类型的实例。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> createInstance(Person.class);  <span class="hljs-comment">// 创建一个 Person 类型的对象</span><br></code></pre></td></tr></table></figure><p>这里，<code>Person.class</code> 就是将 <code>Person</code> 类的类型传递给了泛型方法 <code>createInstance</code>，而方法本身会在运行时通过这个类型创建相应的实例。</p><h3 id="5-泛型方法的好处"><a href="#5-泛型方法的好处" class="headerlink" title="5. 泛型方法的好处"></a>5. <strong>泛型方法的好处</strong></h3><p>泛型方法的好处是显而易见的：</p><ul><li><strong>代码复用</strong>：你可以用一个方法处理不同类型的数据，而不需要为每个类型编写单独的实现。</li><li><strong>类型安全</strong>：泛型方法能保证类型的安全性，在编译时检查类型，避免了类型转换错误。</li><li><strong>灵活性</strong>：你可以动态指定类型，使得方法能够在运行时适应不同的类型需求。</li></ul><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. <strong>总结</strong></h3><p>简而言之，泛型方法确实可以理解为“将类型作为参数传递给方法”，但这种类型参数的传递不仅限于数据本身，还可以涵盖对类型（类）的操作。通过这种方式，泛型方法能够在运行时处理不同类型的数据，同时保持类型安全和代码的通用性。</p><p>在很多支持泛型的语言中，泛型方法和泛型类的概念是相辅相成的，帮助开发者编写更加灵活、可重用、类型安全的代码。</p><h2 id="那么，我就有了另一个疑惑，虽然我写泛型方法很简单，但是语言在背后的实现是怎样的呢-难道我在调用一个语言中已有的泛型方法的时候，语言在提供的代码里将所有支持的类型都实现一遍-C-语言是怎么实现对泛型方法的支持的呢"><a href="#那么，我就有了另一个疑惑，虽然我写泛型方法很简单，但是语言在背后的实现是怎样的呢-难道我在调用一个语言中已有的泛型方法的时候，语言在提供的代码里将所有支持的类型都实现一遍-C-语言是怎么实现对泛型方法的支持的呢" class="headerlink" title="那么，我就有了另一个疑惑，虽然我写泛型方法很简单，但是语言在背后的实现是怎样的呢?难道我在调用一个语言中已有的泛型方法的时候，语言在提供的代码里将所有支持的类型都实现一遍?C#语言是怎么实现对泛型方法的支持的呢?"></a>那么，我就有了另一个疑惑，虽然我写泛型方法很简单，但是语言在背后的实现是怎样的呢?难道我在调用一个语言中已有的泛型方法的时候，语言在提供的代码里将所有支持的类型都实现一遍?C#语言是怎么实现对泛型方法的支持的呢?</h2><p>这是一个非常好的问题！你提到的疑惑触及了泛型在编译器和运行时如何实现的核心机制。确实，泛型方法在语言设计和实现中涉及到一些复杂的概念，尤其是如何在语言背后支持泛型而不导致代码膨胀或者性能问题。我们可以通过 <strong>类型擦除</strong> 和 <strong>具体化</strong> 这两个关键概念来理解语言是如何支持泛型的。</p><p>下面，我将详细解释 C# 如何实现对泛型方法的支持，同时也会简要提到其他语言（比如 Java）中类似的实现方式。</p><h3 id="1-C-中泛型方法的实现原理"><a href="#1-C-中泛型方法的实现原理" class="headerlink" title="1. C# 中泛型方法的实现原理"></a>1. <strong>C# 中泛型方法的实现原理</strong></h3><p>C# 支持 <strong>类型参数化</strong>，它通过 <strong>泛型类型</strong> 和 <strong>泛型方法</strong> 来实现代码的通用性。泛型方法允许你定义一种模板方法，这个方法能够适用于不同类型的数据，而不需要为每种类型编写不同的实现。</p><p>在 C# 中，泛型的实现方式是通过 <strong>泛型类型的具体化</strong> 来完成的。具体化就是指在编译时，编译器会根据调用时使用的实际类型，生成不同的类型代码。这是 C# 泛型支持的核心原理。与此不同，C# 并不会在运行时动态生成代码或创建类型，而是通过编译时的类型推导来生成所需的具体化代码。</p><h3 id="2-编译时的类型具体化"><a href="#2-编译时的类型具体化" class="headerlink" title="2. 编译时的类型具体化"></a>2. <strong>编译时的类型具体化</strong></h3><p>当你编写一个泛型方法时，编译器会在编译期间生成该方法的具体实现，具体化的实现会针对每一种不同的类型（即调用时传入的类型）生成相应的代码。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T <span class="hljs-keyword">value</span></span>)</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-keyword">value</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>假设你调用这个方法两次，分别使用了 <code>int</code> 和 <code>string</code> 类型：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Print(<span class="hljs-number">123</span>);   <span class="hljs-comment">// T 被替换为 int</span><br>Print(<span class="hljs-string">&quot;abc&quot;</span>); <span class="hljs-comment">// T 被替换为 string</span><br></code></pre></td></tr></table></figure><p>在这种情况下，C# 编译器会生成两个方法版本：</p><ol><li>一个是 <code>Print&lt;int&gt;</code>，专门处理 <code>int</code> 类型的输入；</li><li>另一个是 <code>Print&lt;string&gt;</code>，专门处理 <code>string</code> 类型的输入。</li></ol><p>这个过程称为 <strong>泛型方法的具体化</strong>。编译器会为每个具体类型生成相应的代码，因此你最终不会看到针对每个类型都进行重复的代码实现，而是针对每个类型生成单独的代码。</p><h3 id="3-类型擦除（Type-Erasure）与-C-的不同"><a href="#3-类型擦除（Type-Erasure）与-C-的不同" class="headerlink" title="3. 类型擦除（Type Erasure）与 C# 的不同"></a>3. <strong>类型擦除（Type Erasure）与 C# 的不同</strong></h3><p>Java 在实现泛型时采用了 <strong>类型擦除</strong>（Type Erasure）的机制，而 C# 没有完全使用这种方法。让我们简单了解一下类型擦除和它与 C# 实现的区别。</p><h4 id="类型擦除（Type-Erasure）"><a href="#类型擦除（Type-Erasure）" class="headerlink" title="类型擦除（Type Erasure）"></a><strong>类型擦除（Type Erasure）</strong></h4><p>在 Java 中，泛型是 <strong>编译时类型安全</strong> 的，但是它使用 <strong>类型擦除</strong> 来简化运行时的实现。也就是说，泛型的类型信息会在编译时被擦除，最终在字节码中，所有泛型类型都会被替换为原始类型（通常是 <code>Object</code>，或者在限定类型时是某个父类）。这意味着在运行时，Java 的泛型没有保留任何类型信息，只保留了原始类型信息。</p><p>例如，Java 中的泛型方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(T value)</span> &#123;<br>    System.out.println(value);<br>&#125;<br></code></pre></td></tr></table></figure><p>经过编译后，会转化成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(Object value)</span> &#123;<br>    System.out.println(value);<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，在 Java 中，所有类型检查和类型转换发生在编译时，运行时并没有类型参数的概念。</p><h4 id="C-的实现"><a href="#C-的实现" class="headerlink" title="C# 的实现"></a><strong>C# 的实现</strong></h4><p>而 C# 没有使用类型擦除，而是通过 <strong>生成具体化的代码</strong> 来保留类型信息。具体来说，C# 使用的是 <strong>泛型类型的具体化</strong>，而不是类型擦除。泛型方法在 C# 编译时会根据调用时的类型生成不同的代码，而不是在运行时丢失类型信息。因此，在 C# 中，泛型方法会根据类型生成不同的版本，而不像 Java 那样在运行时丢失泛型类型信息。</p><h3 id="4-性能和内存管理"><a href="#4-性能和内存管理" class="headerlink" title="4. 性能和内存管理"></a>4. <strong>性能和内存管理</strong></h3><p>虽然 C# 在编译时会生成多个方法的具体化版本，但它采取了优化措施以避免不必要的内存开销和代码膨胀。比如，对于相同的泛型类型参数（例如 <code>int</code> 和 <code>float</code>），C# 编译器可以将它们共享相同的底层实现，从而节省内存。</p><p>此外，在 C# 中，如果你定义的泛型类型与某些类型有共享的底层实现（例如，<code>int</code> 和 <code>long</code> 类型有共享的基础实现），C# 编译器可能会采用<strong>共享实现</strong>，避免生成完全独立的代码。这样做可以减少代码生成的数量，同时提高性能。</p><h3 id="5-反射与泛型"><a href="#5-反射与泛型" class="headerlink" title="5. 反射与泛型"></a>5. <strong>反射与泛型</strong></h3><p>C# 还允许通过反射机制来动态地处理泛型类型。这使得在运行时也可以进行泛型类型的操作。比如，你可以通过反射动态地调用泛型方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">MethodInfo method = <span class="hljs-keyword">typeof</span>(YourClass).GetMethod(<span class="hljs-string">&quot;Print&quot;</span>);<br>MethodInfo generic = method.MakeGenericMethod(<span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">int</span>));<br>generic.Invoke(yourObject, <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[] &#123; <span class="hljs-number">123</span> &#125;);<br></code></pre></td></tr></table></figure><p>这段代码演示了如何通过反射动态地调用一个泛型方法并指定具体的类型。这个过程虽然涉及到运行时反射，但通常泛型的实际方法调用是通过编译时生成的具体方法来完成的。</p><h3 id="6-总结-1"><a href="#6-总结-1" class="headerlink" title="6. 总结"></a>6. <strong>总结</strong></h3><ul><li><strong>C#</strong> 支持泛型方法的方式主要依赖 <strong>编译时类型具体化</strong>，即在编译时生成不同类型版本的代码，而不是在运行时动态创建。</li><li><strong>Java</strong> 则采用了 <strong>类型擦除</strong> 的方式，在编译时擦除类型信息，并在运行时只保留原始类型（通常是 <code>Object</code>）。</li><li>C# 的方法调用与类型具体化的机制在编译时就决定了它的效率，避免了类型擦除可能带来的性能损失。</li></ul><p>这种编译时的 <strong>类型具体化</strong> 是 C# 泛型支持的核心，不仅保证了类型安全，还有效避免了运行时类型推断的开销，同时提供了灵活的类型参数化特性。</p><h2 id="虚拟化或者说虚拟机都分为几种-Docker是什么类型-anaconda又是什么类型-用于桌面的完成虚拟化是什么类型"><a href="#虚拟化或者说虚拟机都分为几种-Docker是什么类型-anaconda又是什么类型-用于桌面的完成虚拟化是什么类型" class="headerlink" title="虚拟化或者说虚拟机都分为几种?Docker是什么类型?anaconda又是什么类型?用于桌面的完成虚拟化是什么类型?"></a>虚拟化或者说虚拟机都分为几种?Docker是什么类型?anaconda又是什么类型?用于桌面的完成虚拟化是什么类型?</h2><p>虚拟化技术通常分为几种类型，主要根据虚拟化的层次和用途来分类：</p><h3 id="1-硬件虚拟化（完整虚拟化-全虚拟化）"><a href="#1-硬件虚拟化（完整虚拟化-全虚拟化）" class="headerlink" title="1. 硬件虚拟化（完整虚拟化 &#x2F; 全虚拟化）"></a>1. <strong>硬件虚拟化（完整虚拟化 &#x2F; 全虚拟化）</strong></h3><ul><li><strong>定义</strong>：在硬件层面上进行虚拟化，虚拟机的操作系统和应用可以完全独立运行，并且认为自己独占了硬件。</li><li><strong>例子</strong>：<strong>VMware ESXi</strong>、<strong>KVM</strong>、<strong>Microsoft Hyper-V</strong>。</li><li><strong>应用场景</strong>：数据中心、服务器集群等环境，用于运行多个不同的操作系统或应用环境。</li><li><strong>桌面虚拟化示例</strong>：<strong>VMware Workstation</strong> 和 <strong>Oracle VirtualBox</strong>，用于开发、测试和桌面应用的虚拟化。</li></ul><h3 id="2-操作系统层虚拟化-容器虚拟化"><a href="#2-操作系统层虚拟化-容器虚拟化" class="headerlink" title="2. 操作系统层虚拟化 &#x2F; 容器虚拟化"></a>2. <strong>操作系统层虚拟化 &#x2F; 容器虚拟化</strong></h3><ul><li><strong>定义</strong>：通过在操作系统层创建多个隔离的容器，每个容器内运行不同的应用或服务，但共享宿主操作系统内核。</li><li><strong>例子</strong>：<strong>Docker</strong>、<strong>LXC</strong>、<strong>Kubernetes</strong>。</li><li><strong>应用场景</strong>：用于微服务、云计算和应用隔离，适合需要高效率、快速启动和低资源占用的场景。</li><li><strong>Docker 的类型</strong>：<strong>容器虚拟化</strong>，因为它共享宿主机的内核，是轻量化的应用隔离方案。</li></ul><h3 id="3-应用虚拟化"><a href="#3-应用虚拟化" class="headerlink" title="3. 应用虚拟化"></a>3. <strong>应用虚拟化</strong></h3><ul><li><strong>定义</strong>：直接虚拟化应用，应用可以在不同的操作系统和硬件上运行，但不需要整个操作系统实例。</li><li><strong>例子</strong>：<strong>Wine</strong>、<strong>Citrix XenApp</strong>、<strong>Microsoft App-V</strong>。</li><li><strong>应用场景</strong>：在不同平台上运行原本不兼容的应用，例如在 Linux 上运行 Windows 应用，适合于应用发布和管理。</li></ul><h3 id="4-语言-环境管理器虚拟化"><a href="#4-语言-环境管理器虚拟化" class="headerlink" title="4. 语言&#x2F;环境管理器虚拟化"></a>4. <strong>语言&#x2F;环境管理器虚拟化</strong></h3><ul><li><strong>定义</strong>：虚拟化某个编程语言或开发环境，用于提供独立的包、依赖和环境管理。</li><li><strong>例子</strong>：<strong>Anaconda</strong>（用于 Python 环境管理）、<strong>RVM</strong>（用于 Ruby）、<strong>NVM</strong>（用于 Node.js）。</li><li><strong>应用场景</strong>：开发和数据科学，适用于创建和管理不同的开发环境和依赖。</li><li><strong>Anaconda 的类型</strong>：<strong>语言环境管理虚拟化</strong>，因为它用于隔离不同的 Python 环境和依赖，并不虚拟化操作系统或硬件。</li></ul><h3 id="5-桌面虚拟化（Remote-Desktop-Virtualization）"><a href="#5-桌面虚拟化（Remote-Desktop-Virtualization）" class="headerlink" title="5. 桌面虚拟化（Remote Desktop Virtualization）"></a>5. <strong>桌面虚拟化（Remote Desktop Virtualization）</strong></h3><ul><li><strong>定义</strong>：通过虚拟化技术，使用户可以在一个物理终端上访问虚拟桌面或远程桌面。</li><li><strong>例子</strong>：<strong>Microsoft Remote Desktop</strong>、<strong>Citrix XenDesktop</strong>、<strong>VMware Horizon</strong>。</li><li><strong>应用场景</strong>：用于访问虚拟化的桌面环境或通过远程协议使用另一台计算机，常见于企业办公环境和云桌面场景。</li></ul><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>硬件虚拟化</strong>：适合服务器和完整操作系统隔离。</li><li><strong>容器虚拟化</strong>：适合轻量级应用和微服务。</li><li><strong>应用虚拟化</strong>：适合跨平台运行应用。</li><li><strong>语言&#x2F;环境管理器虚拟化</strong>：适合隔离编程语言和开发环境（如 Anaconda）。</li><li><strong>桌面虚拟化</strong>：适合通过网络访问虚拟桌面或远程桌面。</li></ul><h2 id="引擎到底是一种什么东西-是一些库吗-还是一些现成的工具-如果是库的话，引擎和运行时有什么区别了"><a href="#引擎到底是一种什么东西-是一些库吗-还是一些现成的工具-如果是库的话，引擎和运行时有什么区别了" class="headerlink" title="引擎到底是一种什么东西?是一些库吗?还是一些现成的工具?如果是库的话，引擎和运行时有什么区别了?"></a>引擎到底是一种什么东西?是一些库吗?还是一些现成的工具?如果是库的话，引擎和运行时有什么区别了?</h2><p>引擎（Engine）在软件开发领域中通常是指一种能够执行特定任务或处理特定类型数据的核心组件，它可以是一套库（Library）、框架（Framework）或工具（Tool）的集合，具体取决于它的设计目标和实现方式。下面用通俗的语言来区分引擎、库、运行时的概念。</p><hr><h3 id="1-引擎是什么？"><a href="#1-引擎是什么？" class="headerlink" title="1. 引擎是什么？"></a><strong>1. 引擎是什么？</strong></h3><p>引擎是一种更“高层次”的概念，它是为了解决特定问题而提供的一个综合性核心组件，通常是预先设计好并高度集成的一整套功能或模块。以下是一些常见类型的引擎：</p><ul><li><strong>游戏引擎（Game Engine）</strong>： 提供渲染、物理计算、音效处理、AI、脚本等功能，如 Unity、Unreal Engine。</li><li><strong>图形引擎（Graphics Engine）</strong>： 专注于图像或视频渲染，比如 OpenGL、DirectX。</li><li><strong>物理引擎（Physics Engine）</strong>： 模拟现实世界中的物理行为，如 Box2D、PhysX。</li><li><strong>搜索引擎（Search Engine）</strong>： 用于索引和快速检索信息，如 Elasticsearch、Google。</li></ul><p>引擎通常具有以下特性：</p><ol><li><strong>综合性</strong>：它往往不局限于单一功能，而是整合了多种相关功能模块。</li><li><strong>可扩展性</strong>：用户可以在引擎的基础上进行自定义开发。</li><li><strong>抽象层</strong>：引擎隐藏了底层实现细节，开发者直接调用接口即可完成复杂任务。</li></ol><hr><h3 id="2-引擎和库（Library）的区别"><a href="#2-引擎和库（Library）的区别" class="headerlink" title="2. 引擎和库（Library）的区别"></a><strong>2. 引擎和库（Library）的区别</strong></h3><ul><li><p><strong>库（Library）</strong>是一组预定义的函数、类、工具的集合，用来简化特定功能的实现，比如 JSON 解析库、数学计算库等。</p><ul><li><p>特点</p><p>：</p><ul><li>单一性：通常是为了解决某一类问题（如文件操作、数据分析）。</li><li>被动性：需要开发者显式调用。</li></ul></li></ul></li><li><p><strong>引擎（Engine）</strong>则是更完整的系统，可能内含多个库，但比单纯的库功能更多、更复杂。</p><ul><li><p>特点</p><p>：</p><ul><li>高度集成：涵盖多个功能模块，提供“一站式”解决方案。</li><li>主动性：通常提供一个运行机制（Loop 或事件驱动），开发者配置好后可以自动运行。</li></ul></li></ul></li></ul><p><strong>例子</strong>：</p><ul><li>JSON 库是一种库，只提供 JSON 解析或生成功能。</li><li>游戏引擎可能包含多个库（如渲染、物理计算），并在此基础上提供完整的游戏开发工作流。</li></ul><hr><h3 id="3-引擎和运行时（Runtime）的区别"><a href="#3-引擎和运行时（Runtime）的区别" class="headerlink" title="3. 引擎和运行时（Runtime）的区别"></a><strong>3. 引擎和运行时（Runtime）的区别</strong></h3><ul><li><p><strong>运行时（Runtime）</strong>是指程序运行期间提供支持的软件层，通常与语言或平台相关。</p><ul><li><p>特点</p><p>：</p><ul><li>管理程序的执行：包括内存分配、垃圾回收、线程调度等。</li><li>依赖平台：运行时与底层硬件或操作系统紧密结合。</li><li>非开发工具：它不直接提供开发者使用的接口，而是运行时的功能由编译器、框架等间接调用。</li></ul></li></ul></li></ul><p><strong>引擎和运行时的主要区别在于：</strong></p><ol><li><p>目标不同</p><p>：</p><ul><li>引擎关注“功能实现”，比如游戏中的渲染和物理。</li><li>运行时关注“执行支持”，确保程序能够被操作系统和硬件正确运行。</li></ul></li><li><p>开发者交互</p><p>：</p><ul><li>引擎直接提供 API 接口给开发者使用。</li><li>运行时通常是透明的，用户无需直接与之交互。</li></ul></li></ol><p><strong>例子</strong>：</p><ul><li>.NET 的运行时是 CLR（Common Language Runtime），管理 .NET 程序的执行。</li><li>Unity 引擎基于 Mono 或 IL2CPP 运行时，这些运行时支持 Unity 脚本的执行。</li></ul><hr><h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul><li><strong>库</strong>是工具箱，提供独立功能的模块，开发者按需调用。</li><li><strong>引擎</strong>是一个高度模块化、功能集成的核心组件，其开放接口让开发者可以自由调用其功能或进行扩展。因此，<strong>引擎本质上可以被视为一个开放接口的软件，它是开发工具与底层实现之间的桥梁，极大地提高了开发效率和灵活性</strong>。。</li><li><strong>运行时</strong>是程序的“运行支撑层”，负责管理程序与硬件&#x2F;操作系统的交互。</li></ul><p>引擎本身可能包含运行时（如游戏引擎带有脚本运行时）和多个库，它是开发者与底层技术之间的桥梁，用于快速构建复杂的系统或应用。</p><h2 id="我是否可以这么理解，所谓的函数式还是面向对象式风格的代码，最大的区别就在于函数还是对象是编程语言中的第一公民"><a href="#我是否可以这么理解，所谓的函数式还是面向对象式风格的代码，最大的区别就在于函数还是对象是编程语言中的第一公民" class="headerlink" title="我是否可以这么理解，所谓的函数式还是面向对象式风格的代码，最大的区别就在于函数还是对象是编程语言中的第一公民?"></a>我是否可以这么理解，所谓的函数式还是面向对象式风格的代码，最大的区别就在于函数还是对象是编程语言中的第一公民?</h2><p>你的理解是有一定道理的，但可以进一步细化。函数式编程（Functional Programming, FP）和面向对象编程（Object-Oriented Programming, OOP）的核心区别，确实可以从<strong>第一公民</strong>的角度来理解，但它们的差异远不止于此。</p><h3 id="函数式编程（FP）"><a href="#函数式编程（FP）" class="headerlink" title="函数式编程（FP）"></a>函数式编程（FP）</h3><p>在函数式编程中，<strong>函数</strong>是编程语言中的“第一公民”。这意味着：</p><ol><li><strong>函数可以作为值</strong>：你可以将函数作为参数传递给其他函数，或者将其返回作为结果。例如，高阶函数（higher-order functions）可以接受函数作为参数，或者返回函数作为结果。</li><li><strong>函数无副作用</strong>：函数通常是纯粹的（pure），这意味着它们的返回值只依赖于输入参数，不依赖外部状态，并且没有副作用（例如，不修改全局变量或输入参数）。</li><li><strong>不变性</strong>：函数式编程推崇<strong>不可变数据</strong>。变量一旦赋值后，不会再被修改。数据结构通常是不可变的，如果需要修改，就会生成一个新的数据结构。</li><li><strong>声明式</strong>：函数式编程侧重于描述“做什么”（What）而不是“如何做”（How）。比如，使用映射（map）、过滤（filter）等高阶函数来描述逻辑，而不是详细说明如何逐步实现这些逻辑。</li></ol><h3 id="面向对象编程（OOP）"><a href="#面向对象编程（OOP）" class="headerlink" title="面向对象编程（OOP）"></a>面向对象编程（OOP）</h3><p>在面向对象编程中，<strong>对象</strong>是编程语言中的“第一公民”。这意味着：</p><ol><li><strong>数据和行为封装在对象中</strong>：对象不仅包含数据（属性），还包含操作这些数据的行为（方法）。OOP 强调通过封装（encapsulation）将数据和行为紧密绑定在一起。</li><li><strong>继承和多态</strong>：OOP 强调通过继承（inheritance）来重用代码，并通过多态（polymorphism）来实现不同对象间的行为重载和扩展。</li><li><strong>状态和行为的修改</strong>：对象的状态通常是可以改变的（mutability），并且行为是通过方法来实现的。对象之间的交互通常通过消息传递（方法调用）来进行。</li><li><strong>命令式</strong>：OOP 偏向于命令式编程（imperative），强调如何执行任务，逐步修改状态。</li></ol><h3 id="进一步分析"><a href="#进一步分析" class="headerlink" title="进一步分析"></a>进一步分析</h3><p>将“第一公民”概念作为区分 FP 和 OOP 的角度，可以看出，确实是函数和对象在两种风格中的角色不同。但这种区分并不意味着函数式编程没有对象，或者面向对象编程没有函数。在许多语言中，尤其是现代语言（如 C#、JavaScript、Python 等），两种编程范式是可以并存的。</p><ul><li>在 C# 中，函数是通过委托、Lambda 表达式等形式存在的，而对象则是通过类和实例来定义的。C# 允许你以面向对象的方式编写代码，但同时也支持函数式编程的特性，如 LINQ 查询和不可变集合。</li><li>例如，C# 的 LINQ 查询使用了大量的函数式编程思想，但它的基本结构依然是基于对象和类的。</li></ul><h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>函数式编程的核心是函数</strong>，侧重于数据的处理与变换，强调不可变性、纯函数和声明式编程。</li><li><strong>面向对象编程的核心是对象</strong>，侧重于通过对象封装数据和行为，强调继承、多态和状态变化。</li></ul><p>因此，虽然可以从“第一公民”的角度理解两者的不同，但这只是其本质特征之一，二者的差异还包括如何组织代码、如何处理副作用、如何管理状态等方面。</p><h1 id="我是否可以这么理解，-exe只是开启了一个用C-运行时来翻译中间语言的进程，而热重载就是在VS的这个进程对-exe的这个进程进行注入"><a href="#我是否可以这么理解，-exe只是开启了一个用C-运行时来翻译中间语言的进程，而热重载就是在VS的这个进程对-exe的这个进程进行注入" class="headerlink" title="我是否可以这么理解，.exe只是开启了一个用C#运行时来翻译中间语言的进程，而热重载就是在VS的这个进程对.exe的这个进程进行注入"></a>我是否可以这么理解，.exe只是开启了一个用C#运行时来翻译中间语言的进程，而热重载就是在VS的这个进程对.exe的这个进程进行注入</h1><p>你的理解基本正确，但需要稍作补充和调整：</p><ol><li><strong><code>.exe</code> 文件运行的本质</strong><ul><li>当你运行 C# 编写的程序（例如一个 <code>.exe</code> 文件）时，该 <code>.exe</code> 文件实际上包含了 <strong>中间语言（IL）</strong> 和 <strong>元数据</strong>。</li><li>.NET 运行时（CLR，Common Language Runtime）会启动一个进程，加载这个 <code>.exe</code> 文件，解析 IL，并即时编译为机器码（通过 JIT 编译器）。</li><li>所以，<code>.exe</code> 是程序的入口点，但它的执行是由 .NET 运行时处理的。</li></ul></li><li><strong>热重载的作用</strong><ul><li><strong>Visual Studio 和运行时交互</strong>：<ul><li>Visual Studio 的调试器会与运行时直接通信，而不是直接操作 <code>.exe</code> 文件。</li><li>热重载并不是对 <code>.exe</code> 文件进行修改，而是通过调试器注入或替换运行时中的 IL。</li></ul></li><li><strong>注入方式</strong>：<ul><li>Visual Studio 捕获代码变化后，生成 <strong>增量 IL 文件</strong>。</li><li>调试器通过运行时 API，将增量 IL 加载到运行中的进程内存中。</li><li>CLR 动态更新类或方法的元数据和实现，让修改即时生效。</li></ul></li></ul></li><li><strong>跨进程通信</strong><ul><li>Visual Studio 调试器是一个单独的进程，它通过 <strong>调试协议</strong>（如 Windows Debug API 或 .NET 调试协议）与运行时进程通信。</li><li>热重载的“注入”本质上是调试器对运行时发出指令，要求运行时动态加载新的 IL。</li></ul></li></ol><hr><h3 id="改进你的理解"><a href="#改进你的理解" class="headerlink" title="改进你的理解"></a><strong>改进你的理解</strong></h3><h4 id="更准确的表述："><a href="#更准确的表述：" class="headerlink" title="更准确的表述："></a><strong>更准确的表述：</strong></h4><p><code>.exe</code> 文件本身只是托管代码（IL）的容器，其运行由 .NET 运行时管理。热重载通过 Visual Studio 调试器与运行时的交互，将修改后的 IL 动态注入到运行时进程的内存中，而不直接操作 <code>.exe</code> 文件。</p><hr><h3 id="完整运行时流程"><a href="#完整运行时流程" class="headerlink" title="完整运行时流程"></a><strong>完整运行时流程</strong></h3><ol><li><strong>启动 <code>.exe</code> 文件</strong><ul><li>操作系统启动进程，加载 <code>.exe</code> 文件。</li><li>CLR 解析 <code>.exe</code> 的元数据，并启动应用程序的入口方法。</li></ul></li><li><strong>JIT 编译和执行</strong><ul><li>CLR 按需将 IL 转换为机器码（JIT 编译）。</li><li>程序开始运行，执行逻辑。</li></ul></li><li><strong>热重载过程</strong><ul><li><strong>代码修改</strong>：开发者在 Visual Studio 中修改代码。</li><li><strong>增量编译</strong>：Visual Studio 编译器只重新生成改动部分的 IL。</li><li><strong>注入更新</strong>：调试器通过运行时 API，将新的 IL 加载到目标进程中。</li><li><strong>动态替换</strong>：CLR 更新运行时中的方法或类，立即生效。</li></ul></li><li><strong>持续运行</strong><ul><li>运行中的进程保持其当前状态（如变量值和线程栈），无需重新启动。</li></ul></li></ol><hr><h3 id="补充：为什么不直接修改-exe-文件？"><a href="#补充：为什么不直接修改-exe-文件？" class="headerlink" title="补充：为什么不直接修改 .exe 文件？"></a><strong>补充：为什么不直接修改 <code>.exe</code> 文件？</strong></h3><ol><li><strong>运行时安全性</strong><ul><li><code>.exe</code> 文件可能已被操作系统锁定（因为它正在运行）。</li><li>修改 <code>.exe</code> 文件会带来运行时的不确定性。</li></ul></li><li><strong>热重载的设计目标</strong><ul><li>热重载的目标是快速迭代代码，而不是永久修改二进制文件。</li><li>修改 IL 的逻辑只存在于内存中，对原始文件无影响。</li></ul></li><li><strong>调试器的职责</strong><ul><li>热重载的注入逻辑是调试器和 CLR 的协作，而不需要修改磁盘上的文件。</li></ul></li></ol><hr><h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>你可以理解为：</p><ul><li><code>.exe</code> 启动后，CLR 承担了 IL 的加载和运行工作。</li><li>热重载由 <strong>Visual Studio 调试器</strong> 和 <strong>CLR</strong> 协作完成。</li><li>通过注入增量 IL 文件的方式，动态修改运行中的进程内存，而不是直接修改 <code>.exe</code> 文件。</li></ul><p>这种设计既保障了开发效率，又避免了修改原始二进制文件的潜在问题。</p><h1 id="所以实际上，无论是函数式也好，面向对象也好，最重要的思想其实是抽象数据，SICP的前两章实际上是为了传授抽象数据的思想，无论是用函数式还是什么，核心思想其实是这个，我理解的对吗"><a href="#所以实际上，无论是函数式也好，面向对象也好，最重要的思想其实是抽象数据，SICP的前两章实际上是为了传授抽象数据的思想，无论是用函数式还是什么，核心思想其实是这个，我理解的对吗" class="headerlink" title="所以实际上，无论是函数式也好，面向对象也好，最重要的思想其实是抽象数据，SICP的前两章实际上是为了传授抽象数据的思想，无论是用函数式还是什么，核心思想其实是这个，我理解的对吗?"></a>所以实际上，无论是函数式也好，面向对象也好，最重要的思想其实是抽象数据，SICP的前两章实际上是为了传授抽象数据的思想，无论是用函数式还是什么，核心思想其实是这个，我理解的对吗?</h1><p><strong>是的，你的理解大体是正确的。**SICP 的核心思想之一，就是**通过抽象**来管理程序的复杂度。无论是过程抽象（第 1 章讲的“高阶函数”与函数式思维）还是数据抽象（第 2 章讲的“抽象数据类型”），它们的目的都是</strong>把我们在构建程序时的“做什么”<strong>和</strong>“怎么做”**分离开来，从而让程序更易于理解和维护。</p><ul><li><strong>SICP 第 1 章</strong>更多地侧重<strong>过程抽象</strong>：如何把复杂的过程逻辑封装在函数中，再用高阶函数等手段进行组合，从而“像搭积木一样”构建复杂行为。</li><li><strong>SICP 第 2 章</strong>则介绍<strong>数据抽象</strong>：如何“先定义好对数据的操作与接口”，再决定用何种内部表示（结构）去实现这些操作。这样一来，就能<strong>隐藏</strong>数据的底层实现细节，仅保留对外可见的操作接口。</li></ul><p>这些抽象思维本质上<strong>并不局限于函数式或面向对象</strong>——不论使用 OOP、函数式、过程式等范式，都可以而且都需要<strong>数据抽象</strong>来降低耦合、提升可维护性。面向对象更多地在语言层面提供了“类”、“对象”、“继承”、“接口”之类的特性，让你有一整套写法来实现<strong>抽象数据</strong>与<strong>抽象行为</strong>；而函数式或过程式也可以通过<strong>函数、闭包、模块</strong>等手段来做同样的事。</p><p>因此，<strong>SICP 最想传递的</strong>并不是“要去用哪个编程范式”，而是<strong>如何以抽象为工具</strong>，在程序构建中管理复杂度。在第 2 章，你所看到的那种“先定义一组操作，再去实现底层结构”的模式，确实正是“数据抽象”的精髓所在。你把它理解为在给后续的 OOP 思维做铺垫也可以，但它本身更是“抽象数据类型”这一概念的最初阐释，与是否走向 OOP 语言并没有强制联系。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>问答</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令速查</title>
    <link href="/2024/11/03/Linux%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5/"/>
    <url>/2024/11/03/Linux%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5/</url>
    
    <content type="html"><![CDATA[<p><strong>关机&#x2F;重启&#x2F;注销</strong></p><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>shutdown -h now</td><td>即刻关机</td></tr><tr><td>shutdown -h 10</td><td>10分钟后关机</td></tr><tr><td>shutdown -h 11:00</td><td>11：00关机</td></tr><tr><td>shutdown -h +10</td><td>预定时间关机（10分钟后）</td></tr><tr><td>shutdown -c</td><td>取消指定时间关机</td></tr><tr><td>shutdown -r now</td><td>重启</td></tr><tr><td>shutdown -r 10</td><td>10分钟之后重启</td></tr><tr><td>shutdown -r 11:00</td><td>定时重启</td></tr><tr><td>reboot</td><td>重启</td></tr><tr><td>init 6</td><td>重启</td></tr><tr><td>init 0</td><td>⽴刻关机</td></tr><tr><td>telinit 0</td><td>关机</td></tr><tr><td>poweroff</td><td>⽴刻关机</td></tr><tr><td>halt</td><td>关机</td></tr><tr><td>sync</td><td>buff数据同步到磁盘</td></tr><tr><td>logout</td><td>退出登录Shell</td></tr></tbody></table><p><strong>系统信息和性能查看</strong></p><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>uname -a</td><td>查看内核&#x2F;OS&#x2F;CPU信息</td></tr><tr><td>uname -r</td><td>查看内核版本</td></tr><tr><td>uname -m</td><td>查看处理器架构</td></tr><tr><td>arch</td><td>查看处理器架构</td></tr><tr><td>hostname</td><td>查看计算机名</td></tr><tr><td>who</td><td>显示当前登录系统的⽤户</td></tr><tr><td>who am i</td><td>显示登录时的⽤户名</td></tr><tr><td>whoami</td><td>显示当前⽤户名</td></tr><tr><td>cat &#x2F;proc&#x2F;version</td><td>查看linux版本信息</td></tr><tr><td>cat &#x2F;proc&#x2F;cpuinfo</td><td>查看CPU信息</td></tr><tr><td>cat &#x2F;proc&#x2F;interrupts</td><td>查看中断</td></tr><tr><td>cat &#x2F;proc&#x2F;loadavg</td><td>查看系统负载</td></tr><tr><td>uptime</td><td>查看系统运⾏时间、⽤户数、负载</td></tr><tr><td>env</td><td>查看系统的环境变量</td></tr><tr><td>lsusb -tv</td><td>查看系统USB设备信息</td></tr><tr><td>lspci -tv</td><td>查看系统PCI设备信息</td></tr><tr><td>lsmod</td><td>查看已加载的系统模块</td></tr><tr><td>grep MemTotal &#x2F;proc&#x2F;meminfo</td><td>查看内存总量</td></tr><tr><td>grep MemFree &#x2F;proc&#x2F;meminfo</td><td>查看空闲内存量</td></tr><tr><td>free -m</td><td>查看内存⽤量和交换区⽤量</td></tr><tr><td>date</td><td>显示系统⽇期时间</td></tr><tr><td>cal 2021</td><td>显示2021⽇历表</td></tr><tr><td>top</td><td>动态显示cpu&#x2F;内存&#x2F;进程等情况</td></tr><tr><td>vmstat 1 20</td><td>每1秒采⼀次系统状态，采20次</td></tr><tr><td>iostat</td><td>查看io读写&#x2F;cpu使⽤情况</td></tr><tr><td>查看io读写&#x2F;cpu使⽤情况</td><td>查询cpu使⽤情况（1秒⼀次，共10次）</td></tr><tr><td>sar -d 1 10</td><td>查询磁盘性能</td></tr></tbody></table><p><strong>磁盘和分区</strong></p><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>fdisk -l</td><td>查看所有磁盘分区</td></tr><tr><td>swapon -s</td><td>查看所有交换分区</td></tr><tr><td>df -h</td><td>查看磁盘使⽤情况及挂载点</td></tr><tr><td>df -hl</td><td>同上</td></tr><tr><td>du -sh &#x2F;dir</td><td>查看指定某个⽬录的⼤⼩</td></tr><tr><td>du -sk * | sort -rn</td><td>从⾼到低依次显示⽂件和⽬录⼤⼩</td></tr><tr><td>mount &#x2F;dev&#x2F;hda2 &#x2F;mnt&#x2F;hda2</td><td>挂载hda2盘</td></tr><tr><td>mount -t ntfs &#x2F;dev&#x2F;sdc1 &#x2F;mnt&#x2F;usbhd1</td><td>指定⽂件系统类型挂载（如ntfs）</td></tr><tr><td>mount -o loop xxx.iso &#x2F;mnt&#x2F;cdrom</td><td>挂 载 iso ⽂ 件</td></tr><tr><td>umount -v &#x2F;dev&#x2F;sda1</td><td>通过设备名卸载</td></tr><tr><td>umount -v &#x2F;mnt&#x2F;mymnt</td><td>通过挂载点卸载</td></tr><tr><td>fuser -km &#x2F;mnt&#x2F;hda1</td><td>强制卸载(慎⽤)</td></tr></tbody></table><p><strong>⽤户和⽤户组</strong></p><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>useradd codesheep</td><td>创建⽤户</td></tr><tr><td>userdel -r codesheep</td><td>删除⽤户</td></tr><tr><td>usermod -g group_name user_name</td><td>修改⽤户的组</td></tr><tr><td>usermod -aG group_name user_name</td><td>将⽤户添加到组</td></tr><tr><td>usermod -s &#x2F;bin&#x2F;ksh -d &#x2F;home&#x2F;codepig –g dev codesheep</td><td>修改⽤户codesheep的登录Shell、主⽬录以及⽤户组</td></tr><tr><td>groups test</td><td>查看test⽤户所在的组</td></tr><tr><td>groupadd group_name</td><td>创建⽤户组</td></tr><tr><td>groupdel group_name</td><td>删除⽤户组</td></tr><tr><td>groupmod -n new_name old_name</td><td>重命名⽤户组</td></tr><tr><td>su - user_name</td><td>su - user_name</td></tr><tr><td>passwd</td><td>修改⼝令</td></tr><tr><td>passwd codesheep</td><td>修改某⽤户的⼝令</td></tr><tr><td>w</td><td>查看活动⽤户</td></tr><tr><td>id codesheep</td><td>查看指定⽤户codesheep信息</td></tr><tr><td>last</td><td>查看⽤户登录⽇志</td></tr><tr><td>crontab -l</td><td>查看当前⽤户的计划任务</td></tr><tr><td>cut -d: -f1 &#x2F;etc&#x2F;passwd</td><td>查看系统所有⽤户</td></tr><tr><td>cut -d: -f1 &#x2F;etc&#x2F;group</td><td>查看系统所有组</td></tr></tbody></table><p><strong>⽹络和进程管理</strong></p><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>ifconfig</td><td>查看⽹络接⼝属性</td></tr><tr><td>ifconfig eth0</td><td>查看某⽹卡的配置</td></tr><tr><td>route -n</td><td>查看路由表</td></tr><tr><td>netstat -lntp</td><td>查看所有监听端⼝</td></tr><tr><td>netstat -antp</td><td>查看已经建⽴的TCP连接</td></tr><tr><td>netstat -lutp</td><td>查看TCP&#x2F;UDP的状态信息</td></tr><tr><td>ifup eth0</td><td>启⽤eth0⽹络设备</td></tr><tr><td>ifdown eth0</td><td>禁⽤eth0⽹络设备</td></tr><tr><td>iptables -L</td><td>查看iptables规则</td></tr><tr><td>ifconfig eth0 192.168.1.1 netmask 255.255.255.0</td><td>配置ip地址</td></tr><tr><td>dhclient eth0</td><td>以dhcp模式启⽤eth0</td></tr><tr><td>route add -net 0&#x2F;0 gw Gateway_IP</td><td>配置默认⽹关</td></tr><tr><td>route add -net 192.168.0.0 netmask 255.255.0.0 gw  192.168.1.1</td><td>配置静态路由到达⽹络’192.168.0.0&#x2F;16’</td></tr><tr><td>route del 0&#x2F;0 gw Gateway_IP</td><td>删除静态路由</td></tr><tr><td>hostname</td><td>查看主机名</td></tr><tr><td>host <a href="http://www.baidu.com/">www.baidu.com</a></td><td>解析主机名</td></tr><tr><td>nslookup <a href="http://www.baidu.com/">www.baidu.com</a></td><td>查询DNS记录，查看域名解析是否正常</td></tr><tr><td>ps -ef</td><td>查看所有进程</td></tr><tr><td>ps -ef | grep codesheep</td><td>过滤出你需要的进程</td></tr><tr><td>kill -s name</td><td>kill指定名称的进程</td></tr><tr><td>kill -s pid</td><td>kill指定pid的进程</td></tr><tr><td>top</td><td>实时显示进程状态</td></tr><tr><td>vmstat 1 20</td><td>每1秒采⼀次系统状态，采20次</td></tr><tr><td>iostat</td><td>iostat</td></tr><tr><td>sar -u 1 10</td><td>查询cpu使⽤情况（1秒⼀次，共10次）</td></tr><tr><td>sar -d 1 10</td><td>查询磁盘性能</td></tr></tbody></table><p><strong>常⻅系统服务命令</strong></p><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>chkconfig –list</td><td>列出系统服务</td></tr><tr><td>service &lt;服务名&gt; status</td><td>查看某个服务</td></tr><tr><td>service &lt;服务名&gt; start</td><td>启动某个服务</td></tr><tr><td>service &lt;服务名&gt; stop</td><td>终⽌某个服务</td></tr><tr><td>service &lt;服务名&gt; restart</td><td>重启某个服务</td></tr><tr><td>systemctl status &lt;服务名&gt;</td><td>查看某个服务</td></tr><tr><td>systemctl start &lt;服务名&gt;</td><td>启动某个服务</td></tr><tr><td>systemctl stop &lt;服务名&gt;</td><td>终⽌某个服务</td></tr><tr><td>systemctl restart &lt;服务名&gt;</td><td>重启某个服务</td></tr><tr><td>systemctl enable &lt;服务名&gt;</td><td>关闭⾃启动</td></tr><tr><td>systemctl disable &lt;服务名&gt;</td><td>关闭⾃启动</td></tr></tbody></table><p><strong>⽂件和⽬录操作</strong></p><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>cd &lt;⽬录名&gt;</td><td>进⼊某个⽬录</td></tr><tr><td>cd ..</td><td>回上级⽬录</td></tr><tr><td>cd ..&#x2F;..</td><td>回上两级⽬录</td></tr><tr><td>cd</td><td>进个⼈主⽬录</td></tr><tr><td>cd -</td><td>回上⼀步所在⽬录</td></tr><tr><td>pwd</td><td>显示当前路径</td></tr><tr><td>ls</td><td>查看⽂件⽬录列表</td></tr><tr><td>ls -F</td><td>查看⽬录中内容（显示是⽂件还是⽬录）</td></tr><tr><td>ls -l</td><td>查看⽂件和⽬录的详情列表</td></tr><tr><td>ls -a</td><td>查看隐藏⽂件</td></tr><tr><td>ls -lh</td><td>查看⽂件和⽬录的详情列表（增强⽂件⼤⼩易读性）</td></tr><tr><td>ls -lSr</td><td>查看⽂件和⽬录列表（以⽂件⼤⼩升序查看）</td></tr><tr><td>tree</td><td>查看⽂件和⽬录的树形结构</td></tr><tr><td>mkdir &lt;⽬录名&gt;</td><td>创建⽬录</td></tr><tr><td>mkdir dir1 dir2</td><td>同时创建两个⽬录</td></tr><tr><td>mkdir -p &#x2F;tmp&#x2F;dir1&#x2F;dir2</td><td>创建⽬录树</td></tr><tr><td>rm -f file1</td><td>删除’file1’⽂件</td></tr><tr><td>rmdir dir1</td><td>删除’dir1’⽬录</td></tr><tr><td>rm -rf dir1</td><td>删除’dir1’⽬录和其内容</td></tr><tr><td>rm -rf dir1 dir2</td><td>同时删除两个⽬录及其内容</td></tr><tr><td>mv old_dir new_dir</td><td>重命名&#x2F;移动⽬录</td></tr><tr><td>cp file1 file2</td><td>复制⽂件</td></tr><tr><td>cp dir&#x2F;* .</td><td>复制某⽬录下的所有⽂件⾄当前⽬录</td></tr><tr><td>cp -a dir1 dir2</td><td>复制⽬录</td></tr><tr><td>cp -a &#x2F;tmp&#x2F;dir1 .</td><td>复制⼀个⽬录⾄当前⽬录</td></tr><tr><td>ln -s file1 link1</td><td>创建指向⽂件&#x2F;⽬录的软链接</td></tr><tr><td>ln file1 lnk1</td><td>创建指向⽂件&#x2F;⽬录的物理链接</td></tr><tr><td>find &#x2F; -name file1</td><td>从跟⽬录开始搜索⽂件&#x2F;⽬录</td></tr><tr><td>find &#x2F; -user user1</td><td>搜索⽤户user1的⽂件&#x2F;⽬录</td></tr><tr><td>find &#x2F;dir -name *.bin</td><td>在⽬录&#x2F;dir中搜带有.bin后缀的⽂件</td></tr><tr><td>locate &lt;关键词&gt;</td><td>快速定位⽂件</td></tr><tr><td>locate *.mp4</td><td>寻找.mp4结尾的⽂件</td></tr><tr><td>whereis &lt;关键词&gt;</td><td>显示某⼆进制⽂件&#x2F;可执⾏⽂件的路径</td></tr><tr><td>which &lt;关键词&gt;</td><td>查找系统⽬录下某的⼆进制⽂件</td></tr><tr><td>chmod ugo+rwx dir1</td><td>设置⽬录所有者(u)、群组(g)及其他⼈(o)的读（r）写(w)执⾏(x)权限</td></tr><tr><td>chmod go-rwx dir1</td><td>移除群组(g)与其他⼈(o)对⽬录的读写执⾏权限</td></tr><tr><td>chown user1 file1</td><td>改变⽂件的所有者属性</td></tr><tr><td>chown -R user1 dir1</td><td>改变⽬录的所有者属性</td></tr><tr><td>chgrp group1 file1</td><td>改变⽂件群组</td></tr><tr><td>chown user1:group1 file1</td><td>改变⽂件的所有⼈和群组</td></tr></tbody></table><p><strong>⽂件查看和处理</strong></p><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>cat file1</td><td>查看⽂件内容</td></tr><tr><td>cat -n file1</td><td>查看内容并标示⾏数</td></tr><tr><td>tac file1</td><td>从最后⼀⾏开始反看⽂件内容</td></tr><tr><td>more file1</td><td>more file1</td></tr><tr><td>less file1</td><td>类似more命令，但允许反向操作</td></tr><tr><td>head -2 file1</td><td>查看⽂件前两⾏</td></tr><tr><td>tail -2 file1</td><td>查看⽂件后两⾏</td></tr><tr><td>tail -f &#x2F;log&#x2F;msg</td><td>实时查看添加到⽂件中的内容</td></tr><tr><td>grep codesheep hello.txt</td><td>在⽂件hello.txt中查找关键词codesheep</td></tr><tr><td>grep ^sheep hello.txt</td><td>在⽂件hello.txt中查找以sheep开头的内容</td></tr><tr><td>grep [0-9] hello.txt</td><td>选择hello.txt⽂件中所有包含数字的⾏</td></tr><tr><td>sed ‘s&#x2F;s1&#x2F;s2&#x2F;g’ hello.txt</td><td>将hello.txt⽂件中的s1替换成s2</td></tr><tr><td>sed ‘&#x2F;^$&#x2F;d’ hello.txt</td><td>从hello.txt⽂件中删除所有空⽩⾏</td></tr><tr><td>sed ‘&#x2F; *#&#x2F;d; &#x2F;^$&#x2F;d’ hello.txt</td><td>从hello.txt⽂件中删除所有注释和空⽩⾏</td></tr><tr><td>sed -e ‘1d’ hello.txt</td><td>从⽂件hello.txt 中排除第⼀⾏</td></tr><tr><td>sed -n ‘&#x2F;s1&#x2F;p’ hello.txt</td><td>查看只包含关键词”s1”的⾏</td></tr><tr><td>sed -e ‘s&#x2F; *$&#x2F;&#x2F;‘ hello.txt</td><td>删除每⼀⾏最后的空⽩字符</td></tr><tr><td>sed -e ‘s&#x2F;s1&#x2F;&#x2F;g’ hello.txt</td><td>从⽂档中只删除词汇s1并保留剩余全部</td></tr><tr><td>sed -n ‘1,5p;5q’ hello.txt</td><td>查看从第⼀⾏到第5⾏内容</td></tr><tr><td>sed -n ‘5p;5q’ hello.txt</td><td>查看第5⾏</td></tr><tr><td>paste file1 file2</td><td>合并两个⽂件或两栏的内容</td></tr><tr><td>paste -d ‘+’ file1 file2</td><td>合并两个⽂件或两栏的内容，中间⽤”+”区分</td></tr><tr><td>sort file1 file2</td><td>排序两个⽂件的内容</td></tr><tr><td>comm -1 file1 file2</td><td>⽐较两个⽂件的内容(去除’file1’所含内容)</td></tr><tr><td>comm -2 file1 file2</td><td>⽐较两个⽂件的内容(去除’file2’所含内容</td></tr><tr><td>comm -3 file1 file2</td><td>⽐较两个⽂件的内容(去除两⽂件共有部分)</td></tr></tbody></table><p><strong>打包和解压</strong></p><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>zip xxx.zip file</td><td>压缩⾄zip包</td></tr><tr><td>zip -r xxx.zip file1 file2 dir1</td><td>将多个⽂件+⽬录压成zip包</td></tr><tr><td>unzip xxx.zip</td><td>解压zip包</td></tr><tr><td>tar -cvf xxx.tar file</td><td>创建⾮压缩tar包</td></tr><tr><td>tar -cvf xxx.tar file1 file2 dir1</td><td>将多个⽂件+⽬录打tar包</td></tr><tr><td>tar -tf xxx.tar</td><td>查看tar包的内容</td></tr><tr><td>tar -xvf xxx.tar</td><td>解压tar包</td></tr><tr><td>tar -xvf xxx.tar -C &#x2F;dir</td><td>将tar包解压⾄指定⽬录</td></tr><tr><td>tar -cvfj xxx.tar.bz2 dir</td><td>创建bz2压缩包</td></tr><tr><td>tar -jxvf xxx.tar.bz2</td><td>解压bz2压缩包</td></tr><tr><td>tar -cvfz xxx.tar.gz dir</td><td>创建gzip压缩包</td></tr><tr><td>tar -zxvf xxx.tar.gz</td><td>解压gzip压缩包</td></tr><tr><td>bunzip2 xxx.bz2</td><td>解压bz2压缩包</td></tr><tr><td>bzip2 filename</td><td>压缩⽂件</td></tr><tr><td>gunzip xxx.gz</td><td>解压gzip压缩包</td></tr><tr><td>gzip filename</td><td>压缩⽂件</td></tr><tr><td>gzip -9 filename</td><td>最⼤程度压缩</td></tr></tbody></table><p><strong>RPM包管理命令</strong></p><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>rpm -qa</td><td>查看已安装的rpm包</td></tr><tr><td>rpm -q pkg_name</td><td>查询某个rpm包</td></tr><tr><td>rpm -q –whatprovides xxx</td><td>显示xxx功能是由哪个包提供的</td></tr><tr><td>rpm -q –whatrequires xxx</td><td>显示xxx功能被哪个程序包依赖的</td></tr><tr><td>rpm -q –changelog xxx</td><td>显示xxx包的更改记录</td></tr><tr><td>rpm -qi pkg_name</td><td>查看⼀个包的详细信息</td></tr><tr><td>rpm -qd pkg_name</td><td>查询⼀个包所提供的⽂档</td></tr><tr><td>rpm -qc pkg_name</td><td>查看已安装rpm包提供的配置⽂件</td></tr><tr><td>rpm -ql pkg_name</td><td>查看⼀个包安装了哪些⽂件</td></tr><tr><td>rpm -qf filename</td><td>查看某个⽂件属于哪个包</td></tr><tr><td>rpm -qR pkg_name</td><td>查询包的依赖关系</td></tr><tr><td>rpm -ivh xxx.rpm</td><td>安装rpm包</td></tr><tr><td>rpm -ivh –test xxx.rpm</td><td>测试安装rpm包</td></tr><tr><td>rpm -ivh –nodeps xxx.rpm</td><td>安装rpm包时忽略依赖关系</td></tr><tr><td>rpm -e xxx</td><td>卸载程序包</td></tr><tr><td>rpm -Fvh pkg_name</td><td>升级确定已安装的rpm包</td></tr><tr><td>rpm -Uvh pkg_name</td><td>升级rpm包(若未安装则会安装)</td></tr><tr><td>rpm -V pkg_name</td><td>RPM包详细信息校验</td></tr></tbody></table><p><strong>YUM包管理命令</strong></p><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>yum repolist enabled</td><td>显示可⽤的源仓库</td></tr><tr><td>yum search pkg_name</td><td>搜索软件包</td></tr><tr><td>yum install pkg_name</td><td>下载并安装软件包</td></tr><tr><td>yum install –downloadonly pkg_name</td><td>只 下 载 不 安 装</td></tr><tr><td>yum list</td><td>显示所有程序包</td></tr><tr><td>yum list installed</td><td>查看当前系统已安装包</td></tr><tr><td>yum list updates</td><td>查看可以更新的包列表</td></tr><tr><td>yum check-update</td><td>查看可升级的软件包</td></tr><tr><td>yum update</td><td>更新所有软件包</td></tr><tr><td>yum update pkg_name</td><td>升级指定软件包</td></tr><tr><td>yum deplist pkg_name</td><td>列出软件包依赖关系</td></tr><tr><td>yum remove pkg_name</td><td>删除软件包</td></tr><tr><td>yum clean all</td><td>清除缓存</td></tr><tr><td>yum clean packages</td><td>清除缓存的软件包</td></tr><tr><td>yum clean headers</td><td>清除缓存的header</td></tr></tbody></table><p><strong>DPKG包管理命令</strong></p><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>dpkg -c xxx.deb</td><td>列出deb包的内容</td></tr><tr><td>dpkg -i xxx.deb</td><td>安装&#x2F;更新deb包</td></tr><tr><td>dpkg -r pkg_name</td><td>移除deb包</td></tr><tr><td>dpkg -P pkg_name</td><td>移除deb包(不保留配置)</td></tr><tr><td>dpkg -l</td><td>查看系统中已安装deb包</td></tr><tr><td>dpkg -l pkg_name</td><td>显示包的⼤致信息</td></tr><tr><td>dpkg -L pkg_name</td><td>查看deb包安装的⽂件</td></tr><tr><td>dpkg -s pkg_name</td><td>查看包的详细信息</td></tr><tr><td>dpkg –unpack xxx.deb</td><td>解开deb包的内容</td></tr></tbody></table><p><strong>APT软件⼯具</strong></p><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>apt-cache search pkg_name</td><td>搜索程序包</td></tr><tr><td>apt-cache show pkg_name</td><td>获取包的概览信息</td></tr><tr><td>apt-get install pkg_name</td><td>安装&#x2F;升级软件包</td></tr><tr><td>apt-get purge pkg_name</td><td>卸载软件（包括配置）</td></tr><tr><td>apt-get remove pkg_name</td><td>卸载软件（不包括配置）</td></tr><tr><td>apt-get update</td><td>更新包索引信息</td></tr><tr><td>apt-get upgrade</td><td>更新已安装软件包</td></tr><tr><td>apt-get clean</td><td>清理缓存</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络零碎知识点</title>
    <link href="/2024/10/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2024/10/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="私有-IP-地址范围有三段"><a href="#私有-IP-地址范围有三段" class="headerlink" title="私有 IP 地址范围有三段"></a>私有 IP 地址范围有三段</h3><blockquote><p>根据 <a href="https://tools.ietf.org/html/rfc1918">RFC 1918</a>，私有 IP 地址范围有三段，每段都是专门保留给局域网使用的，不会在公网中出现：</p><ol><li><strong>10.0.0.0 - 10.255.255.255</strong>（10.0.0.0&#x2F;8）：适用于大规模的私有网络（例如大型企业内部网络）。</li><li><strong>172.16.0.0 - 172.31.255.255</strong>（172.16.0.0&#x2F;12）：适用于中等规模的私有网络。</li><li><strong>192.168.0.0 - 192.168.255.255</strong>（192.168.0.0&#x2F;16）：适用于小型私有网络，也是最常见的家用和小型办公室网络范围。</li></ol></blockquote><h3 id="子网掩码的原理"><a href="#子网掩码的原理" class="headerlink" title="子网掩码的原理"></a>子网掩码的原理</h3><p>子网掩码的作用就是分割Ip中网络和设备的部分</p><blockquote><p>在 IPv4 地址中（例如 172.21.10.67），一个 IP 地址由 32 位组成，通常分成 4 组，每组 8 位（1 个字节），用十进制表示成 <code>x.x.x.x</code> 的形式。</p><p>子网掩码也是一个 32 位的数字，它用来遮蔽 IP 地址的前几位以表示网络部分。子网掩码中的每个 <code>1</code> 表示网络部分，每个 <code>0</code> 表示主机部分。例如，<code>255.255.255.0</code> 的二进制形式是 <code>11111111.11111111.11111111.00000000</code>，表示前 24 位（即前三组 8 位）属于网络部分，最后 8 位属于主机部分。</p><p>对于 IP 地址 <code>172.21.10.67</code> 和子网掩码 <code>255.255.255.0</code>，转换为二进制为：</p><ul><li>IP 地址：<code>10101100.00010101.00001010.01000011</code>  </li><li>子网掩码：<code>11111111.11111111.11111111.00000000</code></li></ul></blockquote><h3 id="子网掩码的标准格式"><a href="#子网掩码的标准格式" class="headerlink" title="子网掩码的标准格式"></a>子网掩码的标准格式</h3><p>在二进制下，子网掩码的1或0必须连续</p><blockquote><p>标准的子网掩码格式只允许使用以下形式：</p><ul><li><code>255.0.0.0</code> (即 <code>/8</code>)</li><li><code>255.255.0.0</code> (即 <code>/16</code>)</li><li><code>255.255.255.0</code> (即 <code>/24</code>)</li><li>以及其他以 <code>1</code> 位连续、<code>0</code> 位连续的格式，比如 <code>255.255.252.0</code> (即 <code>/22</code>)</li></ul></blockquote><h3 id="如何计算一个子网的-IP-地址数量"><a href="#如何计算一个子网的-IP-地址数量" class="headerlink" title="如何计算一个子网的 IP 地址数量"></a>如何计算一个子网的 IP 地址数量</h3><p>$$<br>\text{可用 IP 地址数} &#x3D; 2^{(32 - \text{子网掩码中的1的数量})} - 2<br>$$</p><blockquote><ul><li><strong><code>255.255.255.0</code></strong> (<code>/24</code>)：32 - 24 &#x3D; 8，所以可用 IP 数是 $ 2^8 - 2 &#x3D; 256 - 2 &#x3D; 254$</li><li><strong><code>255.255.252.0</code></strong> (<code>/22</code>)：32 - 22 &#x3D; 10，所以可用 IP 数是 $2^{10} - 2 &#x3D; 1024 - 2 &#x3D; 1022 $</li></ul></blockquote><h3 id="ARP-Address-Resolution-Protocol-地址解析协议-是一种网络协议"><a href="#ARP-Address-Resolution-Protocol-地址解析协议-是一种网络协议" class="headerlink" title="ARP(Address Resolution Protocol,地址解析协议)是一种网络协议"></a>ARP(Address Resolution Protocol,地址解析协议)是一种网络协议</h3><p>ARP地址解析协议用于将IP地址解析为物理地址(MAC地址)。</p><blockquote><p>在局域网中，设备通过 IP 地址识别对方，但实际的数据传输是通过 MAC 地址完成的。ARP 的主要作用是找到目标 IP 地址所对应的 MAC 地址，以便正确地传输数据。</p></blockquote><h3 id="ARP广播就是设备通过IP找对应MAC的过程"><a href="#ARP广播就是设备通过IP找对应MAC的过程" class="headerlink" title="ARP广播就是设备通过IP找对应MAC的过程"></a>ARP广播就是设备通过IP找对应MAC的过程</h3><blockquote><p>当设备 A 想要与设备 B 通信时，设备 A 需要知道设备 B 的 MAC 地址，但它可能只知道设备 B 的 IP 地址。</p><p>设备 A 会发送一个 ARP 广播请求，内容大致为“谁的 IP 地址是 X.X.X.X？请告诉我你的 MAC 地址。”</p><p>这个广播会被发送到同一局域网的所有设备（因为是广播），只有 IP 地址匹配的设备（即设备 B）会回应这个请求。</p><p>设备 B 收到请求后，会发送一个 ARP 响应，告知设备 A 其 MAC 地址。</p><p>设备 A 获取到设备 B 的 MAC 地址后，就可以通过该 MAC 地址将数据发送给设备 B。</p></blockquote><h3 id="ARP缓存就是IP与MAC的对应表"><a href="#ARP缓存就是IP与MAC的对应表" class="headerlink" title="ARP缓存就是IP与MAC的对应表"></a>ARP缓存就是IP与MAC的对应表</h3><blockquote><p>ARP 缓存是设备维护的一个表，用于存储 IP 地址和 MAC 地址之间的映射关系。</p><p>当设备 A 获取了设备 B 的 MAC 地址后，它会将该 IP 地址和 MAC 地址对暂时存储在 ARP 缓存中。</p><p>这样，当设备 A 下次需要和设备 B 通信时，可以直接从 ARP 缓存中查找，不需要再次发送 ARP 广播请求。</p><p>ARP 缓存中的记录通常有一定的生存时间（TTL），过期后会自动清除。如果设备 A 再次需要与设备 B 通信，则需要重新发送 ARP 请求。</p><p>在Windows和Linux上用<code>arp -a</code>命令可以查看这张表</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows设置网络优先级</title>
    <link href="/2024/10/30/Windows%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <url>/2024/10/30/Windows%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C%E4%BC%98%E5%85%88%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<p>本文内容基于此文章内容，感谢作者分享经验。</p><p><a href="https://www.bilibili.com/read/cv33491047/?jump_opus=1">Windows11 同时连接有线和 WiFi 双网卡时，设置网络优先级 - 哔哩哔哩</a></p><p>在 Windows 11 中，同时连接无线和有线网络时，可以通过更改网络适配器的“跃点数”来设置优先级。跃点数是一个数字，数字越小，优先级越高</p><p>设置步骤如下：</p><ol><li><p>按 Windows  + R 打开运行窗口</p></li><li><p>在运行窗口中输入 ncpa.cpl，然后按回车即可打开网络适配器</p><p><img src="/../images/Windows%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C%E4%BC%98%E5%85%88%E7%BA%A7/image-20241031144315052.png" alt="image-20241031144315052"></p></li><li><p>在网络适配器窗口中，右键单击要设置优先级的网络适配器，然后选择属性</p></li><li><p>在网络适配器属性窗口中，选择 Internet 协议版本 4 (TCP&#x2F;IPv4)，点击属性，然后再点击高级</p><p><img src="/../images/Windows%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C%E4%BC%98%E5%85%88%E7%BA%A7/image-20241031144351703.png" alt="image-20241031144351703"></p></li><li><p>在 高级 TCP&#x2F;IP 设置 窗口中，取消勾选 自动跃点</p><p><img src="/../images/Windows%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C%E4%BC%98%E5%85%88%E7%BA%A7/image-20241031144421772.png" alt="image-20241031144421772"></p></li><li><p>在 默认网关 项目中点击编辑，取消勾选 自动跃点</p></li><li><p>在上面两个 跃点数 框中，输入要设置的跃点数，数字越小，优先级越高</p></li></ol><p>8.设置好后，可以在 Powershell 或 终端 中，使用 <code>route print</code> 命令查看跃点数</p><p>例如：</p><p>如果要 优先使用有线网络，可以将有线网络的跃点数设置为 10，将无线网络的跃点数设置为 20</p><p>如果要 优先使用无线网络，可以将无线网络的跃点数设置为 10，将有线网络的跃点数设置为 20</p><p>注意：</p><p>更改网络适配器的跃点数后，需要重新启动计算机才能使设置生效</p><p>如果不确定要设置哪个跃点数，可以参考以下建议：</p><p>通常情况下，有线网络的优先级应高于无线网络<br>如果无线网络连接速度较快，可以将无线网络的优先级设置得更高</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一星期的七天都有着什么意象</title>
    <link href="/2024/10/29/%E4%B8%80%E6%98%9F%E6%9C%9F%E7%9A%84%E4%B8%83%E5%A4%A9%E9%83%BD%E6%9C%89%E7%9D%80%E4%BB%80%E4%B9%88%E6%84%8F%E8%B1%A1/"/>
    <url>/2024/10/29/%E4%B8%80%E6%98%9F%E6%9C%9F%E7%9A%84%E4%B8%83%E5%A4%A9%E9%83%BD%E6%9C%89%E7%9D%80%E4%BB%80%E4%B9%88%E6%84%8F%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.gcores.com/videos/119831">一星期的七天都各自代表着哪位神明呢？ | 机核 GCORES</a>本文基本为该视频的总结版。</p><ul><li><p>Sunday</p><ul><li>赫利俄斯之日</li></ul></li><li><p>Monday</p><ul><li>塞勒涅之日</li></ul></li><li><p>Tuesday</p><ul><li>提尔之日</li></ul></li><li><p>Wendy</p><ul><li>奥丁之日（奥丁在英语里称Woden）</li></ul></li><li><p>Thursday</p><ul><li>索尔之日</li></ul></li><li><p>Friday</p><ul><li>芙利嘉之日</li></ul></li><li><p>Saturday</p><ul><li>萨图恩之日（农神，克洛诺斯的某些设定来自于他）</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>将ipynb文件转换为markdown</title>
    <link href="/2024/10/27/%E5%B0%86ipynb%E6%96%87%E4%BB%B6%E8%BD%AC%E6%8D%A2%E4%B8%BAmarkdown/"/>
    <url>/2024/10/27/%E5%B0%86ipynb%E6%96%87%E4%BB%B6%E8%BD%AC%E6%8D%A2%E4%B8%BAmarkdown/</url>
    
    <content type="html"><![CDATA[<p><code>nbconvert</code> 是 Jupyter Notebook 提供的一个工具，用于将 <code>.ipynb</code> 文件转换为多种格式。你可以使用它将 Jupyter Notebook 转换为以下格式：</p><h3 id="常见的导出格式："><a href="#常见的导出格式：" class="headerlink" title="常见的导出格式："></a>常见的导出格式：</h3><ol><li><p><strong>HTML</strong>：将 Notebook 导出为 HTML 文件，适合在网页中查看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jupyter nbconvert --to html notebook.ipynb<br></code></pre></td></tr></table></figure></li><li><p><strong>Markdown</strong>：将 Notebook 导出为 Markdown 格式，可以方便地在博客或 GitHub 中查看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jupyter nbconvert --to markdown notebook.ipynb<br></code></pre></td></tr></table></figure></li><li><p><strong>PDF</strong>：将 Notebook 导出为 PDF 文件，适合打印或分享。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jupyter nbconvert --to pdf notebook.ipynb<br></code></pre></td></tr></table></figure></li><li><p><strong>LaTeX</strong>：将 Notebook 导出为 LaTeX 格式，可以进一步转化为高质量的 PDF。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jupyter nbconvert --to latex notebook.ipynb<br></code></pre></td></tr></table></figure></li><li><p><strong>Python</strong>：将 Notebook 转换为 Python 脚本（<code>.py</code> 文件）。这个格式将所有代码和注释提取到一个 Python 文件中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jupyter nbconvert --to script notebook.ipynb<br></code></pre></td></tr></table></figure></li><li><p><strong>Reveal.js</strong>：将 Notebook 导出为 HTML 幻灯片（使用 Reveal.js 库）。适合用作展示或教学演示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jupyter nbconvert --to reveal_slides notebook.ipynb<br></code></pre></td></tr></table></figure></li><li><p><strong>Executable Script</strong>：将 Notebook 导出为可执行的脚本格式，例如 Bash 脚本等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jupyter nbconvert --to script notebook.ipynb<br></code></pre></td></tr></table></figure></li><li><p><strong>Notebooks（No conversion, just saves as <code>.ipynb</code>）</strong>：直接保存为 <code>.ipynb</code> 文件，不进行任何转换。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jupyter nbconvert --to notebook notebook.ipynb<br></code></pre></td></tr></table></figure></li></ol><h3 id="其他导出格式："><a href="#其他导出格式：" class="headerlink" title="其他导出格式："></a>其他导出格式：</h3><ul><li><strong>Custom Formats</strong>：可以定义自己的模板或导出格式。对于某些高级用户，<code>nbconvert</code> 允许使用自定义模板进行导出。</li></ul><h3 id="使用示例："><a href="#使用示例：" class="headerlink" title="使用示例："></a>使用示例：</h3><p>假设你有一个名为 <code>notebook.ipynb</code> 的 Jupyter Notebook 文件，想要将其转换为 HTML 格式，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jupyter nbconvert --to html notebook.ipynb<br></code></pre></td></tr></table></figure><p>转换后的文件将在当前目录下生成一个名为 <code>notebook.html</code> 的 HTML 文件，你可以在浏览器中打开它。</p><p>你也可以将转换的结果输出到指定的文件夹或文件名中，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jupyter nbconvert --to html notebook.ipynb --output /path/to/output/notebook.html<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>nbconvert</code> 支持将 Jupyter Notebook 导出为多种格式，主要包括 <strong>HTML</strong>、<strong>Markdown</strong>、<strong>PDF</strong>、<strong>LaTeX</strong>、<strong>Python</strong> 等格式，适合不同需求的使用场景。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jupyter</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生词本</title>
    <link href="/2024/10/27/%E7%94%9F%E8%AF%8D%E6%9C%AC/"/>
    <url>/2024/10/27/%E7%94%9F%E8%AF%8D%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<blockquote><p>sentinel</p><p>n. 哨兵<br>vt. 守卫，放哨</p><p>Gundam Sentinel 高达前哨战 ; 联邦先锋战<br>sentinel valve 报警阀 ; 脉冲阀 ; 信号阀 ; 警示阀<br>Sentinel Prime 御天敌 ; 御死敌 ; 御天至尊 ; 御天友</p></blockquote><blockquote><p>params</p><p>n. 参数；参数个数（param 的复数）<br>Raycaster params 光线追踪参数 ; 光线计算参数<br>Common params 通用参数<br>Reycaster Params 光线投射选项组</p></blockquote><blockquote><p>grid</p><p>n. 网格，方格；栅栏；输电网，电力网；赛车起跑线；美式橄榄球球场，橄榄球赛；（控制）栅极；计算机联网<br>v. 使……构成网格状，布置成网格结构<br>Grid computing 网格计算 ; 网格计较<br>Power Grid 发电厂 ; 电力网 ; 电力公司 ; 电网<br>State Grid 国家电网公司 ; 国家电网 ; 电网公司 ; 中国国家电网</p></blockquote><blockquote><p>intermediate<br>adj. 居中的，中间的；中等程度的，中级的<br>n. 中级水平者，中级学生；中间事物；（化合物）中间体<br>v. 充当调解人，斡旋</p><p>intermediate filament  细胞   中间纤维 ; 间纤维 ; 中间丝状体 ;   细胞   中间丝<br>Intermediate Egret 鸟<br>Intermediate Region 中间区域 ; 中间地带 ; 中间区</p></blockquote><blockquote><p>protocol</p><p>n. 礼仪，礼节；国际议定书，协议；条约草案，（协议或条约的）附件；（协定，公约）修正案（或增补）；（数据传递的）协议，规约；科学实验计划，医疗方案；（科学实验结果的）官方记录<br>v. 以协议形式发布；拟定</p><p>Montreal Protocol 蒙特利尔协议 ; 蒙特利尔协定<br>Kyoto Protocol 京都议定书 ; 京都协定<br>routing protocol 路由协议 ; 路由选择协议 ; 路由协定 ; 路由选择和谈</p></blockquote><blockquote><p>transmission</p><p>n. （无线电、电视等信号的）播送，发送；（电台或电视等的）信息，广播；传递，传播，传染；（车辆的）传动装置，变速器<br>Transmission Line  电讯   传输线 ; 输电线 ; 输电线路 ;   电讯   传输线路<br>automatic transmission  车辆   自动变速器 ;   机   自动变速装置 ; 自动换档 ; 自动发报<br>Maximum Transmission Unit 最大传输单元</p></blockquote><blockquote><p>Synchronize</p><p>vt. （使）同步；对准（钟，表）；相符；（电脑）同步化</p><p>Synchronize Selection 同步选择<br>synchronous synchronize 同步<br>Synchronize Sequence Numbers 同步序列编号</p></blockquote><blockquote><p>Sequence</p><p>n. 顺序，次序；连续事件（或动作、事物）；（电影中表现同一主题或场面的）一组镜头；（生物学中分子或基因的排列）顺序；模进；（纸牌的）同花顺；序列；（天主教弥撒中圣歌与福音之间的）继续经<br>v. 按顺序排列；测定（整套基因或分子成分的）序列；用音序器播放（或录制）音乐</p><p>Sequence Diagram 时序图 ; 序列图 ; 顺序图 ; 循序图<br>Cauchy sequence 柯西序列 ; 柯悟列 ; 柯西列<br>main sequence 主序星 ; 主序带</p></blockquote><blockquote><p>parameter</p><p>n. 界限，范围；参数，变量；（统计）人口参数</p><p>parameter estimation 参数估计<br>technical parameter 技术参数；技术参考<br>technological parameter 工艺参数</p></blockquote><blockquote><p>queuing</p><p>v. &lt;英&gt;排队（等候）；竞相，抢着（做某事）（queue 的现在分词）</p><p>queuing theory 排队论；研究等待时间的等候理论<br>queuing model 排队模型；等候模式</p></blockquote><blockquote><p>Telemetry</p><p>n. [自] 遥测技术；遥感勘测；自动测量记录传导</p><p>telemetry data 遥测数据</p></blockquote><blockquote><p>Transport</p><p>n. 运输，运送；交通工具，运输方式；交通运输系统；（运送部队、给养等的）运输船，运输机；强烈的感情，狂喜；&lt;史&gt;流放犯<br>v. （用交通工具）运输，运送；（以自然方式）运输，传播；使产生身临其境的感觉；流放，放逐（犯人）；使狂喜，使（某人）充满强烈情感（尤指快乐）</p></blockquote><blockquote><p>Attribute</p><p>v. 把……归因于；认为是……所作；认为……具有某种特质<br>n. 属性，特质；标志，象征；定语</p><p>attribute data 属性资料（数据）<br>attribute value 属性值<br>attribute name 属性名称</p></blockquote><blockquote><p>constructor</p><p>n. 构造函数；构造器；建造者</p><p>Provide at least one  constructor . 至少提供一个构造函数。<br>Executes the rest of the  constructor . 执行构造函数的剩余部分。<br>Provide a  constructor . 提供构造函数。</p></blockquote><blockquote><p>usage</p><p>n. （词语的）用法；使用，用量；（尤指形成权利，义务，标准等的）常规做法，惯例；&lt;正式&gt;虐待，不公待遇</p><p>usage rate 使用率<br>long term usage 长期使用<br>usage time 使用时间；通信传输时间</p></blockquote><blockquote><p>Dispose</p><p>v. 处理，放置，安排；使易于，使倾向于；丢掉</p><p>dispose of 去掉 ; 解决 ; 处理掉 ; 除掉<br>dispose for 布置<br>Dispose Pattern 处置模式 ; 清理模式 ; 释放模式 ; 料理</p></blockquote><blockquote><p>Assembly </p><p>n. 议会，代表大会；集会，集会者；装配，组装；（计算机）汇编</p><p>National Assembly 国民大会 ; 国民议会 ; 国民会议 ; 韩国国民大会<br>assembly line  装配线 ; 组装线 ; 生产流水线<br>assembly language  汇编语言</p></blockquote><blockquote><p>Ethernet </p><p>n.以太网</p></blockquote><blockquote><p>frame </p><p>n.帧，框架</p><p>frame relay  通信   帧中继 ; 桢中继<br>frame rate 帧率 ; 帧速率 ; 帧频 ; 画面更新率<br>Jumbo Frame 巨型帧 ; 超长帧 ; 改成无</p></blockquote><blockquote><p>manual</p><p>adj. 手工的，体力的；手动的，用手操作的<br>n. 使用手册，说明书；手动换挡的车辆；风琴键盘；（牧师主持圣礼时用）礼仪书</p><p>manual operation [计]人工操作；手控<br>manual work 手工作业<br>manual control 手动控制；人工控制</p></blockquote><blockquote><p>Abort<br>v. （使）流产，堕（胎）；（由于问题或故障）中止，使夭折；（胚胎器官，有机体）发育不全，败育<br>n. &lt;非正式&gt;（飞行、航天任务或其他事业的）中断，取消；夭折的计划（或事业）</p><p>abort light 紧急故障信号 ; 故障信号灯 ; 紧急停机信号 ; 故障信号<br>Data Abort 数据访问中止 ; 数据中止 ; 数据异常 ; 数据终止<br>abort sequence 中断序列 ;   计   放弃序列 ; 中止序列 ; 异常中止顺序</p></blockquote><blockquote><p>Broker</p><p>n. 经纪人，中间人，代理服务器<br>v. 协调，安排</p><p>Insurance Broker  保险   保险经纪人 ; 保险经济人 ; 保险经纪<br>Stock Broker 证券经纪人 ; 股票经纪 ; 股票经纪人 ; 证券经纪<br>Customs broker  贸易   报关行 ; 代理报关 ; 报关员</p></blockquote><blockquote><p>Finite </p><p>adj. 有限的，有限制的；限定的<br>n. 有限之物</p><p>finite element  数   有限元 ; 有限元法 ; 有限单元法 ; 有限元素<br>finite field  数   有限域 ; 结合有限场<br>non-finite verb 非限定动词 ; 非谓语动词 ; 非限制动词 ; 性动词</p></blockquote><blockquote><p>gelato</p><p>n. （意大利语）冰淇淋<br>n. （Gelato）人名；（意）杰拉托</p></blockquote><blockquote><p>trim</p><p>v. 修剪，修整；削减，减少；修饰，点缀（尤指某物的边缘）；切除，剪掉（不规则或不需要的部分）；调整（船帆）利用风力；使（飞机）配平；调整负载以保持（船，飞机）的平衡；使（身体某一部分）变结实，变瘦；（为个人升迁而在政治上）随大流，见风使舵<br>n. （尤指毛发的）修剪；额外装饰，边饰，点缀物；汽车装饰（尤指车内座椅铺面或内垫衬料）；（电影剪辑后的）废片；（船在水中的）水平位势；（飞机）配平；良好的状态（或情况）；机翼的位置<br>adj. 整齐的，整洁美观的；修长的，苗条而健康的</p><p>interior trim 内部装饰<br>out of trim 未准备好；失去平衡；健康情况不佳<br>trim down 裁减</p></blockquote><blockquote><p>fund</p><p>n. 基金，专款；资金，钱款；基金会；储备量<br>v. 资助，为……提供资金</p><p>hedge fund 对冲基金 ; 避险基金 ; 套保基金 ; 套利基金<br>mutual fund 共同基金 ; 互助基金 ; 互惠基金 ; 公共基金<br>fund manager 基金经理 ; 财务经理 ; 管理公司</p></blockquote><blockquote><p>dispose</p><p>v. 处理，放置，安排；使易于，使倾向于；丢掉</p><p>dispose of 去掉 ; 解决 ; 处理掉 ; 除掉<br>dispose for 布置<br>Dispose Pattern 处置模式 ; 清理模式 ; 释放模式 ; 料理</p></blockquote><blockquote><p>fractional</p><p>adj. 部分的；[数] 分数的，小数的</p><p>fractional crystallization 分离结晶；分步结晶；分馏结晶作用；分级析晶<br>fractional order 分数阶<br>fractional distillation 分馏</p></blockquote><blockquote><p>nozzle</p><p>n. 管口，喷嘴；&lt;俚&gt;鼻子</p><p>spray nozzle 喷雾嘴；水雾喷嘴<br>jet nozzle 喷嘴；尾喷口；喷射管<br>submerged nozzle 浸入式水口</p></blockquote><blockquote><p>Elapsed</p><p>v. （时间）消逝，过去（elapse 的过去式和过去分词）<br>adj. 过去的，经过的</p><p>elapsed time 运行时间，经过时间</p></blockquote><blockquote><p>populate</p><p>v. （大批人或动物）居住于，生活于；充满，出现于（某地方，领域）；迁移，殖民于；（给文件）增添数据，输入数据</p><p>Easy Populate CSV 插件<br>Populate Tool 随机复制工具<br>Populate ACE Book 更新ACE帐簿</p></blockquote><blockquote><p>paradigm</p><p>n. 范例，模范</p><p>Programming Paradigms 编程范式 ; 编程思维模型 ; 字幕 ; 程序设计典范<br>desktop paradigms 桌面范例<br>the experimental paradigms 实验范式</p></blockquote><blockquote><p>operand</p><p>n. [计] 操作数；[计] 运算对象</p><p>1 [计]  操作数 关键字（keyword）：编译器或解释器保留的词，用于解析程序；变量名不能使用关键字，如if，def，while等。 操作数（ operand ）：操作符所操作的值。 表达式（expression）：变量、操作符和值的组合，可以表示一个单独的结果值。<br>2  运算元 指令(Instructions)是CPU执行的操作，通常指令也称作操作码(Opcode)： 运算元 (Operand)是指令操作的对像：而位址(Address)是指定资料在记忆体中的位置。<br>3 [计]  运算对象 表达式由一个或多个运算对象（ operand ）组成，对表达式求值将得到一个结果（result）。字面值和变量是最简单的表达式（expression），其结果就是字面值和变量的值。<br>4  操作 … one connected blob一个连接的斑点；同一连接泡  operand 操作 ；运算对象  operand s运算物体；运算对象 …<br>Operand Stack 操作数堆栈 ; 操作数栈 ; 栈操作 ; 操作栈<br>positional operand 定位操 ; 部位操作数 ;   计   定位操作数<br>address operand 地址操 ; 操作数地址 ; 地址操作数 ; 地址修改</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单词</tag>
      
      <tag>English</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PowerShell知识点</title>
    <link href="/2024/10/27/PowerShell%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2024/10/27/PowerShell%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>Get-Help对标Linux中的-help<br>Get-Adapter命令查看所有网卡</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Get-NetAdapter</span> | <span class="hljs-built_in">Select-Object</span> <span class="hljs-literal">-ExpandProperty</span> Name<br><span class="hljs-comment">#Select-Object 可以用 select 代替</span><br><span class="hljs-comment">&lt;#</span><br><span class="hljs-comment">这里用了管道操作符来筛选出Name属性，也可以不用，直接显示所有网卡的所有信息</span><br><span class="hljs-comment">#&gt;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>命令</th><th>解释</th><th>别名</th></tr></thead><tbody><tr><td>Remove-Item</td><td></td><td>rm</td></tr><tr><td>Rename-Item</td><td></td><td>ren</td></tr><tr><td>Get-ChildItem</td><td></td><td>ls</td></tr><tr><td>Get-Command</td><td>获得命令相关信息</td><td>gcm</td></tr><tr><td>Write-Output</td><td></td><td>echo</td></tr><tr><td>Start-Process</td><td>单开一个进程运行程序</td><td>start</td></tr><tr><td>Invoke-Item</td><td></td><td>ii</td></tr><tr><td>Get-Item</td><td></td><td>gi</td></tr><tr><td>Get-ItemProperty</td><td>检索注册表项的属性或文件系统对象的属性</td><td>gp</td></tr><tr><td>Select-Object</td><td>选择对象的属性和对象</td><td>select</td></tr><tr><td>Get-Job</td><td>检查后台作业的任务</td><td>gjb</td></tr><tr><td>Start-Job</td><td>让任务在后台作业（终端关闭即关闭）</td><td>sajb</td></tr><tr><td>New-Item</td><td><strong>基本等同于Linux的touch</strong></td><td>ni</td></tr><tr><td>Get-Help</td><td>查看命令帮助文档</td><td>man</td></tr></tbody></table><p>或且非——<code>-or</code>、<code>-and</code>、<code>-not</code></p><p>执行命令而不返回回显信息</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$ExecutionContext</span>.PreExecutionContextInitScript = &#123; <span class="hljs-variable">$PSDefaultParameterValues</span>[<span class="hljs-string">&quot;*:ErrorAction&quot;</span>] = <span class="hljs-string">&quot;SilentlyContinue&quot;</span> &#125;<br></code></pre></td></tr></table></figure><p>查找环境变量中的命令可执行文件的位置，如</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Get-Command</span> python<br><span class="hljs-comment">#或者</span><br><span class="hljs-built_in">gcm</span> python<br></code></pre></td></tr></table></figure><p>返回</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">CommandType     Name                                               Version    Source<br><span class="hljs-literal">-----------</span>     <span class="hljs-literal">----</span>                                               <span class="hljs-literal">-------</span>    <span class="hljs-literal">------</span><br>Application     python.exe                                         <span class="hljs-number">3.9</span>.<span class="hljs-number">131</span>... C:\Program Files (x86)\Microsoft Visual Studio\Shar...<br></code></pre></td></tr></table></figure><p>也可以<code>(gcm python).Source</code>,返回</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">C:\Program Files (x86)\Microsoft Visual Studio\Shared\Python39_64\python.exe<br></code></pre></td></tr></table></figure><p>sysdm.cpl打开系统属性</p><p>regedit打开注册表编辑器</p><p>Clear-RycycleBin清空回收站 -DriveLetter C 或者C，D，E或者*</p><p>taskmgr打开任务管理器</p><p>devmgmt.msc打开设备管理器</p><p><strong>脚本参数</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-keyword">param</span> (<br>    [<span class="hljs-type">Alias</span>(<span class="hljs-string">&quot;r&quot;</span>)]<span class="hljs-comment">#为参数指定别名&#x27;r&#x27;</span><br>    [<span class="hljs-built_in">string</span>]<span class="hljs-variable">$RuntimeIdentifier</span> = <span class="hljs-string">&quot;win-x64&quot;</span><span class="hljs-comment">#定义一个字符串类型的参数，并设定默认值为&quot;win-x64&quot;</span><br>)<br></code></pre></td></tr></table></figure><p>如果想要用两个变量来拼成一句命令，需要在行首放一个”&amp;”调用运算符</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">(netstat <span class="hljs-literal">-ano</span> | findstr :<span class="hljs-number">1883</span>).Split(<span class="hljs-string">&quot;`n&quot;</span>).Count<br><span class="hljs-comment">#获取所有连接并显示它们的pid，找到其中1883端口的，输出内容根据行来分割成数组，计数</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>PowerShell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2024/10/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2024/10/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h1><p>总体来说设计模式分为三大类：</p><p><strong>创建型模式</strong>，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p><p><strong>结构型模式</strong>，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p><p><strong>行为型模式</strong>，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><p>这三种设计模式分别关注:<strong>如何创建对象</strong>,<strong>如何组织类与对象</strong>,<strong>如何在对象之间进行职责分配和交互</strong>。</p><p>经典的设计模式有23种。随着编程语言的演进，一些设计模式（比如Singleton）也随之过时，甚至成了反模式，一些则被内置在编程语言中（比如Iterator），另外还有一些新的模式诞生（比如Monostate）。</p><ul><li>创建型</li></ul><p>常用的有：<a href="https://www.zhihu.com/search?q=%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:3066680548%7D">单例模式</a>、工厂模式（工厂方法和抽象工厂）、<a href="https://www.zhihu.com/search?q=%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:3066680548%7D">建造者模式</a>。</p><p>不常用的有：原型模式。</p><ul><li>结构型</li></ul><p>常用的有：代理模式、桥接模式、装饰者模式、<a href="https://www.zhihu.com/search?q=%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:3066680548%7D">适配器模式</a>。</p><p>不常用的有：门面模式、组合模式、<a href="https://www.zhihu.com/search?q=%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:3051466608%7D">享元模式</a>。</p><ul><li>行为型</li></ul><p>常用的有：<a href="https://www.zhihu.com/search?q=%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:3051466608%7D">观察者模式</a>、模板模式、策略模式、职责链模式、<a href="https://www.zhihu.com/search?q=%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:3051466608%7D">迭代器模式</a>、状态模式。</p><p>不常用的有：<a href="https://www.zhihu.com/search?q=%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:3051466608%7D">访问者模式</a>、<a href="https://www.zhihu.com/search?q=%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:3066680548%7D">备忘录模式</a>、命令模式、<a href="https://www.zhihu.com/search?q=%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:3051466608%7D">解释器模式</a>、<a href="https://www.zhihu.com/search?q=%E4%B8%AD%E4%BB%8B%E6%A8%A1%E5%BC%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:3066680548%7D">中介模式</a>。</p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/v2-c2c7af7c27e0db3f075b2e05e819d02f_720w.webp" alt="img"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/v2-fcc5b0cfee03ff17b7887a028054b191_720w.webp" alt="img"></p><h1 id="设计模式的具体实现"><a href="#设计模式的具体实现" class="headerlink" title="设计模式的具体实现"></a>设计模式的具体实现</h1><h2 id="C"><a href="#C" class="headerlink" title="C#"></a>C#</h2><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IProduct</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Use</span>()</span>;  <span class="hljs-comment">// 所有产品都会提供 Use() 方法</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ProductA</span> : <span class="hljs-title">IProduct</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Use</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;使用产品 A 的功能...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ProductB</span> : <span class="hljs-title">IProduct</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Use</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;使用产品 B 的功能...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SimpleFactory</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IProduct <span class="hljs-title">CreateProduct</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> type</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">switch</span> (type)<br>        &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;A&quot;</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ProductA();<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;B&quot;</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ProductB();<br>            <span class="hljs-literal">default</span>:<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentException(<span class="hljs-string">$&quot;未知产品类型：<span class="hljs-subst">&#123;type&#125;</span>&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 客户端决定需要哪个类型的产品，或者可以由配置文件/用户输入等决定</span><br>        IProduct product1 = SimpleFactory.CreateProduct(<span class="hljs-string">&quot;A&quot;</span>);<br>        product1.Use(); <span class="hljs-comment">// 输出：使用产品 A 的功能...</span><br><br>        IProduct product2 = SimpleFactory.CreateProduct(<span class="hljs-string">&quot;B&quot;</span>);<br>        product2.Use(); <span class="hljs-comment">// 输出：使用产品 B 的功能...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//我们以“日志记录器（Logger）”为例，实现两种不同的日志输出方式：Console 日志与 File 日志</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ILogger</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Log</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ConsoleLogger</span> : <span class="hljs-title">ILogger</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Log</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;[Console Logger] <span class="hljs-subst">&#123;message&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FileLogger</span> : <span class="hljs-title">ILogger</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Log</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 简化实现，实际要考虑IO处理、文件路径等</span><br>        File.WriteAllText(<span class="hljs-string">@&quot;&quot;</span>,<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;message&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//定义抽象工厂</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LoggerCreator</span><br>&#123;<br>    <span class="hljs-comment">// 工厂方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> ILogger <span class="hljs-title">FactoryMethod</span>()</span>;<br><br>    <span class="hljs-comment">// 提供公共逻辑，这里演示一个示例</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteLog</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 通过工厂方法获得具体日志类</span><br>        ILogger logger = FactoryMethod();<br>        <span class="hljs-comment">// 写入日志</span><br>        logger.Log(message);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//定义具体工厂</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ConsoleLoggerCreator</span> : <span class="hljs-title">LoggerCreator</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> ILogger <span class="hljs-title">FactoryMethod</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConsoleLogger();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FileLoggerCreator</span> : <span class="hljs-title">LoggerCreator</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> ILogger <span class="hljs-title">FactoryMethod</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FileLogger();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 可能来自配置或运行时判断</span><br>        LoggerCreator creator;<br><br>        <span class="hljs-comment">// 假设在这里我们需要一个控制台日志</span><br>        creator = <span class="hljs-keyword">new</span> ConsoleLoggerCreator();<br>        creator.WriteLog(<span class="hljs-string">&quot;这是控制台日志内容&quot;</span>);<br><br>        <span class="hljs-comment">// 假设在这里我们需要一个文件日志</span><br>        creator = <span class="hljs-keyword">new</span> FileLoggerCreator();<br>        creator.WriteLog(<span class="hljs-string">&quot;这是文件日志内容&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IPrototype</span><br>&#123;<br>    <span class="hljs-function">IPrototype <span class="hljs-title">Clone</span>()</span>;<br>&#125;<br><span class="hljs-comment">//这其中包含一个Clone()方法，所有实现该接口的类都必须提供克隆自身的逻辑</span><br><span class="hljs-comment">//浅拷贝</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ConcretePrototype</span> : <span class="hljs-title">IPrototype</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> List&lt;<span class="hljs-built_in">string</span>&gt; Tags &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-comment">// 浅拷贝：直接使用 MemberwiseClone()</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IPrototype <span class="hljs-title">Clone</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.MemberwiseClone() <span class="hljs-keyword">as</span> IPrototype;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ToString</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">$&quot;ConcretePrototype [Name=<span class="hljs-subst">&#123;Name&#125;</span>, Tags=<span class="hljs-subst">&#123;<span class="hljs-built_in">string</span>.Join(<span class="hljs-string">&quot;,&quot;</span>, Tags)&#125;</span>]&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//深拷贝</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DeepPrototype</span> : <span class="hljs-title">IPrototype</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> List&lt;<span class="hljs-built_in">string</span>&gt; Tags &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-comment">// 深拷贝：自己动手复制复杂引用类型的内容</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IPrototype <span class="hljs-title">Clone</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 先浅拷贝</span><br>        DeepPrototype copy = <span class="hljs-keyword">this</span>.MemberwiseClone() <span class="hljs-keyword">as</span> DeepPrototype;<br><br>        <span class="hljs-comment">// 对引用类型字段进行单独拷贝</span><br>        copy.Tags = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-keyword">this</span>.Tags);<br><br>        <span class="hljs-keyword">return</span> copy;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ToString</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">$&quot;DeepPrototype [Name=<span class="hljs-subst">&#123;Name&#125;</span>, Tags=<span class="hljs-subst">&#123;<span class="hljs-built_in">string</span>.Join(<span class="hljs-string">&quot;,&quot;</span>, Tags)&#125;</span>]&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="测试代码-2"><a href="#测试代码-2" class="headerlink" title="测试代码"></a>测试代码</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// ========== 浅拷贝示例 ==========</span><br>        ConcretePrototype prototypeA = <span class="hljs-keyword">new</span> ConcretePrototype<br>        &#123;<br>            Name = <span class="hljs-string">&quot;Alpha&quot;</span>,<br>            Tags = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">string</span>&gt; &#123; <span class="hljs-string">&quot;Tag1&quot;</span>, <span class="hljs-string">&quot;Tag2&quot;</span> &#125;<br>        &#125;;<br>        Console.WriteLine(<span class="hljs-string">&quot;原对象 prototypeA: &quot;</span> + prototypeA);<br><br>        <span class="hljs-comment">// 克隆</span><br>        <span class="hljs-keyword">var</span> cloneA = prototypeA.Clone() <span class="hljs-keyword">as</span> ConcretePrototype;<br>        Console.WriteLine(<span class="hljs-string">&quot;克隆对象 cloneA:   &quot;</span> + cloneA);<br><br>        <span class="hljs-comment">// 修改克隆对象的引用类型字段</span><br>        cloneA.Tags[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;Tag999&quot;</span>;<br>        Console.WriteLine(<span class="hljs-string">&quot;\n修改 cloneA 的第一项后:&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;原对象 prototypeA: &quot;</span> + prototypeA);  <span class="hljs-comment">// &quot;Tag999&quot; 出现</span><br>        Console.WriteLine(<span class="hljs-string">&quot;克隆对象 cloneA:   &quot;</span> + cloneA);<br><br>        <span class="hljs-comment">// ========== 深拷贝示例 ==========</span><br>        DeepPrototype prototypeB = <span class="hljs-keyword">new</span> DeepPrototype<br>        &#123;<br>            Name = <span class="hljs-string">&quot;Bravo&quot;</span>,<br>            Tags = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">string</span>&gt; &#123; <span class="hljs-string">&quot;TagX&quot;</span>, <span class="hljs-string">&quot;TagY&quot;</span> &#125;<br>        &#125;;<br>        Console.WriteLine(<span class="hljs-string">&quot;\n原对象 prototypeB: &quot;</span> + prototypeB);<br><br>        <span class="hljs-comment">// 克隆</span><br>        <span class="hljs-keyword">var</span> cloneB = prototypeB.Clone() <span class="hljs-keyword">as</span> DeepPrototype;<br>        Console.WriteLine(<span class="hljs-string">&quot;克隆对象 cloneB:   &quot;</span> + cloneB);<br><br>        <span class="hljs-comment">// 修改克隆对象的引用类型字段</span><br>        cloneB.Tags[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;Tag999&quot;</span>;<br>        Console.WriteLine(<span class="hljs-string">&quot;\n修改 cloneB 的第一项后:&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;原对象 prototypeB: &quot;</span> + prototypeB);  <span class="hljs-comment">// 仍然是 &quot;TagX&quot;</span><br>        Console.WriteLine(<span class="hljs-string">&quot;克隆对象 cloneB:   &quot;</span> + cloneB);<br><br>        <span class="hljs-comment">// 暂停</span><br>        Console.ReadKey();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用上感觉就是用一种隔了层纱的方式来用了指针。</p><h4 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//产品类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Computer</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> CPU &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Memory &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Storage &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> GPU &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ToString</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">$&quot;Computer: CPU=<span class="hljs-subst">&#123;CPU&#125;</span>, Memory=<span class="hljs-subst">&#123;Memory&#125;</span>GB, Storage=<span class="hljs-subst">&#123;Storage&#125;</span>GB, GPU=<span class="hljs-subst">&#123;GPU&#125;</span>&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//抽象建造者</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IComputerBuilder</span><br>&#123;<br>    <span class="hljs-comment">//定义了建造步骤</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BuildCPU</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BuildMemory</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BuildStorage</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BuildGPU</span>()</span>;<br>    <br>    <span class="hljs-comment">//最后返回最终构造好的产品对象</span><br>    <span class="hljs-function">Computer <span class="hljs-title">GetComputer</span>()</span>;<br>&#125;<br><span class="hljs-comment">//具体建造者</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GamingComputerBuilder</span> : <span class="hljs-title">IComputerBuilder</span><br>&#123;<br>    <span class="hljs-keyword">private</span> Computer _computer = <span class="hljs-keyword">new</span> Computer();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildCPU</span>()</span><br>    &#123;<br>        _computer.CPU = <span class="hljs-string">&quot;Intel Core i9&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildMemory</span>()</span><br>    &#123;<br>        _computer.Memory = <span class="hljs-number">32</span>; <span class="hljs-comment">// 32 GB</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildStorage</span>()</span><br>    &#123;<br>        _computer.Storage = <span class="hljs-number">2000</span>; <span class="hljs-comment">// 2 TB</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildGPU</span>()</span><br>    &#123;<br>        _computer.GPU = <span class="hljs-string">&quot;NVIDIA GeForce RTX 4090&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Computer <span class="hljs-title">GetComputer</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> _computer;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//办公电脑建造者</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">OfficeComputerBuilder</span> : <span class="hljs-title">IComputerBuilder</span><br>&#123;<br>    <span class="hljs-keyword">private</span> Computer _computer = <span class="hljs-keyword">new</span> Computer();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildCPU</span>()</span><br>    &#123;<br>        _computer.CPU = <span class="hljs-string">&quot;Intel Core i5&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildMemory</span>()</span><br>    &#123;<br>        _computer.Memory = <span class="hljs-number">16</span>; <span class="hljs-comment">// 16 GB</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildStorage</span>()</span><br>    &#123;<br>        _computer.Storage = <span class="hljs-number">512</span>; <span class="hljs-comment">// 512 GB</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildGPU</span>()</span><br>    &#123;<br>        _computer.GPU = <span class="hljs-string">&quot;Integrated Graphics&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Computer <span class="hljs-title">GetComputer</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> _computer;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//指挥者</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ComputerDirector</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Construct</span>(<span class="hljs-params">IComputerBuilder builder</span>)</span><br>    &#123;<br>        builder.BuildCPU();<br>        builder.BuildMemory();<br>        builder.BuildStorage();<br>        builder.BuildGPU();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//电脑指挥者里只有一个构建方法，它知道构建流程，依次调用CPU、内存、存储、GPU 的建造。</span><br><span class="hljs-comment">//在更复杂的场景里，你也可以在指挥者里灵活地对建造步骤进行顺序/配置上的调整。</span><br><span class="hljs-comment">//有时也可以不使用 Director，而是让客户端自己一步步调用建造者的方法——这取决于你是否需要一个统一封装的“指挥过程”。</span><br></code></pre></td></tr></table></figure><h5 id="测试代码-3"><a href="#测试代码-3" class="headerlink" title="测试代码"></a>测试代码</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        ComputerDirector director = <span class="hljs-keyword">new</span> ComputerDirector();<br><br>        <span class="hljs-comment">// ========== 生产一台游戏电脑 ==========</span><br>        IComputerBuilder gamingBuilder = <span class="hljs-keyword">new</span> GamingComputerBuilder();<br>        director.Construct(gamingBuilder);<br>        Computer gamingComputer = gamingBuilder.GetComputer();<br>        Console.WriteLine(<span class="hljs-string">&quot;Gaming Computer Built:&quot;</span>);<br>        Console.WriteLine(gamingComputer);<br><br>        <span class="hljs-comment">// ========== 生产一台办公电脑 ==========</span><br>        IComputerBuilder officeBuilder = <span class="hljs-keyword">new</span> OfficeComputerBuilder();<br>        director.Construct(officeBuilder);<br>        Computer officeComputer = officeBuilder.GetComputer();<br>        Console.WriteLine(<span class="hljs-string">&quot;\nOffice Computer Built:&quot;</span>);<br>        Console.WriteLine(officeComputer);<br><br>        Console.ReadKey();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="输出示例"><a href="#输出示例" class="headerlink" title="输出示例"></a>输出示例</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Gaming Computer Built:<br>Computer: CPU=Intel Core i9, Memory=<span class="hljs-number">32</span>GB, Storage=<span class="hljs-number">2000</span>GB, GPU=NVIDIA GeForce RTX <span class="hljs-number">4090</span><br><br>Office Computer Built:<br>Computer: CPU=Intel Core i5, Memory=<span class="hljs-number">16</span>GB, Storage=<span class="hljs-number">512</span>GB, GPU=Integrated Graphics<br></code></pre></td></tr></table></figure><h5 id="设计模式的优缺点"><a href="#设计模式的优缺点" class="headerlink" title="设计模式的优缺点"></a>设计模式的优缺点</h5><p><strong>优点</strong></p><ol><li><strong>封装复杂构造</strong>：将复杂对象的创建过程分步骤封装到建造者里面，客户端不必关注各个零件如何装配。</li><li><strong>更易扩展</strong>：需要变更或增加产品的组成，可以新建一个 <code>ConcreteBuilder</code> 或调整指挥者的构建流程。</li><li><strong>符合单一职责</strong>：Builder 只负责如何一步步创建对象，Director 负责指挥建造流程，Product 对象则只是数据结构。</li></ol><p><strong>缺点</strong></p><ol><li><strong>类数量增加</strong>：对于每种产品变体，都需要一个对应的 <code>ConcreteBuilder</code>。</li><li><strong>不适合变化过于频繁的场景</strong>：如果对象结构本身经常变动，Builder 也要不断调整。</li></ol><h5 id="何时考虑使用建造者模式"><a href="#何时考虑使用建造者模式" class="headerlink" title="何时考虑使用建造者模式"></a>何时考虑使用建造者模式</h5><ul><li>需要创建的对象<strong>内部结构复杂</strong>，且存在<strong>多种组合或变体</strong>。</li><li>需要将<strong>复杂的构造过程与对象本身的业务逻辑分离</strong>，使得构造过程可以被<strong>单独管理或扩展</strong>。</li><li>希望<strong>通过不同的建造者</strong>来创建“同一类对象”的<strong>不同版本</strong>（如游戏版、办公版、低配版、高配版等）。</li></ul><h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//接口定义</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ISubject</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Request</span>()</span>;<br>&#125;<br><span class="hljs-comment">//真实对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RealSubject</span> : <span class="hljs-title">ISubject</span><br>&#123;<br>    <span class="hljs-comment">//在没有代理的场景下，客户端会直接调用它的Request()</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Request</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;RealSubject: 处理请求的具体逻辑...&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//代理对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ProxySubject</span> : <span class="hljs-title">ISubject</span><br>&#123;<br>    <span class="hljs-keyword">private</span> RealSubject _realSubject;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> _userHasPermission = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 模拟权限</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Proxy</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> userHasPermission</span>)</span><br>    &#123;<br>        _userHasPermission = userHasPermission;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Request</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 在这里可以加一些 &quot;调用前&quot; 的额外操作</span><br>        Console.WriteLine(<span class="hljs-string">&quot;Proxy: 检查/预处理/延迟实例化...&quot;</span>);<br><span class="hljs-keyword">if</span> (!_userHasPermission)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Proxy: 用户没有权限，拒绝访问&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 延迟实例化(懒加载)：只有真正需要时才创建 RealSubject</span><br>        <span class="hljs-keyword">if</span> (_realSubject == <span class="hljs-literal">null</span>)<br>        &#123;<br>            _realSubject = <span class="hljs-keyword">new</span> RealSubject();<br>        &#125;<br><br>        <span class="hljs-comment">// 调用真实对象的方法</span><br>        _realSubject.Request();<br><br>        <span class="hljs-comment">// 在这里可以加一些 &quot;调用后&quot; 的额外操作</span><br>        Console.WriteLine(<span class="hljs-string">&quot;Proxy: 记录日志/缓存结果/后处理...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="测试代码-4"><a href="#测试代码-4" class="headerlink" title="测试代码"></a>测试代码</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 在客户端看来，只要知道 ISubject 接口即可</span><br>        ISubject proxy = <span class="hljs-keyword">new</span> ProxySubject();<br><br>        <span class="hljs-comment">// 通过代理来请求，而不是直接使用 RealSubject</span><br>        proxy.Request();<br><br>        Console.ReadKey();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a>常见用途</h5><ol><li><strong>虚拟代理（Virtual Proxy）</strong>：</li></ol><ul><li>当对象的实例化非常昂贵（如远程图片加载、大型数据），代理可以在使用前不去初始化对象，只有当需要访问时才进行创建，来节省资源。</li></ul><ol start="2"><li><strong>远程代理（Remote Proxy）</strong>：</li></ol><ul><li>用于隐藏一个对象实际在远程系统中（比如分布式架构、远程服务器）。客户端只调用代理，就像调用本地对象一样，代理会通过网络把请求转给远程对象。</li></ul><ol start="3"><li><strong>保护代理（Protection Proxy）</strong>：</li></ol><ul><li>用于控制对真实对象的访问。可以在代理层做权限验证、角色检查等。</li></ul><ol start="4"><li><strong>缓存代理（Cache Proxy）</strong>：</li></ol><ul><li>针对一些需要重复查询的结果，代理可以先去缓存里找，如果命中则直接返回，提高性能。</li></ul><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p><strong>优点</strong></p><ol><li><strong>在不修改真实对象的情况下扩展功能</strong>：对外仍然是同样的接口，灵活性高；</li><li><strong>增强或限制对目标对象的访问</strong>：如权限校验、懒加载、缓存等；</li><li><strong>分担职责</strong>：把一些通用逻辑（缓存、日志、权限等）从真实对象抽离到代理，简化真实对象的实现。</li></ol><p><strong>缺点</strong></p><ol><li><strong>增加类数量与系统复杂度</strong>：每个真实对象都需要对应的代理类；</li><li><strong>调用速度可能变慢</strong>：由于多了一层间接调用。</li><li><strong>过度使用</strong> 也会让系统难以维护，<strong>需谨慎设计</strong>。</li></ol><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//目标接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">INewLogger</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WriteLog</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>;<br>&#125;<br><br><span class="hljs-comment">//被适配的类</span><br><span class="hljs-comment">// 旧系统的日志类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">OldLogger</span><br>&#123;<br>    <span class="hljs-comment">// 假设旧的日志方法是这样</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LogMessage</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> msg</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;OldLogger: &quot;</span> + msg);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//适配器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LoggerAdapter</span> : <span class="hljs-title">INewLogger</span><br>&#123;<br>    <span class="hljs-keyword">private</span> OldLogger _oldLogger;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LoggerAdapter</span>(<span class="hljs-params">OldLogger oldLogger</span>)</span><br>    &#123;<br>        _oldLogger = oldLogger;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteLog</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 在这里进行适配</span><br>        <span class="hljs-comment">// 也可以进行其他转换，比如在旧方法前后加些逻辑</span><br>        _oldLogger.LogMessage(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="测试代码-5"><a href="#测试代码-5" class="headerlink" title="测试代码"></a>测试代码</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 创建旧的日志对象</span><br>        OldLogger oldLogger = <span class="hljs-keyword">new</span> OldLogger();<br><br>        <span class="hljs-comment">// 用适配器将其包装为新接口</span><br>        INewLogger logger = <span class="hljs-keyword">new</span> LoggerAdapter(oldLogger);<br><br>        <span class="hljs-comment">// 客户端只关心 INewLogger 接口</span><br>        logger.WriteLog(<span class="hljs-string">&quot;Hello, Adapter Pattern!&quot;</span>);<br><br>        Console.ReadKey();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="常见用途-1"><a href="#常见用途-1" class="headerlink" title="常见用途"></a>常见用途</h5><p><strong>对象适配 vs. 类适配</strong></p><ul><li>上面展示的方式是一种<strong>对象适配</strong>（通过持有被适配者的实例）。</li><li>另外还有“类适配器”，在 C# 里通常借助继承 + 接口实现，但因为 C# 不支持多继承，类适配器用得并不多。对象适配更常见。</li></ul><p><strong>何时使用</strong></p><ul><li>当你想要复用一些已有的类&#x2F;接口，但它们的接口形式与新需求不兼容时。</li><li>又或者你不能修改现有类（可能是第三方库或遗留系统），就用适配器给它<strong>包一层</strong>，让它变成可用的接口形式。</li></ul><h5 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h5><p><strong>优点</strong></p><ul><li><strong>复用已有功能</strong>：不用重写或复制粘贴代码。</li><li><strong>对原对象无侵入</strong>：不必修改 <code>Adaptee</code> 源码，只需在适配器中做转换。</li><li><strong>耦合度低</strong>：新系统的模块依然只依赖 <code>Target</code> 接口，而非硬编码到 <code>Adaptee</code>。</li></ul><p><strong>缺点</strong></p><ul><li>增加一层间接调用（性能影响一般不大，但存在）。</li><li>如果接口差异较大，适配器需要编写的<strong>转换逻辑</strong>可能更复杂。</li></ul><h4 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//它通过在不改变原有类结构的情况下，动态的给对象添加职责</span><br><br></code></pre></td></tr></table></figure><h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Powershell脚本</title>
    <link href="/2024/10/27/Powershell%E8%84%9A%E6%9C%AC/"/>
    <url>/2024/10/27/Powershell%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h2 id="生成-更新Hexo博客并上传github"><a href="#生成-更新Hexo博客并上传github" class="headerlink" title="生成&#x2F;更新Hexo博客并上传github"></a>生成&#x2F;更新Hexo博客并上传github</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$currentPath</span> = (<span class="hljs-built_in">Get-Location</span>).Path<br><span class="hljs-variable">$oneDrivePath</span> = (<span class="hljs-built_in">Get-ItemProperty</span> <span class="hljs-literal">-Path</span> <span class="hljs-string">&quot;HKCU:\SOFTWARE\Microsoft\OneDrive&quot;</span> <span class="hljs-literal">-Name</span> <span class="hljs-string">&quot;UserFolder&quot;</span>).UserFolder<br><span class="hljs-variable">$hexoPath</span> = <span class="hljs-variable">$oneDrivePath</span>+<span class="hljs-string">&quot;\hexo&quot;</span><br><span class="hljs-built_in">Set-Location</span> <span class="hljs-variable">$hexoPath</span><br>hexo g <span class="hljs-literal">--d</span><br><span class="hljs-built_in">Set-Location</span> <span class="hljs-variable">$currentPath</span><br></code></pre></td></tr></table></figure><h2 id="禁止某些服务并将其设置为无法自启动"><a href="#禁止某些服务并将其设置为无法自启动" class="headerlink" title="禁止某些服务并将其设置为无法自启动"></a>禁止某些服务并将其设置为无法自启动</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$services</span> = <span class="hljs-selector-tag">@</span>(<span class="hljs-string">&quot;WpcMonSvc&quot;</span>, <span class="hljs-string">&quot;RetailDemo&quot;</span>)<br><br><span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$service</span> <span class="hljs-keyword">in</span> <span class="hljs-variable">$services</span>) &#123;<br>    <span class="hljs-comment"># 停止服务</span><br>    <span class="hljs-built_in">Get-Service</span> <span class="hljs-literal">-Name</span> <span class="hljs-variable">$service</span> | <span class="hljs-built_in">Stop-Service</span> <span class="hljs-literal">-Force</span><br>    <br>    <span class="hljs-comment"># 设置服务的启动类型为禁用</span><br>    <span class="hljs-built_in">Set-Service</span> <span class="hljs-literal">-Name</span> <span class="hljs-variable">$service</span> <span class="hljs-literal">-StartupType</span> Disabled<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="批量安装软件"><a href="#批量安装软件" class="headerlink" title="批量安装软件"></a>批量安装软件</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">winget install Git.Git Microsoft.VisualStudioCode Golang.Go LLVM.LLVM DEVCOM.Lua Rustlang.Rust.GNU Microsoft.DotNet.SDK.<span class="hljs-number">9</span> Microsoft.VisualStudio.<span class="hljs-number">2022</span>.Community Valve.Steam TortoiseGit.TortoiseGit appmakes.Typora RoslynPad.RoslynPad Python.Python.<span class="hljs-number">3.13</span> <span class="hljs-number">7</span>zip.<span class="hljs-number">7</span>zip Insecure.Nmap Daum.PotPlayer OpenJS.NodeJS dbeaver.dbeaver Baidu.BaiduNetdisk PostgreSQL.pgAdmin<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PowerShell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编程工具官网</title>
    <link href="/2024/10/27/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7%E5%AE%98%E7%BD%91/"/>
    <url>/2024/10/27/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7%E5%AE%98%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<h4 id="Visual-Studio"><a href="#Visual-Studio" class="headerlink" title="Visual Studio"></a><a href="https://visualstudio.microsoft.com/zh-hans/downloads/">Visual Studio</a></h4><ul><li>C#插件<ul><li><a href="https://marketplace.visualstudio.com/items?itemName=SteveCadwallader.CodeMaidVS2022">CodeMaid VS2022</a></li></ul></li></ul><h4 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a><a href="https://code.visualstudio.com/docs/?dv=win64user">Visual Studio Code</a></h4><h4 id="Git"><a href="#Git" class="headerlink" title="Git"></a><a href="https://git-scm.com/download/win">Git</a></h4><h4 id="TightVNC"><a href="#TightVNC" class="headerlink" title="TightVNC"></a><a href="https://www.tightvnc.com/download.php">TightVNC</a></h4><h4 id="DBeaver"><a href="#DBeaver" class="headerlink" title="DBeaver"></a><a href="https://dbeaver.io/download/">DBeaver</a></h4><h4 id="WireShark"><a href="#WireShark" class="headerlink" title="WireShark"></a><a href="https://www.wireshark.org/">WireShark</a></h4><h4 id="Reqable"><a href="#Reqable" class="headerlink" title="Reqable"></a><a href="https://reqable.com/zh-CN/pricing">Reqable</a></h4>]]></content>
    
    
    <categories>
      
      <category>分享</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理</title>
    <link href="/2024/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    <url>/2024/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="为我从bit开始讲讲计算机中存储数据的这些单位大小以及常见的数据类型的大小"><a href="#为我从bit开始讲讲计算机中存储数据的这些单位大小以及常见的数据类型的大小" class="headerlink" title="为我从bit开始讲讲计算机中存储数据的这些单位大小以及常见的数据类型的大小"></a>为我从bit开始讲讲计算机中存储数据的这些单位大小以及常见的数据类型的大小</h2><h3 id="1-从位（bit）开始"><a href="#1-从位（bit）开始" class="headerlink" title="1. 从位（bit）开始"></a>1. <strong>从位（bit）开始</strong></h3><p>在计算机中，所有数据最终都被存储为二进制形式，即由 <strong>0</strong> 和 <strong>1</strong> 组成。这些最小的信息单元称为<strong>位（bit）</strong>。单个位只能表示两种状态，0 或 1。</p><ul><li><strong>1 bit</strong> &#x3D; 二进制中的一个 0 或 1</li></ul><h3 id="2-字节（Byte）"><a href="#2-字节（Byte）" class="headerlink" title="2. 字节（Byte）"></a>2. <strong>字节（Byte）</strong></h3><p><strong>字节（Byte）</strong> 是计算机存储数据的基本单位。1 字节等于 8 位。这意味着 1 字节可以表示 (2^8) 种不同的状态，即 256 种可能的值。</p><ul><li><strong>1 Byte (B)</strong> &#x3D; 8 bits</li><li>一个字节可以存储 0 到 255 之间的整数值。</li></ul><h3 id="3-千字节（KB）、兆字节（MB）、吉字节（GB）"><a href="#3-千字节（KB）、兆字节（MB）、吉字节（GB）" class="headerlink" title="3. 千字节（KB）、兆字节（MB）、吉字节（GB）"></a>3. <strong>千字节（KB）、兆字节（MB）、吉字节（GB）</strong></h3><p>当数据量变得更大时，我们使用更大的单位来度量数据存储量。</p><ul><li><strong>1 千字节（KB）</strong> &#x3D; 1024 字节 &#x3D; (2^{10}) 字节</li><li><strong>1 兆字节（MB）</strong> &#x3D; 1024 KB &#x3D; (2^{20}) 字节</li><li><strong>1 吉字节（GB）</strong> &#x3D; 1024 MB &#x3D; (2^{30}) 字节</li><li><strong>1 太字节（TB）</strong> &#x3D; 1024 GB &#x3D; (2^{40}) 字节</li></ul><p>注意：在一些场景下，尤其是硬盘厂商的度量方式中，1 KB 有时被认为是 1000 字节，而非 1024 字节，但在技术领域，1024 字节的定义更为常用。</p><h3 id="4-常见数据类型的大小"><a href="#4-常见数据类型的大小" class="headerlink" title="4. 常见数据类型的大小"></a>4. <strong>常见数据类型的大小</strong></h3><p>计算机中的数据类型定义了一个变量所需的内存大小。不同的数据类型占用的内存量不同，具体取决于编程语言、操作系统以及处理器架构。以下是以 C# 语言（以及大部分现代编程语言）为例，常见基本数据类型的大小：</p><h4 id="整数类型："><a href="#整数类型：" class="headerlink" title="整数类型："></a><strong>整数类型：</strong></h4><ol><li><p>**<code>bool</code>**：表示布尔值（<code>true</code> 或 <code>false</code>）</p><ul><li><strong>大小</strong>：1 位（bit）或 1 字节（具体实现可能不同）</li></ul></li><li><p>**<code>byte</code>**：表示 0 到 255 之间的整数</p><ul><li><strong>大小</strong>：1 字节（8 位）</li></ul></li><li><p>**<code>short</code>**：表示 16 位有符号整数，范围是 -32,768 到 32,767</p><ul><li><strong>大小</strong>：2 字节（16 位）</li></ul></li><li><p>**<code>int</code>**：表示 32 位有符号整数，范围是 -2,147,483,648 到 2,147,483,647</p><ul><li><strong>大小</strong>：4 字节（32 位）</li></ul></li><li><p>**<code>long</code>**：表示 64 位有符号整数，范围非常大</p><ul><li><strong>大小</strong>：8 字节（64 位）</li></ul></li><li><p>**<code>char</code>**：表示 Unicode 字符，范围是 0 到 65,535</p><ul><li><strong>大小</strong>：2 字节（16 位）</li></ul></li></ol><h4 id="浮点类型："><a href="#浮点类型：" class="headerlink" title="浮点类型："></a><strong>浮点类型：</strong></h4><ol><li><p>**<code>float</code>**：32 位单精度浮点数，通常有 6-9 位有效数字精度</p><ul><li><strong>大小</strong>：4 字节（32 位）</li></ul></li><li><p>**<code>double</code>**：64 位双精度浮点数，通常有 15-17 位有效数字精度</p><ul><li><strong>大小</strong>：8 字节（64 位）</li></ul></li><li><p>**<code>decimal</code>**：128 位高精度十进制数，通常用于金融计算，支持 28-29 位有效数字</p><ul><li><strong>大小</strong>：16 字节（128 位）</li></ul></li></ol><h4 id="其他数据类型："><a href="#其他数据类型：" class="headerlink" title="其他数据类型："></a><strong>其他数据类型：</strong></h4><ol><li><p>**<code>string</code>**：字符串是一种引用类型，存储的是 Unicode 字符的集合，长度可变。</p><ul><li><strong>大小</strong>：每个字符占用 2 字节（16 位），实际大小取决于字符串的长度。</li></ul></li><li><p>**<code>object</code>**：引用类型的基类，实际大小取决于它引用的对象。</p><ul><li><strong>大小</strong>：取决于引用的对象。</li></ul></li></ol><h3 id="5-数据对齐与内存分配"><a href="#5-数据对齐与内存分配" class="headerlink" title="5. 数据对齐与内存分配"></a>5. <strong>数据对齐与内存分配</strong></h3><p>在实际的计算机中，数据的存储不仅仅受到数据类型本身大小的影响，还可能受到 <strong>数据对齐（Data Alignment）</strong> 的限制。为了提高性能，处理器通常会将数据存储在内存的对齐边界上，这可能会增加变量的实际内存占用。例如，一个<code>long</code>类型的变量通常会被对齐到8字节的边界上，即使它需要的只是8字节内存。</p><h3 id="6-总结："><a href="#6-总结：" class="headerlink" title="6. 总结："></a>6. <strong>总结：</strong></h3><ul><li><strong>位（bit）</strong> 是计算机中的最小信息单位，8 位等于 1 字节（byte）。</li><li><strong>字节（byte）</strong> 是基本的存储单位，常见的数据类型如整数和浮点数都有对应的字节数。</li><li>数据存储的大小依赖于数据类型，整型、浮点型、字符串等不同数据类型会占用不同的字节数。</li><li>常见的数据类型大小可以从 1 字节的布尔值到 16 字节的<code>decimal</code>不等。</li></ul><h2 id="我还见过另一种整数类型的写法，即两个byte称为word而不是short，四个byte称为double-word而不是int，这种是什么情况"><a href="#我还见过另一种整数类型的写法，即两个byte称为word而不是short，四个byte称为double-word而不是int，这种是什么情况" class="headerlink" title="我还见过另一种整数类型的写法，即两个byte称为word而不是short，四个byte称为double word而不是int，这种是什么情况?"></a>我还见过另一种整数类型的写法，即两个byte称为word而不是short，四个byte称为double word而不是int，这种是什么情况?</h2><p>你提到的这种写法来自<strong>计算机体系结构</strong>中的术语，主要与处理器的架构和数据表示相关。在某些场景下，数据的单位不仅仅使用我们常见的“short”、“int”等编程语言中的数据类型命名，还会使用处理器术语，比如 <strong>word</strong>、<strong>double word</strong>、<strong>quad word</strong>。这些术语广泛应用于低层次的硬件设计和汇编语言编程中。</p><p>让我们看看这些术语的定义和它们与现代编程语言的联系：</p><h3 id="1-字（Word）"><a href="#1-字（Word）" class="headerlink" title="1. 字（Word）"></a>1. <strong>字（Word）</strong></h3><p><strong>Word</strong> 是计算机架构中的基本数据单位。它的具体大小取决于处理器的位宽。例如：</p><ul><li><strong>16-bit 处理器</strong>：1 word 通常是 <strong>16 位</strong>（2 个字节）。</li><li><strong>32-bit 处理器</strong>：1 word 通常是 <strong>32 位</strong>（4 个字节）。</li><li><strong>64-bit 处理器</strong>：1 word 通常是 <strong>64 位</strong>（8 个字节）。</li></ul><p>因此，”word” 是与处理器架构相关的术语，而不是固定为某个特定的字节数。随着处理器的位宽增加，word 的大小也可能增加。</p><h3 id="2-双字（Double-Word）"><a href="#2-双字（Double-Word）" class="headerlink" title="2. 双字（Double Word）"></a>2. <strong>双字（Double Word）</strong></h3><p><strong>Double word</strong>（双字，简称 <code>dword</code>）表示 <strong>两个 word</strong>。同样，双字的具体大小取决于系统的 word 大小：</p><ul><li>在 <strong>16-bit 处理器</strong>中，1 个 <code>double word</code> 是 <strong>32 位</strong>（4 个字节）。</li><li>在 <strong>32-bit 处理器</strong>中，1 个 <code>double word</code> 是 <strong>64 位</strong>（8 个字节）。</li></ul><h3 id="3-四字（Quad-Word）"><a href="#3-四字（Quad-Word）" class="headerlink" title="3. 四字（Quad Word）"></a>3. <strong>四字（Quad Word）</strong></h3><p><strong>Quad word</strong>（四字，简称 <code>qword</code>）表示 <strong>四个 word</strong>：</p><ul><li>在 <strong>16-bit 处理器</strong>中，1 个 <code>quad word</code> 是 <strong>64 位</strong>（8 个字节）。</li><li>在 <strong>32-bit 处理器</strong>中，1 个 <code>quad word</code> 是 <strong>128 位</strong>（16 个字节）。</li></ul><h3 id="4-与编程语言数据类型的对应关系"><a href="#4-与编程语言数据类型的对应关系" class="headerlink" title="4. 与编程语言数据类型的对应关系"></a>4. <strong>与编程语言数据类型的对应关系</strong></h3><p>在现代编程语言（如 C#、C、C++）中，这些术语虽然不直接使用，但它们有一定的对应关系：</p><ul><li><strong>Word（2 个字节）</strong>：在 16 位系统中，一个<code>word</code>等价于 C# 中的 <code>short</code>（16 位），即 2 字节的有符号整数。</li><li><strong>Double word（4 个字节）</strong>：在 32 位系统中，<code>dword</code> 通常与 C# 中的 <code>int</code>（32 位，4 字节）等价。</li><li><strong>Quad word（8 个字节）</strong>：在 64 位系统中，<code>qword</code> 通常与 C# 中的 <code>long</code>（64 位，8 字节）等价。</li></ul><h3 id="5-历史背景与现代使用"><a href="#5-历史背景与现代使用" class="headerlink" title="5. 历史背景与现代使用"></a>5. <strong>历史背景与现代使用</strong></h3><p>这些术语最初来源于早期的处理器架构，特别是在 8086 和 x86 家族的处理器设计中。随着计算机体系结构的发展，这些术语仍然在汇编语言、操作系统内核开发以及低层次的硬件编程中被使用。</p><p>例如：</p><ul><li>在 <strong>x86 汇编</strong> 中，<code>mov ax, [bx]</code> 是一个 16 位操作，处理器会移动一个 word（16 位）数据。</li><li>在 <strong>x64 汇编</strong> 中，<code>mov rax, [rbx]</code> 是一个 64 位操作，处理器会移动一个 quad word（64 位）数据。</li></ul><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. <strong>总结</strong></h3><ul><li><strong>Word</strong>、<strong>Double Word</strong> 和 <strong>Quad Word</strong> 是与处理器架构相关的术语，它们的大小取决于处理器的位宽。<ul><li>16-bit 处理器：Word &#x3D; 16 位（2 字节），Double Word &#x3D; 32 位（4 字节）</li><li>32-bit 处理器：Word &#x3D; 32 位（4 字节），Double Word &#x3D; 64 位（8 字节）</li><li>64-bit 处理器：Word &#x3D; 64 位（8 字节），Double Word &#x3D; 128 位（16 字节）</li></ul></li><li>在现代编程语言中，虽然这些术语不常用，但它们有对应的数据类型，比如 <code>short</code>、<code>int</code>、<code>long</code>。</li></ul><p>这些术语仍然在低层次编程、硬件架构和汇编语言中被广泛使用，帮助理解不同处理器位宽下的内存和数据操作方式。</p><h2 id="什么是低层次编程和硬件设计？PLC是否是其中一种"><a href="#什么是低层次编程和硬件设计？PLC是否是其中一种" class="headerlink" title="什么是低层次编程和硬件设计？PLC是否是其中一种?"></a>什么是低层次编程和硬件设计？PLC是否是其中一种?</h2><p><strong>低层次编程</strong>和<strong>硬件设计</strong>是计算机科学中的两个重要领域，它们比现代高级编程语言更接近计算机的硬件和物理实现。我们来详细看看这两个概念，以及它们与 <strong>PLC</strong>（可编程逻辑控制器）的关系。</p><h3 id="1-低层次编程"><a href="#1-低层次编程" class="headerlink" title="1. 低层次编程"></a>1. <strong>低层次编程</strong></h3><p><strong>低层次编程</strong>（Low-level programming）是指直接与硬件交互的编程，它通常依赖于对底层硬件的深入了解。低层次编程的特点是需要操控寄存器、内存地址和数据总线，编写代码的自由度和灵活性更大，但同时编程难度也更高。</p><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul><li><strong>与硬件紧密相关</strong>：程序员必须了解处理器的架构、指令集、寄存器等硬件细节。</li><li><strong>效率高</strong>：因为直接操作硬件，低层次代码可以获得更高的执行效率。</li><li><strong>缺乏抽象</strong>：低层次编程中几乎没有抽象封装，这使得代码更复杂。</li><li><strong>常见语言</strong>：汇编语言（Assembly）、C 语言（有时称为中低层次语言）。</li></ul><h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><ul><li><strong>汇编语言（Assembly）</strong>：这是直接与处理器的机器码对应的编程语言，程序员可以使用它来控制处理器的每一个动作。例如，读取寄存器、执行加法操作、存储数据等。</li><li><strong>嵌入式编程</strong>：在嵌入式系统中，C 语言和汇编语言常被用来编写软件，与硬件（如传感器、控制器）直接通信。</li></ul><h4 id="用途："><a href="#用途：" class="headerlink" title="用途："></a>用途：</h4><ul><li>操作系统开发</li><li>驱动程序编写</li><li>嵌入式系统开发</li><li>硬件控制</li></ul><h3 id="2-硬件设计"><a href="#2-硬件设计" class="headerlink" title="2. 硬件设计"></a>2. <strong>硬件设计</strong></h3><p><strong>硬件设计</strong>（Hardware Design）是指设计和实现计算机硬件（如处理器、存储器、总线等）以及各种电子设备的过程。硬件设计不仅包括电路设计，还涉及到硬件的逻辑控制和优化。</p><h4 id="硬件设计的步骤："><a href="#硬件设计的步骤：" class="headerlink" title="硬件设计的步骤："></a>硬件设计的步骤：</h4><ol><li><strong>逻辑设计</strong>：使用硬件描述语言（如 VHDL 或 Verilog）定义硬件的行为逻辑。这些语言用于设计和模拟电子电路。</li><li><strong>电路设计</strong>：设计物理电路来实现逻辑设计，涉及晶体管、门电路等。</li><li><strong>硬件优化</strong>：为了提高性能，设计人员必须优化硬件的功耗、速度、面积等。</li></ol><h4 id="常见的硬件设计语言："><a href="#常见的硬件设计语言：" class="headerlink" title="常见的硬件设计语言："></a>常见的硬件设计语言：</h4><ul><li><strong>Verilog、VHDL</strong>：用于描述数字系统的硬件描述语言，通常用于设计集成电路（如 FPGA 和 ASIC）。</li><li><strong>SystemC</strong>：用于硬件&#x2F;软件协同设计的系统级语言。</li></ul><h4 id="用途：-1"><a href="#用途：-1" class="headerlink" title="用途："></a>用途：</h4><ul><li>处理器设计</li><li>芯片设计（如 FPGA、ASIC）</li><li>电子系统设计</li></ul><h3 id="3-PLC（可编程逻辑控制器）"><a href="#3-PLC（可编程逻辑控制器）" class="headerlink" title="3. PLC（可编程逻辑控制器）"></a>3. <strong>PLC（可编程逻辑控制器）</strong></h3><p><strong>PLC（Programmable Logic Controller）</strong> 是一种专门为工业自动化设计的数字计算机，主要用于控制机械设备和生产过程。PLC 通常用于自动化系统中，是一种典型的嵌入式系统，但它不完全属于硬件设计的范畴，而是集成了硬件和低层次编程的特点。</p><h4 id="PLC-的特点："><a href="#PLC-的特点：" class="headerlink" title="PLC 的特点："></a>PLC 的特点：</h4><ul><li><strong>硬件部分</strong>：PLC 本身是一个嵌入式控制器，拥有处理器、内存、输入输出模块等硬件组件。</li><li><strong>编程语言</strong>：PLC 编程使用的是专门的编程语言，常见的有 <strong>梯形图（Ladder Diagram, LD）</strong>、<strong>顺序功能图（Sequential Function Chart, SFC）</strong>、<strong>功能块图（Function Block Diagram, FBD）</strong>、<strong>结构化文本（Structured Text, ST）</strong> 等。它们是高层次抽象的，但它们背后可能有更底层的控制逻辑实现。</li><li><strong>实时控制</strong>：PLC 的设计专注于实时性和可靠性，它们可以在严格的时间要求下执行任务。</li><li><strong>工业用途</strong>：PLC 被广泛应用于制造业、石化、自动化设备控制等领域，监控传感器、执行器和机械操作。</li></ul><p>虽然 PLC 使用的编程语言比汇编语言抽象得多，但其实际运行的控制程序与硬件有非常紧密的联系，因此它们可以被看作是一种特殊的低层次编程。它的程序编写更偏向控制流程逻辑，而不是直接的硬件编程。</p><h3 id="4-PLC-与低层次编程和硬件设计的关系"><a href="#4-PLC-与低层次编程和硬件设计的关系" class="headerlink" title="4. PLC 与低层次编程和硬件设计的关系"></a>4. <strong>PLC 与低层次编程和硬件设计的关系</strong></h3><ul><li><strong>低层次编程</strong>：虽然 PLC 编程语言（如梯形图）比汇编语言更高级，但它们的目的是直接控制硬件操作（如启动电机、读取传感器），所以可以认为 PLC 编程是一种与硬件非常紧密结合的低层次编程。</li><li><strong>硬件设计</strong>：PLC 硬件部分是由嵌入式系统设计的，包括处理器、存储器、I&#x2F;O 接口等。PLC 本身的设计可以归类为嵌入式硬件设计，但使用 PLC 的用户通常不会涉及直接的硬件设计，而是使用 PLC 提供的编程接口进行自动化控制。</li></ul><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. <strong>总结</strong></h3><ul><li><strong>低层次编程</strong> 是指直接与硬件交互、控制硬件的编程方式，典型语言是汇编和 C。</li><li><strong>硬件设计</strong> 涉及数字电路、处理器等电子设备的设计，通常使用 VHDL、Verilog 等语言。</li><li><strong>PLC</strong> 是一种用于工业自动化的嵌入式系统，集成了硬件设计和控制逻辑编程，尽管 PLC 编程语言比低层次编程更高级，但其控制方式与硬件密切相关。</li></ul><p>因此，PLC 是一种专注于工业控制的嵌入式系统，它处在低层次编程和硬件设计之间。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>html基础</title>
    <link href="/2024/10/21/%E5%9C%A8html%E4%B8%AD%E4%BD%BF%E7%94%A8Latex%E5%85%AC%E5%BC%8F/"/>
    <url>/2024/10/21/%E5%9C%A8html%E4%B8%AD%E4%BD%BF%E7%94%A8Latex%E5%85%AC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h4 id="引入-MathJax"><a href="#引入-MathJax" class="headerlink" title="引入 MathJax:"></a>引入 MathJax:</h4><p>在 HTML 文件的 <head> 部分引入 MathJax 的 CDN：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://polyfill.io/v3/polyfill.min.js?features=es6&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;MathJax-script&quot;</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="插入-LaTeX-公式"><a href="#插入-LaTeX-公式" class="headerlink" title="插入 LaTeX 公式:"></a>插入 LaTeX 公式:</h4><p> 使用 <code>\( ... \)</code> 或 <code>\[ ... \]</code> 来包裹 LaTeX 公式。<code>\( ... \)</code> 用于行内公式，<code>\[ ... \]</code> 用于块级公式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>使用 MathJax 显示 LaTeX 公式<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一个行内公式： \( E = mc^2 \)<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一个块级公式：<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>\[ \int_0^\infty e^&#123;-x^2&#125; \, dx = \frac&#123;\sqrt&#123;\pi&#125;&#125;&#123;2&#125; \]<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#相关问题</title>
    <link href="/2024/10/17/C-Sharp%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <url>/2024/10/17/C-Sharp%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="C-中-”字符串”是什么意思"><a href="#C-中-”字符串”是什么意思" class="headerlink" title="C#中$@”字符串”是什么意思"></a>C#中$@”字符串”是什么意思</h2><ul><li>$表示{}内的内容会被替换为变量的值</li><li>@表示将后面字符串内的转义字符当作普通字符对待</li></ul><h2 id="C-中-STATHread-是什么意思？"><a href="#C-中-STATHread-是什么意思？" class="headerlink" title="C#中[STATHread]是什么意思？"></a>C#中[STATHread]是什么意思？</h2><ul><li>[STAThread]是一个特性，用于指示应用程序的默认线程是单线程单元(STA),多用在程序的入口方法上</li><li>STA即Single      Thread Apartment，是一种线程模型，在这个模型中，每个线程都有自己的单独的消息队列，用于处理Windows消息。<strong>这种模型对于需要处理用户界面的线程非常有用</strong>，因为用户界面通常需要在单个线程上进行操作以避免并发问题</li><li>[STATHread]特性在使用COM Interop(托管代码与非托管代码之间的协同过程)的应用程序中非常重要。如果应用程序实际调用了COM组件，则仅为COM interop初始化该线程，如果没有使用COM interop,则不初始化该线程。</li></ul><h2 id="region…-endregion是什么意思？"><a href="#region…-endregion是什么意思？" class="headerlink" title="#region…#endregion是什么意思？"></a><code>#region</code>…<code>#endregion</code>是什么意思？</h2><ul><li>在C#中，<code>#region</code>和<code>#endregion</code>是预处理指令，用于在VisualStudio中标记一块可以折叠和展开的代码区域，可以在<code>#region</code>后添加任意描述文字，以便记住此区域的用途，<strong>不会影响代码执行，只是提升可读性</strong></li></ul><h2 id="using关键字有什么用"><a href="#using关键字有什么用" class="headerlink" title="using关键字有什么用"></a><code>using</code>关键字有什么用</h2><ul><li><strong>导入命名空间</strong>，这样就可以在代码中直接使用该命名空间中的类型，如<code>using System</code>后不用写<code>System.Console.WriteLine()</code></li></ul><h2 id="var是什么意思"><a href="#var是什么意思" class="headerlink" title="var是什么意思"></a>var是什么意思</h2><ul><li><p><code>var</code>是一个关键字，用于声明变量，<code>var</code>关键字告诉编译器，希望它根据变量的初始化表达式来推断变量类型。这被称为类型推断。</p></li><li><p>如<code>var total =0;</code>编译器会推断出<code>total</code>是一个int类型的变量，因为它被初始化为一个整数。</p></li><li><p><code>var</code>声明的变量必须在声明的时候进行初始化</p></li><li><p><code>var</code>只能用于局部变量的声明，不能在类的级别使用<code>var</code>来声明字段。</p></li><li><p>怎么在C#方法的头尾添加计时</p><ul><li><pre><code class="c#">using System.Diagnostics;public void YourMethod()&#123;    //创建Stopwatch实例    Stopwatch stopwatch = new Stopwatch();    //开始计时    stopwatch.Start();    //代码本体    //停止计时    stopwatch.Stop();    //获取经过的时间    TimeSpan elapsed = stopwatch.Elapsed;    //打印经过时间    Console.WriteLine($&quot;程序共运行了&#123;elapsed.TotalMilliseconds&#125;毫秒&quot;);&#125;<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><span class="hljs-meta">## C#中的=&gt;是什么意思？</span><br><br>  - =&gt;是c<span class="hljs-meta">#中的lambda运算符，用于定义匿名函数或表达式主体定义方法</span><br><br><span class="hljs-meta">## C#中属性(Property)和变量（Variable）的区别是什么？</span><br><br>  - 属性和变量都是用来存储数据的，但它们的用途和功能有所不同<br><br>  - **变量**是程序中最基本的数据存储单位。它有一个数据类型和一个值，可以直接读取或修改变量的值。<br><br>  - **属性**则是类、结构或接口中的成员，它提供了一种灵活的机制来读取、写入或计算私有字段的值<br><br><span class="hljs-meta">## 重写ToString()有什么作用？</span><br><br>  - ToString是所有对象都具有的方法，默认行为是返回对象的类型名<br><br>- 如果在同一类中，一个方法重写了比如，ToString(),那么同一类的方法再使用ToString的时候是会使用原有方法还是重写后的方法？<br><br>  - 如果在一个类中重写了ToString()方法，那么这个类的所有实例在调用ToString()方法时，都会使用我重写版本的方法而不是原有方法。在面向对象编程中，当一个方法被重写时，子类的方法会覆盖父类的方法。<br><br>- 为什么抽象类没有构造函数也能传入参数<br><br>  - 实际上，抽象类是可以有构造函数的。虽然不能直接实例化一个抽象类，但是可以在抽象类的构造函数中初始化一些成员，然后在派生类中通过`<span class="hljs-keyword">base</span>`关键字来调用这个构造函数。<br><br>    ```C<span class="hljs-meta">#</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AbstractClass</span><br>    &#123;<br>        <span class="hljs-keyword">protected</span> <span class="hljs-built_in">string</span> name;<br>    <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AbstractClass</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">this</span>.name = name;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DerivedClass</span> : <span class="hljs-title">AbstractClass</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DerivedClass</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">name</span>)</span><br>        &#123;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p><code>this</code>关键字是干什么用的</p><ul><li><p><strong>引用实例成员</strong>：虽然一般情况下不用this也能访问实例成员，但是它可以结局命名冲突，比如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> myField;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyMethod</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> myField</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.myField = myField;  <span class="hljs-comment">// 使用 this 关键字区分实例字段和参数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种情况下虽然也可以直接写，但是这么写更好看</p></li><li><p><strong>调用其他构造函数</strong>：在一个构造函数中，可以使用<code>this</code>关键字来调用同一个类中的其他构造函数，例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>() : <span class="hljs-title">this</span>(<span class="hljs-params"><span class="hljs-number">10</span></span>)  <span class="hljs-comment">// 使用 this 关键字调用另一个构造函数</span></span><br>    &#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> myField</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.myField = myField;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>[JsonIgnore]</code>是啥？</p><ul><li>在C#中，<code>[JsonIgnore]</code>是一个【特性】，它来自<code>Newtonsoft.Json</code>库。当在一个类的属性或字段前使用<code>[JsonIgnore]</code>特性时，这个属性或字段将不会被序列化到JSON字符串中，也不会被从JSON字符串中反序列化。</li></ul></li><li><p>为什么一个类可以被用来定义属性，如<code>private Node? next;</code>和<code>public Node? Next&#123;get;set;&#125;</code></p><p>- </p></li><li><p>为什么一个类可以作为泛型类的类型参数来创建一个新的类？</p><ul><li><strong>性能优化</strong>：因为泛型是值类型而不是引用类型，因此它可以避免装箱和拆箱操作</li><li>具体应用方面，泛型广泛应用于集合类(如List<T>，Dictionary&lt;TKey,TValue&gt;)，以及任务并行库(Task<T>)，事件处理(EventHandler<TEventArgs>)等许多场景中。</li></ul></li><li><p>什么是嵌套类？</p></li><li><p>为什么属性可以被委托定义？委托会对委托封装的方法产生什么影响？委托接受的两个参数和委托定义的属性有什么关系？</p><ul><li>委托可以封装一个方法的签名，可以视作对方法的引用，因此，定义一个委托类型的属性，这个属性可以存储一个方法的引用，然后可以通过这个属性来调用这个方法。</li><li><strong>委托对其封装的方法没有直接的影响</strong>。可以将方法作为参数传递给其他方法，或者将多个方法组合在一起，此外，使用位图哦可以实现<strong>事件</strong>和<strong>回调函数</strong>。</li><li><strong>委托的参数是指通过委托调用方法时传递的参数</strong>。</li></ul></li><li><p><code>internal static Action&lt;string, object&gt; Write &#123; get; set; &#125;</code>是什么意思</p><ul><li><p><code>internal</code>访问修饰符，只能在同一程序集中被访问</p></li><li><p><code>static</code>修饰符，<strong>表示这个属性属于类本身，而不是类的实例</strong>。可以通过类名来访问这个属性而不需要创建类的实例。</p></li><li><p><code>Action&lt;string ,object&gt;</code>这是属性的类型。<code>Action</code>代表无返回值的方法的委托。这个<code>Action</code>委托接受两个参数，一个是<code>string</code>类型，一个是<code>object</code>类型。</p></li><li><p><code>Write</code>属性名称</p></li><li><p><code>&#123;get;set;&#125;</code>属性的访问器。</p></li><li><p><code>internal static Action&lt;string, object&gt; Write &#123; get; set; &#125;</code>定义了一个名为<code>Write</code>的属性，它的类型是<code>Action&lt;string,object&gt;</code>可以在同一个程序集中被访问，且属于类本身。</p></li><li><p>这个<code>Write</code>属性可以存储一个方法的引用，这个方法必须接受一个<code>string</code>参数和一个<code>object</code>参数，并且没有返回值。可以通过<code>Write</code>属性来调用这个方法。</p></li><li><p>什么是语法糖？</p><ul><li>语法糖是一种术语，指的是设计来使编程更容易或更可读的语言特性。这些特性并没有增加语言的功能，但是可以使代码更简洁，更易于阅读和编写。</li><li>如，在C#中，属性(properties)就是一种语法糖。可以直接使用<code>obj.Property</code>来获取或设置值，而不需要调用<code>obj.GetProperty</code>或<code>obj.SetProperty(value)</code>。这使得代码更简洁，更像自然语言。</li><li><strong>虽然语法糖可以提高代码的可读性和编写效率，但是过度的使用可能会使代码变得难以理解和维护</strong>。</li></ul></li><li><p><code>Name[3..]</code>是什么意思</p><ul><li>范围表达式，从Name字符串中提取一个子字符串，<code>3..</code>表示从3开始到字符串末尾。</li></ul></li><li><p>C#的垃圾回收机制是怎样的？</p></li><li><p>什么是并发字典（ConcurrentDictionary）？</p><ul><li>并发字典是.NET Framework中的一个类,System.Collections.Concurrent命名空间的一部分。</li><li>并发字典是线程安全的字典，这意味着多个线程可以同时从字典中添加、删除和更新键值对，而不会引发任何线程冲突或数据不一致的问题。</li><li>并发字典的主要优点是它允许多个线程同时读取和写入数据，而不需要使用锁或其他同步机制。这使得并发字典在需要高并发访问的多线程应用程序中非常有用。</li></ul></li><li><p>在C#中，类型和类有区别吗？</p><ul><li>C#的类型分为值类型（int，bool）和引用类型（class interface delegate），用GetType()处理一个引用类型的实例时，会直接返回这个实例的类或接口。</li></ul></li><li><p>如何用C#将一段哈希值解为明码？</p></li></ul></li><li><p>什么是对象初始化器？</p><ul><li><p>C#中的一个特性，允许在创建对象的同时初始化对象的属性或字段。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#">ClassName objectName = <span class="hljs-keyword">new</span> ClassName &#123;Property1 = value1,Property2 = value2&#125;;<br>Person person = <span class="hljs-keyword">new</span> Person &#123;Name = <span class="hljs-string">&quot;Alice&quot;</span>,Age =<span class="hljs-number">30</span>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>StringComparison.OrdinalIgnoreCase是啥？</p><ul><li>StringComparison.OrdinalIgnoreCase是C#枚举的一个成员，在进行字符串比较操作时顾略大小写并使用不分区域性的排序规则。</li></ul></li><li><p>类类型的属性和实例有啥区别？</p><ul><li><strong>主要区别在于访问方式和生命周期</strong></li><li><strong>类类型的属性</strong>:类属性可以有默认值，也可以在构造函数中初始化。它们的声明周期与类实例的声明周期相同。</li><li><strong>实例</strong>:实例是类的具体化。实例的声明舟曲从创建它的那一刻开始，直到没有任何引用指向它并被垃圾收集器回收为止。</li></ul></li><li><p>字典为什么不支持从值访问键？</p><ul><li>字典是一种基于键的数据结构，主要目的是提供快速的键到值的映射。</li></ul></li><li><p>什么是锁语句？</p><ul><li>用于确保在同一时间只有一个线程可以执行被锁定的代码块。<code>SyncRoot</code>是一个对象，用作锁的标识。</li></ul></li><li><p>Devices.TryGetValue(position,out var _)是啥意思？（Devices是个字典）</p><ul><li>尝试获取与指定的键position关联的值，如果找到了键，那么它会返回true，并将关联值赋给out参数，<code>_</code>是一个丢弃符，表示不关心TryGetValue方法返回的值。</li></ul></li><li><p>C#抽象类，接口和普通类各自有什么使用环境？</p></li><li></li><li><p>Task.Delay()和Task.Wait()和Task.Sleep()的区别是什么？</p><ul><li><strong>Task.Delay()</strong>:一个<strong>异步</strong>的延迟方法，返回一个任务，在指定的时间间隔后该任务会完成。这个方法是<strong>非阻塞</strong>的。</li><li><strong>Task.Wait()<strong>：一个</strong>同步</strong>的方法，它会<strong>阻塞</strong>当前的线程，直到任务完成。</li><li><strong>Task.Sleep()<strong>：</strong>阻塞</strong>当前线程，使其在指定时间间隔进入睡眠。</li></ul></li><li><p>C# 中nameof是如何使用的？</p><ul><li>nameof是一个编译器关键字，用于获取变量、类型、方法、属性、事件、索引器和命名空间的名称作为字符串常量。nameof提供了一种方便的方式来引用这些 实体的名称，而不需要硬编码字符串，当实体名称改变时，相关的字符串也会自动更新，减少出错的可能性。</li></ul></li><li><p>ref是什么意思？</p><ul><li><p>一个关键字，用于传递变量的引用。在调用Increment方法时，传递count变量的引用而不是它的值。如：<code>Interlocked.Increment(ref count);</code>会直接修改传递给它的count变量的内存地址中存储的值，而不是修改count变量的一个副本。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span> = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">int</span> othervalue = <span class="hljs-number">20</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Swap</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> a,<span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> b</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> temp = a;<br>    a = b;<br>    b = temp;<br>&#125;<br>swap(<span class="hljs-keyword">ref</span> <span class="hljs-keyword">value</span>,<span class="hljs-keyword">ref</span> othervalue);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>ref和指针的区别？</p><ul><li><strong>ref关键字</strong>：<ul><li>ref是类型安全的，编译器会检查ref参数的类型，确保它与声明的类型一致。</li><li>在调用方法中使用ref</li></ul></li></ul></li><li><p>相较于多线程，异步有什么优缺点？</p></li><li><p>什么是是匿名方法？</p><ul><li><p>匿名方法（Anonymous Method）是一种<strong>不具有名称的函数或方法</strong>。它通常在<strong>需要将函数作为参数传递时使用</strong>，或者在<strong>不需要重复使用该函数的情况下直接定义</strong>。这类方法在许多编程语言中都有实现，主要用于简化代码和提高可读性。</p></li><li><h3 id="使用-delegate-关键字定义匿名方法"><a href="#使用-delegate-关键字定义匿名方法" class="headerlink" title="使用 delegate 关键字定义匿名方法"></a>使用 <code>delegate</code> 关键字定义匿名方法</h3><p>使用 <code>delegate</code> 关键字定义匿名方法是一种较早的方式，它允许你在没有显式定义方法的情况下编写内联代码。这种方法在C# 2.0中引入。</p></li></ul></li><li><p>什么是显式方法定义？什么是内联代码？</p><ul><li><h3 id="显式方法定义"><a href="#显式方法定义" class="headerlink" title="显式方法定义"></a>显式方法定义</h3><p><strong>显式方法定义</strong>指的是通过为方法提供明确的名称、参数和返回类型来定义的方法。这种方法通常在类或模块中定义，具有清晰的作用域和调用方式。显式方法定义有助于代码的组织和重用。</p></li><li><h3 id="内联代码"><a href="#内联代码" class="headerlink" title="内联代码"></a>内联代码</h3><p><strong>内联代码</strong>指的是在代码的执行路径中直接编写的代码，而不是通过调用方法或函数来执行。这种代码通常直接嵌入在使用它的地方，不通过显式方法定义来分离。内联代码通常用于简单的、一次性的任务，但过多的内联代码会导致代码难以维护和理解。</p></li></ul></li><li><p>匿名方法传入委托有什么效果？</p></li><li><p>为啥C#可以用JAVA的库？</p><ul><li>NPOI将Apache POI 库移植到了.NET</li></ul></li><li><p>C#中Nlog是啥？</p><ul><li>一个流行的C#日志记录库，支持多种目标输出(targets)，如文件，数据库，控制台等。</li></ul></li></ul><h2 id="C-取整和取余怎么写"><a href="#C-取整和取余怎么写" class="headerlink" title="C#取整和取余怎么写"></a>C#取整和取余怎么写</h2><h2 id="C-如何取或去掉字符串中某种格式的数据"><a href="#C-如何取或去掉字符串中某种格式的数据" class="headerlink" title="C#如何取或去掉字符串中某种格式的数据"></a>C#如何取或去掉字符串中某种格式的数据</h2><p>正则表达式</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">Match match = Regex.Match(text,<span class="hljs-string">$@&quot;^[a-zA-Z]+&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="C-如何查看项目已经安装的包"><a href="#C-如何查看项目已经安装的包" class="headerlink" title="C#如何查看项目已经安装的包"></a>C#如何查看项目已经安装的包</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">dotnet list package<br></code></pre></td></tr></table></figure><h2 id="C-如何安装包"><a href="#C-如何安装包" class="headerlink" title="C#如何安装包"></a>C#如何安装包</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">dotnet <span class="hljs-keyword">add</span> package xxx<br></code></pre></td></tr></table></figure><h2 id="C-如何添加引用"><a href="#C-如何添加引用" class="headerlink" title="C#如何添加引用"></a>C#如何添加引用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dotnet add reference ../.../.../xxx.dll 或xxx.csproj<br></code></pre></td></tr></table></figure><h2 id="C-匿名类型"><a href="#C-匿名类型" class="headerlink" title="C#匿名类型"></a>C#匿名类型</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">var</span> config = <span class="hljs-keyword">new</span>&#123;<br>    UrlOfGuoKongRiZhao = httpGroup.GetValueByDefault(<span class="hljs-string">&quot;国控站_日照市空气质量&quot;</span>,<span class="hljs-built_in">string</span>.Empty,<span class="hljs-literal">true</span>),<br>UrlOfGuoKongOtherStations = httpGroup.GetValueByDefault(<span class="hljs-string">&quot;国控站_城市具体站点数据&quot;</span>,<span class="hljs-built_in">string</span>.Empty,<span class="hljs-literal">true</span>),<br>UrlOfFieldDevice = httpGroup.GetValueByDefault(<span class="hljs-string">&quot;现场设备&quot;</span>,<span class="hljs-built_in">string</span>.Empty,<span class="hljs-literal">true</span>),<br>UrlOfHeChengFugitiveDust = httpGroup.GetValueByDefault(<span class="hljs-string">&quot;青岛和诚_雨水设备&quot;</span>,<span class="hljs-built_in">string</span>.Empty,<span class="hljs-literal">true</span>),<br>UrlOfHeChengNoise = httpGroup.GetValueByDefault(<span class="hljs-string">&quot;青岛和诚_噪声设备&quot;</span>,<span class="hljs-built_in">string</span>.Empty,<span class="hljs-literal">true</span>)<br>&#125;;<br></code></pre></td></tr></table></figure><p>匿名类型可以不显式声明类型的情况下创建对象并初始化其属性。可以直接声明直接用，而不用声明一个类或者结构体。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#工具</title>
    <link href="/2024/10/13/C-Sharp%E5%B7%A5%E5%85%B7/"/>
    <url>/2024/10/13/C-Sharp%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="dotnet-tool可以直接下到的"><a href="#dotnet-tool可以直接下到的" class="headerlink" title="dotnet tool可以直接下到的"></a>dotnet tool可以直接下到的</h2><h3 id="Csharp-Repl"><a href="#Csharp-Repl" class="headerlink" title="Csharp Repl"></a>Csharp Repl</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">dotnet tool install <span class="hljs-literal">-g</span> csharprepl <br><span class="hljs-comment">#直接安装即可，无需代理</span><br><span class="hljs-comment">#已知可用环境:win11、win10</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网页游戏分享</title>
    <link href="/2024/10/13/%E7%BD%91%E9%A1%B5%E6%B8%B8%E6%88%8F%E5%88%86%E4%BA%AB/"/>
    <url>/2024/10/13/%E7%BD%91%E9%A1%B5%E6%B8%B8%E6%88%8F%E5%88%86%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<p><a href="https://cookieclicker.com/">Cookie Clicker</a></p><p><img src="/../images/%E7%BD%91%E9%A1%B5%E6%B8%B8%E6%88%8F%E5%88%86%E4%BA%AB/OIP.jpeg" alt="这是什么?饼干?点一下"></p>]]></content>
    
    
    <categories>
      
      <category>分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在线工具分享</title>
    <link href="/2024/10/13/%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"/>
    <url>/2024/10/13/%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<p>本文档内容来自互联网上富有分享精神的程序员们，感谢他们做出的贡献</p><h1 id="Learn-Git-Branching"><a href="#Learn-Git-Branching" class="headerlink" title="Learn Git Branching"></a><a href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git Branching</a></h1><p>一个在线学习和联系Git使用的网站</p><h1 id="VisuAlgo"><a href="#VisuAlgo" class="headerlink" title="VisuAlgo"></a><a href="https://visualgo.net/zh">VisuAlgo</a></h1><p>一个数据结构和算法可视化的网站</p>]]></content>
    
    
    <categories>
      
      <category>分享</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python脚本</title>
    <link href="/2024/10/06/Python%E8%84%9A%E6%9C%AC/"/>
    <url>/2024/10/06/Python%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="爬虫抓图"><a href="#爬虫抓图" class="headerlink" title="爬虫抓图"></a>爬虫抓图</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">from</span> io <span class="hljs-keyword">import</span> BytesIO<br><span class="hljs-comment">#这个可以用来爬一般的有图片的静态网站</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">download_images</span>(<span class="hljs-params">url,save_path,suffix =<span class="hljs-number">1</span></span>):<br>    os.makedirs(save_path, exist_ok=<span class="hljs-literal">True</span>)<br>    response = requests.get(url)<br>    soup = BeautifulSoup(response.text,<span class="hljs-string">&#x27;html.parser&#x27;</span>)<br>    image_tags = soup.find_all(<span class="hljs-string">&#x27;img&#x27;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(save_path):<br>        os.mkdir(save_path)<br><br>    <span class="hljs-keyword">for</span> img <span class="hljs-keyword">in</span> image_tags:<br>        img_url = img.get(<span class="hljs-string">&#x27;src&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;https&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> img_url:<br>            img_url = url+img_url<br>        img_data = requests.get(img_url).content<br>        <span class="hljs-comment">#使用合法的文件名</span><br>        img_name = os.path.join(save_path,os.path.basename(img_url).split(<span class="hljs-string">&#x27;?&#x27;</span>)[<span class="hljs-number">0</span>])<br>        img_name, ext = os.path.splitext(img_name)<br>        img_name = os.path.join(save_path,img_name)<br><br>      <br><br>        <span class="hljs-keyword">if</span> os.path.exists(os.path.join(save_path,img_name)+<span class="hljs-string">&quot;.jpg&quot;</span>):<br>            <span class="hljs-keyword">while</span> os.path.exists(os.path.join(save_path,<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;img_name&#125;</span>_<span class="hljs-subst">&#123;suffix&#125;</span>.jpg&quot;</span>)):<br>                suffix+=<span class="hljs-number">1</span><br>            img_name = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;img_name&#125;</span>_<span class="hljs-subst">&#123;suffix&#125;</span>&quot;</span><br>        <span class="hljs-built_in">print</span>(img_name)<br>        <span class="hljs-comment">#将图片转换为.jpg格式并保存</span><br>        <span class="hljs-keyword">try</span>:<br>            img = Image.<span class="hljs-built_in">open</span>(BytesIO(img_data))<br>        <span class="hljs-keyword">except</span> IOError:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Cannot identify image file from URL <span class="hljs-subst">&#123;img_url&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> ext == <span class="hljs-string">&#x27;.webp&#x27;</span>:<br>                <span class="hljs-comment"># 如果原始格式是 .webp，将其强制转换为 .jpg 格式</span><br>                img.save(img_name + <span class="hljs-string">&quot;.jpg&quot;</span>, <span class="hljs-string">&#x27;JPEG&#x27;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 否则，保持原始格式</span><br>                img.save(img_name + ext)<br><br><br><span class="hljs-comment">#url = &#x27;https://www.4khd.com/content/14/huayanghuayangshow20240208-vol566-wang-yuchun.html&#x27;</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    url=<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入网站:&quot;</span>)<br>    start_page = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入开始页面:&quot;</span>))<br>    end_page = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入终止页面:&quot;</span>))    <br>    <span class="hljs-keyword">if</span> url.endswith(<span class="hljs-string">&#x27;.html&#x27;</span>):<br>        folder_name =os.path.basename(url).split(<span class="hljs-string">&quot;?&quot;</span>)[<span class="hljs-number">0</span>]<br>        <span class="hljs-comment">#save_path = f&quot;F:\Picture\&#123;folder_name&#125;&quot;</span><br>        save_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), <span class="hljs-string">&quot;Pictures&quot;</span>, folder_name)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment">#save_path = f&#x27;F:\Picture\Crawler1&#x27;</span><br>        save_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), <span class="hljs-string">&quot;Pictures&quot;</span>, <span class="hljs-string">&quot;Crawler1&quot;</span>)<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start_page,end_page+<span class="hljs-number">1</span>):<br>        <span class="hljs-comment">#download_images(url+f&#x27;/?query-3-page=&#123;i&#125;&amp;cst&#x27;, save_path,1)</span><br>        <span class="hljs-comment">#download_images(url+f&#x27;/&#123;i&#125;&#x27;+&quot;.html&quot;, save_path,1)</span><br>        download_images(url+<span class="hljs-string">f&#x27;/<span class="hljs-subst">&#123;i&#125;</span>&#x27;</span>, save_path,<span class="hljs-number">1</span>)<br><br><br>    <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#面向对象</title>
    <link href="/2024/10/06/C-Sharp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2024/10/06/C-Sharp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>所以封装的作用是这样的，如果一个命名空间下没有可以引用的方法，该命名空间就不能被引用</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#发展史</title>
    <link href="/2024/09/30/C-sharp%E5%8F%91%E5%B1%95%E5%8F%B2/"/>
    <url>/2024/09/30/C-sharp%E5%8F%91%E5%B1%95%E5%8F%B2/</url>
    
    <content type="html"><![CDATA[<p>.NET 的发展历史可以分为多个阶段，涵盖了 .NET Framework、.NET Core 和 ASP.NET Core 的演变。以下是一个简要的概述：</p><h3 id="1-NET-Framework-（2002年发布）"><a href="#1-NET-Framework-（2002年发布）" class="headerlink" title="1. .NET Framework （2002年发布）"></a>1. <strong>.NET Framework</strong> （2002年发布）</h3><ul><li><strong>概述</strong>：这是微软在2002年首次推出的开发平台，旨在简化 Windows 应用开发。它包括了一个庞大的类库（BCL - Base Class Library）和 Common Language Runtime (CLR)，支持多种编程语言（如 C# 和 VB.NET）。</li><li><strong>主要特点</strong>：<ul><li>主要用于开发桌面应用（Windows Forms、WPF）、Web应用（ASP.NET Web Forms、ASP.NET MVC）、以及企业级应用。</li><li>由于紧密集成 Windows 操作系统，跨平台支持较差。</li></ul></li><li><strong>发展</strong>：<ul><li>通过多个版本的迭代添加了如 WCF（Windows Communication Foundation）、WPF（Windows Presentation Foundation）等技术。</li><li>.NET Framework 的最终版本是 4.8，在此之后，微软将更多的精力投入到跨平台的 .NET Core 上。</li></ul></li></ul><h3 id="2-NET-Core-（2016年发布）"><a href="#2-NET-Core-（2016年发布）" class="headerlink" title="2. .NET Core （2016年发布）"></a>2. <strong>.NET Core</strong> （2016年发布）</h3><ul><li><strong>概述</strong>：为了适应现代应用需求，微软在2016年推出了 .NET Core，作为一个轻量、跨平台的框架。它主要面向云计算、微服务和跨平台应用。</li><li><strong>主要特点</strong>：<ul><li>支持跨平台开发（Windows、Linux、macOS）。</li><li>模块化设计，开发者可以只安装和使用所需的组件。</li><li>性能改进显著，特别是在 Web 和云端应用中。</li><li>开源，微软通过 GitHub 维护 .NET Core。</li></ul></li><li><strong>发展</strong>：<ul><li>最初版本是 .NET Core 1.0，功能较少，主要支持控制台应用和 ASP.NET Core。</li><li>.NET Core 2.x 引入了更多的 API，使其更接近 .NET Framework 的功能。</li><li>.NET Core 3.0 开始支持 Windows Forms 和 WPF 等桌面应用，进一步加强其跨平台能力和性能优化。</li></ul></li></ul><h3 id="3-ASP-NET-和-ASP-NET-Core"><a href="#3-ASP-NET-和-ASP-NET-Core" class="headerlink" title="3. ASP.NET 和 ASP.NET Core"></a>3. <strong>ASP.NET 和 ASP.NET Core</strong></h3><ul><li><p>**ASP.NET (2002年发布)**：</p><ul><li>这是基于 .NET Framework 的 Web 开发框架，最早的版本是基于 Web Forms，支持服务器端控件和事件驱动的开发模式。</li><li>后来推出了 ASP.NET MVC，提供了基于 MVC 模式的开发方式，增加了更多的灵活性和可测试性。</li></ul></li><li><p>**ASP.NET Core (2016年发布)**：</p><ul><li>ASP.NET Core 是重新设计的 Web 开发框架，最初是为 .NET Core 打造的，后来也兼容 .NET Framework。其最大的优点是跨平台和高性能。</li><li>与传统的 ASP.NET 不同，ASP.NET Core 是完全模块化的，开发者可以根据需要选择不同的中间件来处理请求和响应。</li><li>逐步淘汰了 Web Forms，主推基于 Razor 的页面或 MVC 模式的开发。</li></ul></li></ul><h3 id="4-统一的-NET-平台：-NET-5-和之后-（2020年发布）"><a href="#4-统一的-NET-平台：-NET-5-和之后-（2020年发布）" class="headerlink" title="4. 统一的 .NET 平台：**.NET 5 和之后** （2020年发布）"></a>4. <strong>统一的 .NET 平台</strong>：**.NET 5 和之后** （2020年发布）</h3><ul><li><strong>概述</strong>：.NET 5 在2020年发布，标志着微软正式将 .NET Framework 和 .NET Core 合并为一个统一的开发平台，称为 “.NET”。从这一版本开始，微软每年发布一个新的主要版本。</li><li><strong>特点</strong>：<ul><li>继续跨平台支持，提升性能。</li><li>统一了应用模型，开发者不再需要区分 .NET Core 和 .NET Framework。</li><li>提供了对更多平台和框架的支持，如 WebAssembly 和 MAUI（用于跨平台的移动和桌面应用开发）。</li></ul></li></ul><h3 id="5-NET-6-和-NET-7"><a href="#5-NET-6-和-NET-7" class="headerlink" title="5. .NET 6 和 .NET 7"></a>5. <strong>.NET 6 和 .NET 7</strong></h3><ul><li><p>**.NET 6 (2021年发布)**：</p><ul><li>LTS（长期支持版），进一步提升了开发效率和跨平台能力。</li><li>引入了 MAUI 框架，使开发者能够用一个代码库编写跨平台的桌面和移动应用。</li></ul></li><li><p>**.NET 7 (2022年发布)**：</p><ul><li>提供更多的性能优化和新特性，进一步整合各种技术栈，如 Blazor（前端框架）、云原生应用支持等。</li></ul></li></ul><h3 id="关系和演变："><a href="#关系和演变：" class="headerlink" title="关系和演变："></a><strong>关系和演变</strong>：</h3><ul><li><strong>.NET Framework</strong>：最早期的微软开发平台，专注于 Windows 应用。</li><li><strong>.NET Core</strong>：后期发展出的一种轻量、跨平台框架，逐渐成为主流。</li><li><strong>ASP.NET Core</strong>：用于构建 Web 应用的现代框架，基于 .NET Core 构建。</li><li>**.NET 5+**：新的统一平台，取代了 .NET Framework 和 .NET Core，成为跨平台开发的未来方向。</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li><strong>.NET Framework</strong> 专注于 Windows，但随着时代发展，跨平台需求增加，微软转向了 .NET Core。</li><li><strong>.NET Core</strong> 强调性能、模块化和跨平台能力。</li><li><strong>.NET 5 及以后</strong> 通过统一平台，将 .NET Core 的现代特性与 .NET Framework 的广泛功能结合，继续适应现代开发需求。</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#代码固定格式及其优缺点</title>
    <link href="/2024/08/29/C-Sharp%E4%BB%A3%E7%A0%81%E5%9B%BA%E5%AE%9A%E6%A0%BC%E5%BC%8F%E4%BB%A5%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9/"/>
    <url>/2024/08/29/C-Sharp%E4%BB%A3%E7%A0%81%E5%9B%BA%E5%AE%9A%E6%A0%BC%E5%BC%8F%E4%BB%A5%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="轮询任务"><a href="#轮询任务" class="headerlink" title="轮询任务"></a>轮询任务</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RunningWorks</span>()</span> &#123;<br>    <span class="hljs-keyword">if</span>(ActiveWorks.Count &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//任务集合不为空</span><br>        Task.Factory.StartNew(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>            <span class="hljs-keyword">while</span>(!IsDisposed) &#123;<br>                <span class="hljs-keyword">await</span> Task.Delay(Interval);<span class="hljs-comment">//他和Thread.Sleep()那个更好？</span><br>            &#125;<br>        &#125;,TaskCreationOptions.LongRunning);<span class="hljs-comment">//长期运行任务的优化项</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Null判断"><a href="#Null判断" class="headerlink" title="Null判断"></a>Null判断</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">if</span>(a!=<span class="hljs-literal">null</span>)&#123;<br>    a.Start();<br>&#125;<br><span class="hljs-comment">//可以替换为</span><br>a?.Start();<span class="hljs-comment">//a不为null则Start</span><br></code></pre></td></tr></table></figure><h1 id="生成大量Enumable随机数据"><a href="#生成大量Enumable随机数据" class="headerlink" title="生成大量Enumable随机数据"></a>生成大量Enumable随机数据</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">Enumerable.Repeat(label,<span class="hljs-number">50</span>).Select(x =&gt; x + (<span class="hljs-built_in">float</span>)random.NextDouble()).ToArray()<br></code></pre></td></tr></table></figure><h2 id="带正负"><a href="#带正负" class="headerlink" title="带正负"></a>带正负</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#">Enumerable.Repeat(label,<span class="hljs-number">50</span>).Select(x =&gt; x + (<span class="hljs-built_in">float</span>)random.NextDouble()*<span class="hljs-number">2</span><span class="hljs-number">-1</span>).ToArray()<br><span class="hljs-comment">//加减在1内的随机数据</span><br></code></pre></td></tr></table></figure><h2 id="指定数量的范围内随机值"><a href="#指定数量的范围内随机值" class="headerlink" title="指定数量的范围内随机值"></a>指定数量的范围内随机值</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#">Enumerable.Range(<span class="hljs-number">0</span>, <span class="hljs-number">50</span>).Select(_=&gt;(<span class="hljs-built_in">float</span>)random.Next(<span class="hljs-number">1</span>,<span class="hljs-number">11</span>));<br><span class="hljs-comment">//50d10</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#字符串类技巧</title>
    <link href="/2024/07/21/C-sharp%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E6%8A%80%E5%B7%A7/"/>
    <url>/2024/07/21/C-sharp%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">var</span> message = <span class="hljs-string">&quot;Hello, C# String!&quot;</span>;<br>message.Split(<span class="hljs-string">&quot; &quot;</span>).Dump();<br>message.Split(<span class="hljs-string">&quot; &quot;</span>,<span class="hljs-number">2</span>).Dump();<span class="hljs-comment">//只要前两份</span><br></code></pre></td></tr></table></figure><p><img src="/../images/C-sharp%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E6%8A%80%E5%B7%A7/image-20240721185653054.png"></p><p>去掉其中的空项和去掉字符串中的空格</p><p><img src="/../images/C-sharp%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E6%8A%80%E5%B7%A7/image-20240721185849458.png"></p><p>如果找有重复项的，比如第二个空格，那么就可以用startIndex，cout还可以限制找的长度</p><p><img src="/../images/C-sharp%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E6%8A%80%E5%B7%A7/image-20240721190435311.png"></p><p>最好不要使用“\n”来换行，因为不同的操作系统的换行符不同</p><p>使用<code>Path.Combine(dir1,dir2,filename)</code>来拼接地址，不要手写地址</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">string</span> sep = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">&#x27;=&#x27;</span>,<span class="hljs-number">20</span>);<br>sep.Dump();<br><span class="hljs-comment">//用C#来输出和python里print(&quot;=&quot;*20)一样的效果</span><br></code></pre></td></tr></table></figure><p><img src="/../images/C-sharp%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E6%8A%80%E5%B7%A7/image-20240721191924114.png"></p><p>可以直接给字符串类的构造函数传入一个字符数组</p><p><img src="/../images/C-sharp%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E6%8A%80%E5%B7%A7/image-20240721192445529.png"></p><p>如果调用LINQ的话会产生额外的开销，可以直接用Array类的Reverse方法，直接原地调转数组，然后将其传入string构造函数</p><p>用Split，Contains的时候，能传入字符一定要用字符，而不是用字符串，因为char是非托管类型，是值类型，String是托管类型，开销要远大于char</p><p><code>\n</code>也是一个字符！</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对概念的个人理解</title>
    <link href="/2024/07/21/%E5%AF%B9%E6%A6%82%E5%BF%B5%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/"/>
    <url>/2024/07/21/%E5%AF%B9%E6%A6%82%E5%BF%B5%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="命令式编程和声明式编程"><a href="#命令式编程和声明式编程" class="headerlink" title="命令式编程和声明式编程"></a>命令式编程和声明式编程</h1><ul><li><p>命令式</p><ul><li>How</li><li>命令式编程要详细的告诉计算机要如何实现你的目标</li><li>a&#x3D;[10];</li><li>For(b in a){      if(b&gt;&#x3D;3){c[10].add(b);}}</li></ul></li><li><p>声明式</p><ul><li>What</li><li>告诉计算机你要实现什么目标</li><li>a&#x3D;[10];</li><li>c[10] &#x3D;      a.Which(b&#x3D;&gt; b&gt;&#x3D;3);</li></ul></li><li><p>并发</p><ul><li>在一段时间内看上去像是同时做了多个事情，实际上是并行执行的还是异步执行的都没有关系</li></ul></li></ul><h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><ul><li>进程是拥有资源的基本单位，线程是调用CPU的基本单位</li><li>最好的那个例子，一个word进程，你编辑文字是一个线程，保存文字是一个线程，如果不能并发的执行的话，那么在执行保存的时候进程就要卡住</li></ul><h1 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h1><ul><li>所谓泛型方法，实际上就是将类型作为参数输入进了函数中</li></ul><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人理解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之美</title>
    <link href="/2024/07/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/"/>
    <url>/2024/07/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/</url>
    
    <content type="html"><![CDATA[<p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_01.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_01"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_02.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_02"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_03.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_03"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_04.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_04"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_05.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_05"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_06.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_06"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_07.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_07"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_08.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_08"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_09.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_09"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_10.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_10"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_11.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_11"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_12.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_12"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_13.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_13"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_14.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_14"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_15.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_15"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_16.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_16"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_17.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_17"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_18.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_18"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_19.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_19"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_20.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_20"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_21.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_21"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_22.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_22"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_23.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_23"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_24.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_24"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_25.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_25"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_26.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_26"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_27.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_27"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_28.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_28"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_29.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_29"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_30.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_30"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_31.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_31"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_32.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_32"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_33.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_33"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_34.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_34"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_35.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_35"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_36.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_36"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_37.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_37"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_38.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_38"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_39.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_39"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_40.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_40"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_41.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_41"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_42.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_42"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_43.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_43"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_44.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_44"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_45.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_45"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_46.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_46"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_47.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_47"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_48.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_48"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_49.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_49"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_50.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_50"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_51.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_51"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_52.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_52"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_53.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_53"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_54.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_54"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_55.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_55"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_56.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_56"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_57.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_57"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_58.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_58"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_59.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_59"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_60.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_60"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_61.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_61"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_62.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_62"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_63.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_63"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_64.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_64"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_65.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_65"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_66.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_66"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_67.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_67"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_68.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_68"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_69.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_69"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_70.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_70"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_71.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_71"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_72.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_72"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_73.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_73"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_74.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_74"></p><p><img src="/./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20(%E7%8E%8B%E4%BA%89)%20(Z-Library)_%E9%A1%B5%E9%9D%A2_75.jpg" alt="设计模式之美 (王争) (Z-Library)_页面_75"></p>]]></content>
    
    
    <categories>
      
      <category>书籍</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>编程语言官网</title>
    <link href="/2024/07/05/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AE%98%E7%BD%91/"/>
    <url>/2024/07/05/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AE%98%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<h1 id="C-C"><a href="#C-C" class="headerlink" title="C&#x2F;C++"></a><a href="https://gcc.gnu.org/">C&#x2F;C++</a></h1><p><img src="/./../images/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AE%98%E7%BD%91/DeviconGcc.svg"></p><h1 id="C"><a href="#C" class="headerlink" title="C#"></a><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/">C#</a></h1><p><img src="/./../images/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AE%98%E7%BD%91/VscodeIconsFileTypeCsharp2.svg"></p><h5 id="NET"><a href="#NET" class="headerlink" title=".NET"></a><a href="https://dotnet.microsoft.com/zh-cn/download/dotnet">.NET</a></h5><h1 id="Go"><a href="#Go" class="headerlink" title="Go"></a><a href="https://go.dev/">Go</a></h1><p><img src="/./../images/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AE%98%E7%BD%91/VscodeIconsFileTypeGoGopher.svg"></p><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a><a href="https://www.java.com/zh-CN/">Java</a></h1><p><img src="/./../images/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AE%98%E7%BD%91/DeviconJava.svg"></p><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a><a href="https://www.javascript.com/">JavaScript</a></h1><p><img src="/./../images/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AE%98%E7%BD%91/VscodeIconsFileTypeJsOfficial.svg"></p><h1 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a><a href="https://kotlinlang.org/">Kotlin</a></h1><p><img src="/./../images/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AE%98%E7%BD%91/LogosKotlin.svg"></p><h1 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a><a href="https://www.lua.org/">Lua</a></h1><p><img src="/./../images/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AE%98%E7%BD%91/VscodeIconsFileTypeLua.svg"></p><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a><a href="https://www.python.org/">Python</a></h1><p><img src="/./../images/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AE%98%E7%BD%91/VscodeIconsFileTypePython.svg"></p><h1 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a><a href="https://www.rust-lang.org/zh-CN/">Rust</a></h1><p><img src="/./../images/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AE%98%E7%BD%91/VscodeIconsFileTypeLightRust.svg"></p><h1 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a><a href="https://www.ruby-lang.org/zh_cn/">Ruby</a></h1><p><img src="/./../images/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AE%98%E7%BD%91/LogosRuby.svg"></p><h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a><a href="https://www.typescriptlang.org/">TypeScript</a></h1><p><img src="/./../images/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AE%98%E7%BD%91/DeviconTypescript.svg"></p>]]></content>
    
    
    <categories>
      
      <category>分享</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>网络相关问题</title>
    <link href="/2024/06/11/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <url>/2024/06/11/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是安装钩子和配置钩子-hook-？"><a href="#什么是安装钩子和配置钩子-hook-？" class="headerlink" title="什么是安装钩子和配置钩子(hook)？"></a>什么是安装钩子和配置钩子(hook)？</h2><ul><li><p>在软件开发中，“钩子”（hook）<strong>是一种机制</strong>，<strong>允许在特定事件或时刻触发自定义代码</strong>。安装和配置钩子通常涉及在某些操作前后自动执行脚本或程序，以实现自动化任务、执行验证或其他定制功能。</p><h3 id="常见的钩子类型"><a href="#常见的钩子类型" class="headerlink" title="常见的钩子类型"></a>常见的钩子类型</h3><ol><li><strong>Git 钩子</strong>： Git 提供了一系列钩子，允许在特定的 Git 操作（如提交、推送、合并等）前后运行自定义脚本。常见的 Git 钩子包括：<ul><li><code>pre-commit</code>：在提交代码之前运行，可以用来检查代码风格、运行测试等。</li><li><code>pre-push</code>：在推送代码到远程仓库之前运行，可以用来验证代码是否符合要求。</li><li><code>post-merge</code>：在合并代码之后运行，可以用来执行一些后处理任务。</li></ul></li><li><strong>npm 钩子</strong>： npm 脚本也支持钩子机制，例如 <code>preinstall</code>、<code>postinstall</code> 等，允许在安装 npm 包之前或之后运行脚本。</li><li><strong>Web 应用钩子</strong>： 在 Web 开发中，可以设置一些钩子来在某些事件（如用户登录、数据更新等）发生时触发特定的代码。</li></ol></li></ul><h2 id="串口链路和以太网链路有什么区别？"><a href="#串口链路和以太网链路有什么区别？" class="headerlink" title="串口链路和以太网链路有什么区别？"></a>串口链路和以太网链路有什么区别？</h2><h2 id="串口链路为COM1到COM512，为什么是这个范围？"><a href="#串口链路为COM1到COM512，为什么是这个范围？" class="headerlink" title="串口链路为COM1到COM512，为什么是这个范围？"></a>串口链路为COM1到COM512，为什么是这个范围？</h2><ul><li><p>早期计算机系统中主板上只有两个串行端口（COM1和COM2），扩展卡可能增加到COM3和COM4。</p></li><li><p>到了现代，操作系统可以支持虚拟串行端口</p></li><li><p>在计算机系统中，<strong>COM端口</strong>（Communication Port）是串行通信端口的简称，用于通过串行接口传输数据。COM端口的主要特点是逐位传输数据，这种传输方式被广泛应用于各种设备之间的通信，例如计算机与调制解调器、打印机、工业控制设备等。</p><h3 id="COM端口的名称和范围"><a href="#COM端口的名称和范围" class="headerlink" title="COM端口的名称和范围"></a>COM端口的名称和范围</h3><ol><li><strong>名称</strong>：<ul><li>COM端口的名称通常为“COM”后面跟一个数字，比如COM1、COM2等。这些名称用于标识计算机系统中的具体串行端口。</li></ul></li><li><strong>范围</strong>：<ul><li>传统上，COM端口的编号范围是从COM1到COM4，因为早期的PC硬件通常只支持4个串行端口。</li><li>随着硬件和操作系统的发展，现代计算机系统可以支持更多的COM端口。Windows系统允许COM端口的编号从COM1一直到COM256。</li><li>一些专业应用和高端硬件可以支持多达512个串行端口，因此在某些情况下可以看到COM1到COM512的范围。</li></ul></li></ol><h3 id="为什么COM端口是这个范围"><a href="#为什么COM端口是这个范围" class="headerlink" title="为什么COM端口是这个范围"></a>为什么COM端口是这个范围</h3><ol><li><strong>历史原因</strong>：<ul><li>早期的计算机硬件限制：在早期的PC系统中，主板上通常只有两个串行端口（COM1和COM2），扩展卡可能增加到COM3和COM4。</li><li>硬件设计：由于串行端口的设计和当时的资源限制，最初的PC系统不支持大量的串行端口。</li></ul></li><li><strong>现代扩展</strong>：<ul><li>操作系统支持：现代操作系统如Windows支持更多的虚拟串行端口和USB-to-Serial适配器，可以分配更高编号的COM端口。</li><li>硬件扩展：现代工业和嵌入式系统中，串行通信依然广泛应用，因此硬件和驱动程序可以支持更大的COM端口范围，例如通过多串口卡或USB扩展器。</li><li>软件需求：一些专业软件和调试工具可能需要访问大量的串行端口，因此支持更大的编号范围。</li></ul></li></ol><h3 id="使用COM端口的示例"><a href="#使用COM端口的示例" class="headerlink" title="使用COM端口的示例"></a>使用COM端口的示例</h3><p>在编程中使用COM端口，通常需要指定端口名称，配置通信参数，然后进行读写操作。以下是一个使用C#中的<code>System.IO.Ports.SerialPort</code>类来打开COM端口的示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs csharp">csharp复制代码<span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.IO.Ports;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 创建SerialPort对象并指定端口名称和通信参数</span><br>        SerialPort serialPort = <span class="hljs-keyword">new</span> SerialPort(<span class="hljs-string">&quot;COM1&quot;</span>, <span class="hljs-number">9600</span>, Parity.None, <span class="hljs-number">8</span>, StopBits.One);<br><br>        <span class="hljs-keyword">try</span><br>        &#123;<br>            <span class="hljs-comment">// 打开端口</span><br>            serialPort.Open();<br><br>            <span class="hljs-comment">// 向端口写入数据</span><br>            serialPort.WriteLine(<span class="hljs-string">&quot;Hello, COM1!&quot;</span>);<br><br>            <span class="hljs-comment">// 从端口读取数据</span><br>            <span class="hljs-built_in">string</span> response = serialPort.ReadLine();<br>            Console.WriteLine(<span class="hljs-string">&quot;Received: &quot;</span> + response);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Exception ex)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Error: &quot;</span> + ex.Message);<br>        &#125;<br>        <span class="hljs-keyword">finally</span><br>        &#123;<br>            <span class="hljs-comment">// 关闭端口</span><br>            <span class="hljs-keyword">if</span> (serialPort.IsOpen)<br>            &#123;<br>                serialPort.Close();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，程序打开了COM1端口，配置了波特率为9600，无奇偶校验，8个数据位和1个停止位，然后进行了数据的发送和接收操作。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>COM端口</strong>是计算机串行通信端口的简称，广泛用于设备之间的数据传输。</li><li><strong>COM端口的名称</strong>通常为“COM”加上一个数字，从COM1开始。</li><li><strong>现代系统支持的COM端口范围</strong>可以从COM1到COM256，甚至更多（例如COM1到COM512）。</li><li><strong>历史和硬件发展</strong>使得COM端口的范围从早期的COM1到COM4扩展到现在的更大范围，以满足现代应用的需求。</li></ul></li></ul><h2 id="波特率？奇偶校验？数据位？停止位？"><a href="#波特率？奇偶校验？数据位？停止位？" class="headerlink" title="波特率？奇偶校验？数据位？停止位？"></a>波特率？奇偶校验？数据位？停止位？</h2><h2 id="端口和串口？"><a href="#端口和串口？" class="headerlink" title="端口和串口？"></a>端口和串口？</h2><ul><li><p><strong>端口</strong></p><ul><li><strong>定义</strong>：在网络通信中，IP地址用于标识网络中的设备，端口号用于标识设备上的特定服务或进程。端口号是一个16位数字，从0到65535</li><li><strong>用途</strong>:端口号可以使得一个设备撒谎给你的多个网络服务同时运行而不发生冲突——Http的80端口，SMTP常用25</li><li><strong>特点</strong>: 通常与传输层协议TCP&#x2F;UDP结合使用</li><li><strong>示例</strong>:当你访问一个网站时，你的浏览器可能会通过端口80（HTTP）或443（HTTPS）与服务器建立连接。</li></ul></li><li><p>串口</p><ul><li><strong>定义</strong>: 串口，也称为串行通信接口，是一种用于实现串行通信的硬件接口。它通过数据线（如RS-232、RS-422或RS-485）进行点对点的通信。</li><li><strong>用途</strong>: 串口主要用于计算机与外部设备（如打印机、调制解调器、传感器等）之间的连接。与网络通信不同，串口通信是同步的，数据一次传输一个比特。</li><li><strong>特点</strong>: 串口通信通常较慢，但可以实现长距离通信，并且由于是点对点连接，所以比较简单和稳定。</li><li><strong>示例</strong>: 在工业自动化和嵌入式系统中，串口常用于控制设备和读取传感器数据</li></ul></li></ul><h2 id="在向接口发送GET请求时发生了什么？"><a href="#在向接口发送GET请求时发生了什么？" class="headerlink" title="在向接口发送GET请求时发生了什么？"></a>在向接口发送GET请求时发生了什么？</h2><ol><li><strong>构建请求</strong>：<ul><li>客户端（例如浏览器或HTTP客户端）构建一个GET请求。这个请求包含请求行、请求头以及可能的查询参数。</li></ul></li><li><strong>发送请求</strong>：<ul><li>请求通过网络传输到服务器。这个过程可能经过多个网络节点和路由器。</li></ul></li><li><strong>服务器接收请求</strong>：<ul><li>服务器的Web服务器（如Apache、Nginx或IIS）接收这个请求。Web服务器负责解析请求，并将其传递给处理该请求的应用程序。</li></ul></li><li><strong>请求处理</strong>：<ul><li>应用程序读取请求的详细信息，包括URL、请求头和查询参数。然后根据请求URL和参数执行特定的逻辑。例如，从数据库中获取数据、进行计算、调用其他服务等。</li></ul></li><li><strong>生成响应</strong>：<ul><li>应用程序生成一个响应，通常包括状态码、响应头和响应体。响应体可能包含客户端请求的数据、错误信息或其他内容。</li></ul></li><li><strong>发送响应</strong>：<ul><li>响应通过网络返回到客户端。客户端接收到响应后，处理和显示返回的数据。</li></ul></li></ol><h2 id="Wireshark的Apdapter-for-loopback-traffic-capture是什么"><a href="#Wireshark的Apdapter-for-loopback-traffic-capture是什么" class="headerlink" title="Wireshark的Apdapter for loopback traffic capture是什么"></a>Wireshark的Apdapter for loopback traffic capture是什么</h2><p>Wireshark 的 “Adapter for loopback traffic capture” 是一个专门用于捕获环回（loopback）接口上的网络流量的工具。环回接口是一个虚拟网络接口，它通常用于同一台计算机上运行的应用程序之间的通信。它的 IP 地址通常为 <code>127.0.0.1</code>（IPv4）或 <code>::1</code>（IPv6）。</p><h4 id="环回接口和其捕获的必要性"><a href="#环回接口和其捕获的必要性" class="headerlink" title="环回接口和其捕获的必要性"></a>环回接口和其捕获的必要性</h4><p>在许多操作系统中，<strong>环回接口</strong>上的流量默认不会被捕获。通常情况下，网络分析工具（包括 Wireshark）主要捕获通过物理或无线网络接口的流量。而环回接口上的流量则往往被忽略。然而，捕获环回流量在以下情况下可能是必要的：</p><ol><li><strong>本地开发和测试</strong>：开发者在同一台机器上测试网络应用程序时，环回接口流量对于调试和分析非常重要。</li><li><strong>服务间通信</strong>：同一台服务器上不同服务或进程之间的通信可能通过环回接口进行。</li><li><strong>安全分析</strong>：环回接口流量可能包含对本地服务的攻击或利用尝试，捕获这些流量有助于安全分析。</li></ol><h4 id="“Adapter-for-loopback-traffic-capture”-的工作原理"><a href="#“Adapter-for-loopback-traffic-capture”-的工作原理" class="headerlink" title="“Adapter for loopback traffic capture” 的工作原理"></a>“Adapter for loopback traffic capture” 的工作原理</h4><p>“Adapter for loopback traffic capture” 是一个虚拟网络适配器，用于捕获 Windows 系统上的环回流量。这是因为 Windows <strong>默认不允许捕获环回流量</strong>，需要借助额外的工具来实现这一功能。常用的方法包括安装特殊的驱动程序或使用网络库，如 Npcap。</p><h4 id="Npcap-驱动"><a href="#Npcap-驱动" class="headerlink" title="Npcap 驱动"></a>Npcap 驱动</h4><p>Npcap 是一个 Windows 平台上的高效捕获库，它是 WinPcap 的现代替代品。Npcap 支持捕获环回接口流量。Wireshark 安装过程中通常会提示安装 Npcap：</p><ol><li><strong>安装 Npcap</strong>：确保在安装 Wireshark 时选择安装 Npcap 驱动程序。</li><li><strong>启用环回捕获</strong>：安装 Npcap 后，Wireshark 将能够捕获环回接口上的流量。</li></ol><h4 id="使用-Wireshark-捕获环回流量"><a href="#使用-Wireshark-捕获环回流量" class="headerlink" title="使用 Wireshark 捕获环回流量"></a>使用 Wireshark 捕获环回流量</h4><p>以下是在 Windows 系统上使用 Wireshark 捕获环回流量的步骤：</p><ol><li><strong>安装 Wireshark 和 Npcap</strong>：<ul><li>从 <a href="https://www.wireshark.org/">Wireshark 官网</a> 下载并安装 Wireshark。</li><li>确保在安装过程中选择安装 Npcap 驱动。</li></ul></li><li><strong>启动 Wireshark</strong>：<ul><li>打开 Wireshark 应用程序。</li></ul></li><li><strong>选择环回适配器</strong>：<ul><li>在主界面中，选择名为 “Npcap Loopback Adapter” 或类似名称的环回适配器。</li><li>注意：不同版本的 Npcap 可能显示的名称略有不同。</li></ul></li><li><strong>启动捕获</strong>：<ul><li>点击 “Start Capturing Packets” 按钮开始捕获数据包。</li></ul></li><li><strong>生成环回流量</strong>：<ul><li>在同一台机器上运行一些网络应用程序，生成环回流量。例如，访问 <code>http://127.0.0.1</code> 或 <code>http://localhost</code> 的 Web 服务器。</li></ul></li><li><strong>查看捕获的数据包</strong>：<ul><li>Wireshark 将显示捕获的环回流量数据包。你可以使用过滤器和其他分析工具查看详细信息。</li></ul></li></ol><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>假设你在本地运行一个 Web 服务器，并且从浏览器访问 <code>http://localhost:8080</code>，你可以在 Wireshark 中看到类似如下的捕获数据包：</p><ol><li><strong>HTTP 请求和响应</strong>：<ul><li>请求：<code>GET / HTTP/1.1</code>，源地址为 <code>127.0.0.1</code>，目的地址也是 <code>127.0.0.1</code>。</li><li>响应：<code>HTTP/1.1 200 OK</code>，源地址和目的地址同样为 <code>127.0.0.1</code>。</li></ul></li><li><strong>其他协议</strong>：<ul><li>如果有其他应用程序使用环回接口进行通信，也会显示在捕获的数据包中。</li></ul></li></ol><p>通过使用 “Adapter for loopback traffic capture” 和 Npcap 驱动程序，你可以方便地捕获和分析本地环回接口上的网络流量，这对于本地开发、调试和安全分析非常有用。</p><h2 id="什么是抓包"><a href="#什么是抓包" class="headerlink" title="什么是抓包"></a>什么是抓包</h2><p>抓包是指捕获和记录在网络上传输的数据包，以便进行分析和调试。抓包可以帮助网络管理员和安全分析师了解网络流量的具体内容，识别网络问题，检测网络攻击和入侵行为。抓包的过程通常包括以下几个步骤：</p><ol><li><strong>选择网卡</strong>：选择一个网卡进行数据包捕获。对于无线网络，可以选择无线网卡；对于有线网络，可以选择有线网卡。</li><li><strong>启动抓包</strong>：使用抓包工具开始捕获数据包。抓包工具会显示实时捕获的数据包列表。</li><li><strong>过滤数据包</strong>：使用过滤器只捕获感兴趣的数据包。例如，只捕获特定 IP 地址、端口号或协议的数据包。</li><li><strong>分析数据包</strong>：抓包工具会解析捕获的数据包，并以易于理解的格式显示其内容。用户可以查看数据包的详细信息，包括源和目的地址、协议类型、数据内容等。</li><li><strong>保存和导出数据包</strong>：将捕获的数据包保存为文件，以便以后分析或共享。</li></ol><h2 id="抓包的原理"><a href="#抓包的原理" class="headerlink" title="抓包的原理"></a>抓包的原理</h2><ol><li><strong>网络接口卡（NIC）</strong>：计算机的网络接口卡（NIC）通常在正常模式下只接收发给自己的数据包。为了进行抓包，NIC 需要工作在混杂模式（Promiscuous Mode），在这种模式下，NIC 可以接收通过网络的所有数据包，而不仅仅是发给它的数据包。</li><li><strong>数据包拦截</strong>：在混杂模式下，网络接口卡<strong>将接收到的所有数据包传递给操作系统的网络堆栈</strong>。抓包工具（如 Wireshark）通过操作系统提供的接口（例如 Windows 的 WinPcap 或 Npcap 驱动，Linux 的 libpcap 库）来捕获这些数据包。</li><li><strong>数据包存储和分析</strong>：抓包工具会将捕获的数据包存储在内存或文件中，并解析这些数据包，显示其内容和元数据。Wireshark 提供了丰富的协议解析功能，可以识别并解析数百种网络协议，并以用户友好的方式显示数据包的详细信息。</li></ol><h2 id="NIC网卡有哪些工作模式？"><a href="#NIC网卡有哪些工作模式？" class="headerlink" title="NIC网卡有哪些工作模式？"></a>NIC网卡有哪些工作模式？</h2><p>除了混杂模式（Promiscuous Mode），NIC还有以下几种常见的工作模式：</p><ol><li><strong>正常模式（Normal Mode）</strong>：<ul><li>在正常模式下，NIC<strong>只接收目的地址是自己的数据包</strong>。对于以太网，这意味着NIC只处理以太网帧的目的MAC地址与其硬件MAC地址匹配的数据包。</li></ul></li><li><strong>多播模式（Multicast Mode）</strong>：<ul><li>在多播模式下，NIC被配置为<strong>接收特定多播组地址的数据包</strong>。多播是一种将单一数据包传送给多个接收者的网络方法。NIC只会接收它被配置的多播地址的数据包。</li></ul></li><li><strong>全部多播模式（All-Multicast Mode）</strong>：<ul><li>在全部多播模式下，NIC将<strong>接收所有的多播流量</strong>，<strong>而不仅仅是特定的多播组地址</strong>。这对于网络分析工具非常有用，因为它们需要监控所有的多播通信。</li></ul></li><li><strong>广播模式（Broadcast Mode）</strong>：<ul><li>在广播模式下，NIC<strong>接收发送到广播地址的数据包</strong>。以太网中的广播地址是 <code>FF:FF:FF:FF:FF:FF</code>，意味着所有连接到同一网络的设备都将接收这些数据包。</li></ul></li><li><strong>无链路模式（Link-Down Mode）</strong>：<ul><li>在无链路模式下，NIC被禁用，无法发送或接收任何数据。这通常用于网络故障排除或网络配置更改时暂时禁用网络接口。</li></ul></li><li><strong>低功耗模式（Low Power Mode）</strong>：<ul><li>在低功耗模式下，NIC进入节能状态，以减少电力消耗。这在移动设备或需要节能的设备上特别有用。<strong>NIC在低功耗模式下可能无法接收数据，或者只能以较低的速率接收数据</strong>。</li></ul></li></ol><h4 id="解释混杂模式"><a href="#解释混杂模式" class="headerlink" title="解释混杂模式"></a>解释混杂模式</h4><p><strong>混杂模式（Promiscuous Mode）</strong>：</p><ul><li>在混杂模式下，NIC接收所有流经网络的流量，而不仅仅是发送到其MAC地址的数据包。这对于网络监控和分析工具（如Wireshark）非常有用，因为它们需要查看网络上所有的通信。</li></ul><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>NIC有多种工作模式，包括正常模式、混杂模式、多播模式、全部多播模式、广播模式、无链路模式和低功耗模式。每种模式有其特定的用途，适用于不同的网络需求和场景。混杂模式尤其用于网络分析和监控，因为它允许NIC接收网络上所有的数据包，而不仅仅是发送给自己的数据包。</p><h2 id="Http常见的错误码有哪些？都是什么意思？"><a href="#Http常见的错误码有哪些？都是什么意思？" class="headerlink" title="Http常见的错误码有哪些？都是什么意思？"></a>Http常见的错误码有哪些？都是什么意思？</h2><p>HTTP错误码，也称为HTTP状态码，是服务器在响应HTTP请求时返回的代码，用于表示请求的结果状态。常见的HTTP错误码及其含义如下：</p><h4 id="1xx-Informational-信息性状态码"><a href="#1xx-Informational-信息性状态码" class="headerlink" title="1xx Informational (信息性状态码)"></a>1xx Informational (信息性状态码)</h4><ul><li><strong>100 Continue</strong>：客户端应该继续请求。如果已经完成请求，则忽略此消息。</li><li><strong>101 Switching Protocols</strong>：服务器根据客户端的请求切换协议。</li></ul><h4 id="2xx-Success-成功状态码"><a href="#2xx-Success-成功状态码" class="headerlink" title="2xx Success (成功状态码)"></a>2xx Success (成功状态码)</h4><ul><li><strong>200 OK</strong>：请求成功，并返回所请求的资源。</li><li><strong>201 Created</strong>：请求成功并且服务器创建了新的资源。</li><li><strong>202 Accepted</strong>：服务器已接受请求，但尚未处理。</li><li><strong>204 No Content</strong>：请求成功但没有内容返回。</li><li><strong>205 Reset Content</strong>：请求成功，请重置视图。</li></ul><h4 id="3xx-Redirection-重定向状态码"><a href="#3xx-Redirection-重定向状态码" class="headerlink" title="3xx Redirection (重定向状态码)"></a>3xx Redirection (重定向状态码)</h4><ul><li><strong>301 Moved Permanently</strong>：请求的资源已被永久移动到新的URL。</li><li><strong>302 Found</strong>：请求的资源临时从不同的URL响应。</li><li><strong>304 Not Modified</strong>：资源未被修改，自上次请求以来没有变化。</li><li><strong>307 Temporary Redirect</strong>：请求的资源临时从不同的URL响应，但必须使用原有的方法请求。</li></ul><h4 id="4xx-Client-Errors-客户端错误状态码"><a href="#4xx-Client-Errors-客户端错误状态码" class="headerlink" title="4xx Client Errors (客户端错误状态码)"></a>4xx Client Errors (客户端错误状态码)</h4><ul><li><strong>400 Bad Request</strong>：服务器无法理解请求的格式，客户端应修改请求。</li><li><strong>401 Unauthorized</strong>：请求需要用户认证。</li><li><strong>403 Forbidden</strong>：服务器理解请求，但拒绝执行。</li><li><strong>404 Not Found</strong>：请求的资源不存在。</li><li><strong>405 Method Not Allowed</strong>：请求方法不被允许。</li><li><strong>406 Not Acceptable</strong>：请求的资源不符合客户端的条件。</li><li><strong>408 Request Timeout</strong>：请求超时，服务器等待客户端发送请求数据超时。</li><li><strong>409 Conflict</strong>：请求与服务器的状态冲突。</li><li><strong>410 Gone</strong>：请求的资源永久删除。</li><li><strong>411 Length Required</strong>：服务器要求在请求中包含Content-Length头。</li><li><strong>413 Payload Too Large</strong>：请求实体过大，服务器无法处理。</li><li><strong>414 URI Too Long</strong>：请求的URI过长，服务器无法处理。</li><li><strong>415 Unsupported Media Type</strong>：请求的媒体格式不受支持。</li><li><strong>429 Too Many Requests</strong>：客户端发送的请求次数超过限额。</li></ul><h4 id="5xx-Server-Errors-服务器错误状态码"><a href="#5xx-Server-Errors-服务器错误状态码" class="headerlink" title="5xx Server Errors (服务器错误状态码)"></a>5xx Server Errors (服务器错误状态码)</h4><ul><li><strong>500 Internal Server Error</strong>：服务器遇到错误，无法完成请求。</li><li><strong>501 Not Implemented</strong>：服务器不支持请求的方法。</li><li><strong>502 Bad Gateway</strong>：服务器作为网关或代理，从上游服务器收到无效响应。</li><li><strong>503 Service Unavailable</strong>：服务器暂时不可用，通常是由于过载或维护。</li><li><strong>504 Gateway Timeout</strong>：服务器作为网关或代理，未能及时从上游服务器收到响应。</li><li><strong>505 HTTP Version Not Supported</strong>：服务器不支持请求所用的HTTP版本。</li></ul><h4 id="常见错误码解释"><a href="#常见错误码解释" class="headerlink" title="常见错误码解释"></a>常见错误码解释</h4><h5 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h5><ul><li><strong>解释</strong>：服务器找不到请求的资源。这通常是因为URL错误或资源已被删除。</li><li><strong>例子</strong>：访问一个不存在的网页时，会返回404错误。</li></ul><h5 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 Internal Server Error"></a>500 Internal Server Error</h5><ul><li><strong>解释</strong>：服务器遇到意外情况，无法完成请求。这通常是由于服务器端代码错误或配置问题。</li><li><strong>例子</strong>：服务器端脚本执行错误，会导致返回500错误。</li></ul><h5 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h5><ul><li><strong>解释</strong>：服务器理解请求，但拒绝执行。这通常是因为权限问题。</li><li><strong>例子</strong>：试图访问没有权限查看的目录或文件时，会返回403错误。</li></ul><h4 id="如何处理这些错误码"><a href="#如何处理这些错误码" class="headerlink" title="如何处理这些错误码"></a>如何处理这些错误码</h4><ul><li><strong>客户端方面</strong>：<ul><li>检查并确保URL正确。</li><li>确认请求方法（GET、POST等）是否正确。</li><li>验证请求头和参数是否正确。</li><li>对需要身份认证的请求，确保提供正确的认证信息。</li></ul></li><li><strong>服务器方面</strong>：<ul><li>查看服务器日志，确定错误原因。</li><li>检查服务器配置，确保正确处理请求。</li><li>确认资源存在且路径正确。</li><li>对于频繁出现的错误，可以添加自定义错误页面，提供更友好的错误信息。</li></ul></li></ul><h2 id="什么是Sockets？"><a href="#什么是Sockets？" class="headerlink" title="什么是Sockets？"></a>什么是Sockets？</h2><p>Sockets是一种<strong>网络编程接口</strong>，用于在网络上进行通信。<strong>它是一种抽象的概念</strong>，通过它，应用程序可以通过网络传输数据。Sockets广泛应用于<strong>客户端-服务器模型</strong>的网络通信。</p><h2 id="除了客户端-服务器模型的网络通信，还有什么模型？应用于什么领域？"><a href="#除了客户端-服务器模型的网络通信，还有什么模型？应用于什么领域？" class="headerlink" title="除了客户端-服务器模型的网络通信，还有什么模型？应用于什么领域？"></a>除了客户端-服务器模型的网络通信，还有什么模型？应用于什么领域？</h2><h3 id="1-对等网络模型（Peer-to-Peer-P2P）"><a href="#1-对等网络模型（Peer-to-Peer-P2P）" class="headerlink" title="1. 对等网络模型（Peer-to-Peer, P2P）"></a>1. <strong>对等网络模型（Peer-to-Peer, P2P）</strong></h3><h4 id="结构："><a href="#结构：" class="headerlink" title="结构："></a>结构：</h4><p>在P2P模型中，<strong>每个节点（即每个计算机或设备）既是客户端也是服务器</strong>。节点可以直接与其他节点通信，没有中心服务器来管理通信。</p><h4 id="应用领域："><a href="#应用领域：" class="headerlink" title="应用领域："></a>应用领域：</h4><ul><li><strong>文件共享</strong>：如BitTorrent、Gnutella，这些应用允许用户在网络中共享和下载文件。</li><li><strong>分布式计算</strong>：如SETI@home、Folding@home，利用闲置的计算资源来执行大型计算任务。</li><li><strong>区块链和加密货币</strong>：如Bitcoin、Ethereum，通过去中心化的方式实现安全和可靠的交易和智能合约执行。</li></ul><h3 id="2-发布-订阅模型（Publish-Subscribe-Pub-Sub）"><a href="#2-发布-订阅模型（Publish-Subscribe-Pub-Sub）" class="headerlink" title="2. 发布-订阅模型（Publish-Subscribe, Pub&#x2F;Sub）"></a>2. <strong>发布-订阅模型（Publish-Subscribe, Pub&#x2F;Sub）</strong></h3><h4 id="结构：-1"><a href="#结构：-1" class="headerlink" title="结构："></a>结构：</h4><p>在Pub&#x2F;Sub模型中，发布者（Publisher）将消息发布到特定的主题（Topic），订阅者（Subscriber）订阅感兴趣的主题，从而接收相关的消息。<strong>通常通过中介（Broker）来管理发布和订阅</strong>。</p><h4 id="应用领域：-1"><a href="#应用领域：-1" class="headerlink" title="应用领域："></a>应用领域：</h4><ul><li><strong>消息系统</strong>：如Apache Kafka、RabbitMQ，用于日志收集、事件通知、数据流处理等。</li><li><strong>实时更新</strong>：如股票行情、社交媒体更新，订阅者可以实时收到最新信息。</li><li><strong>物联网（IoT）</strong>：<strong>如MQTT协议</strong>，设备可以发布传感器数据，订阅者可以实时监控这些数据。</li></ul><h3 id="3-点对点模型（Point-to-Point）"><a href="#3-点对点模型（Point-to-Point）" class="headerlink" title="3. 点对点模型（Point-to-Point）"></a>3. <strong>点对点模型（Point-to-Point）</strong></h3><h4 id="结构：-2"><a href="#结构：-2" class="headerlink" title="结构："></a>结构：</h4><p>在点对点模型中，<strong>两端点之间直接通信</strong>，<strong>没有中间的服务器或代理</strong>。<strong>通信通常是基于套接字（Sockets</strong>）。</p><h4 id="应用领域：-2"><a href="#应用领域：-2" class="headerlink" title="应用领域："></a>应用领域：</h4><ul><li><strong>即时通信</strong>：如Skype、WhatsApp中的点对点通话，用户之间直接建立连接进行音视频通信。</li><li><strong>文件传输</strong>：如SCP（Secure Copy Protocol），用于在两台计算机之间安全传输文件。</li></ul><h3 id="4-多播模型（Multicast）"><a href="#4-多播模型（Multicast）" class="headerlink" title="4. 多播模型（Multicast）"></a>4. <strong>多播模型（Multicast）</strong></h3><h4 id="结构：-3"><a href="#结构：-3" class="headerlink" title="结构："></a>结构：</h4><p><strong>多播模型允许单个发送者将消息发送到多个接收者</strong>，<strong>接收者组成一个多播组（Multicast Group）</strong>。<strong>路由器和交换机在网络层面支持多播。</strong></p><h4 id="应用领域：-3"><a href="#应用领域：-3" class="headerlink" title="应用领域："></a>应用领域：</h4><ul><li><strong>流媒体</strong>：如网络电视、在线广播，向多个用户同时传输音视频内容。</li><li><strong>金融市场数据分发</strong>：将市场数据（如股票价格）实时分发给多个订阅者。</li><li><strong>分布式数据库</strong>：用于数据库复制和同步。</li></ul><h3 id="5-网格网络模型（Mesh-Network）"><a href="#5-网格网络模型（Mesh-Network）" class="headerlink" title="5. 网格网络模型（Mesh Network）"></a>5. <strong>网格网络模型（Mesh Network）</strong></h3><h4 id="结构：-4"><a href="#结构：-4" class="headerlink" title="结构："></a>结构：</h4><p>在网格网络中，<strong>每个节点都可以与多个其他节点直接通信</strong>，形成一个<strong>网状结构</strong>。通信路径可以动态调整以优化传输和容错。</p><h4 id="应用领域：-4"><a href="#应用领域：-4" class="headerlink" title="应用领域："></a>应用领域：</h4><ul><li><strong>无线自组网</strong>：如Zigbee、LoRa，应用于智能家居、工业自动化等领域的无线传感器网络。</li><li><strong>灾难恢复</strong>：在自然灾害或紧急情况下，临时建立通信网络以保障通信畅通。</li><li><strong>社区网络</strong>：通过社区用户的设备形成一个分布式网络，共享互联网接入。</li></ul><h3 id="6-代理模型（Proxy-Model）"><a href="#6-代理模型（Proxy-Model）" class="headerlink" title="6. 代理模型（Proxy Model）"></a>6. <strong>代理模型（Proxy Model）</strong></h3><h4 id="结构：-5"><a href="#结构：-5" class="headerlink" title="结构："></a>结构：</h4><p>在代理模型中，<strong>客户端通过代理服务器与外部服务器通信</strong>。代理服务器可以<strong>对请求进行过滤、缓存、负载均衡</strong>等处理。</p><h4 id="应用领域：-5"><a href="#应用领域：-5" class="headerlink" title="应用领域："></a>应用领域：</h4><ul><li><strong>内容过滤和缓存</strong>：如公司网络中的Web代理，过滤不良网站并缓存常访问内容以节省带宽。</li><li><strong>匿名浏览</strong>：如Tor网络，通过多层代理隐藏用户的真实IP地址和浏览行为。</li><li><strong>负载均衡</strong>：在高流量网站中，代理服务器可以分发请求到多个后端服务器以平衡负载。</li></ul><h2 id="多播和广播的区别是？"><a href="#多播和广播的区别是？" class="headerlink" title="多播和广播的区别是？"></a>多播和广播的区别是？</h2><h3 id="广播（Broadcast）"><a href="#广播（Broadcast）" class="headerlink" title="广播（Broadcast）"></a>广播（Broadcast）</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li><strong>传输范围</strong>：<ul><li>数据包会发送到网络内的所有节点。</li><li>广播数据包在特定网络域（如局域网）内传播，但不会跨越路由器进入其他网络。</li></ul></li><li><strong>目标设备</strong>：<ul><li>所有网络中的设备都会接收到广播消息。</li><li>没有选择性，所有设备都会处理广播数据包，即使它们不需要该数据。</li></ul></li><li><strong>地址类型</strong>：<ul><li>使用广播地址。例如，在IPv4中，广播地址通常为255.255.255.255或特定子网的广播地址（如192.168.1.255）。</li></ul></li><li><strong>应用场景</strong>：<ul><li>网络发现：例如ARP（地址解析协议）请求，用于将IP地址解析为MAC地址。</li><li>DHCP（动态主机配置协议）：用于分配IP地址时的初始请求。</li></ul></li></ol><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li><strong>优点</strong>：<ul><li>简单直接，适合发送需要所有节点接收的消息。</li></ul></li><li><strong>缺点</strong>：<ul><li>低效：所有节点都要处理广播数据，可能会浪费带宽和计算资源。</li><li>可扩展性差：在大规模网络中，过多的广播会导致广播风暴，降低网络性能。</li></ul></li></ul><h3 id="多播（Multicast）"><a href="#多播（Multicast）" class="headerlink" title="多播（Multicast）"></a>多播（Multicast）</h3><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ol><li><strong>传输范围</strong>：<ul><li>数据包仅发送到订阅了特定多播组的节点。</li><li>多播数据包<strong>可以跨越路由器</strong>，但<strong>需要网络设备（如路由器）支持多播协议（如IGMP和PIM</strong>）。</li></ul></li><li><strong>目标设备</strong>：<ul><li>只有加入特定多播组的节点才会接收到多播消息。</li><li>选择性传输，提高了网络效率。</li></ul></li><li><strong>地址类型</strong>：<ul><li>使用多播地址。在IPv4中，多播地址范围为224.0.0.0到239.255.255.255。</li><li>在IPv6中，多播地址以FF开头（例如FF00::&#x2F;8）。</li></ul></li><li><strong>应用场景</strong>：<ul><li>实时数据分发：如视频会议、直播视频流、在线游戏。</li><li>网络协议：如OSPF（开放最短路径优先）路由协议，用于在路由器之间分发路由信息。</li></ul></li></ol><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li><strong>优点</strong>：<ul><li>高效：只有需要接收数据的节点才会接收，节省带宽。</li><li>可扩展：适用于大规模分发数据，避免不必要的数据传输。</li></ul></li><li><strong>缺点</strong>：<ul><li>复杂性：网络设备和配置需要支持多播。</li><li>需要管理多播组和处理多播协议，增加了配置和维护的复杂性。</li></ul></li></ul><h3 id="总结比较"><a href="#总结比较" class="headerlink" title="总结比较"></a>总结比较</h3><table><thead><tr><th>特点</th><th>广播 (Broadcast)</th><th>多播 (Multicast)</th></tr></thead><tbody><tr><td>传输范围</td><td>所有网络内的节点</td><td>订阅了特定多播组的节点</td></tr><tr><td>目标设备</td><td>所有设备接收</td><td>只有特定多播组的设备接收</td></tr><tr><td>地址类型</td><td>广播地址（如255.255.255.255）</td><td>多播地址（如224.0.0.0到239.255.255.255）</td></tr><tr><td>应用场景</td><td>网络发现、DHCP等</td><td>实时数据分发、网络协议等</td></tr><tr><td>优点</td><td>简单直接</td><td>高效、可扩展</td></tr><tr><td>缺点</td><td>低效、可扩展性差</td><td>复杂性高、需要多播支持</td></tr></tbody></table><p>通过这些比较可以看出，多播和广播在数据传输的目标选择和网络资源利用上有显著的差异。广播适用于需要所有节点接收的简单任务，而多播适合需要选择性传输的高效数据分发任务。</p><h2 id="常见HTTP请求方法"><a href="#常见HTTP请求方法" class="headerlink" title="常见HTTP请求方法"></a>常见HTTP请求方法</h2><ol><li><p><strong>GET</strong>：</p><ul><li><p><strong>用途</strong>：请求从服务器检索数据。</p></li><li><p><strong>功能</strong>：GET请求通过URL传递参数，并从服务器获取响应数据。它通常用于获取数据而不进行任何数据修改。</p></li><li><p><strong>特性</strong>：GET请求是幂等的（同样的请求多次执行效果相同）和安全的（不会对服务器数据进行修改）。</p></li><li><p>示例</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/index.html</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.example.com<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>POST</strong>：</p><ul><li><p><strong>用途</strong>：将数据提交到服务器，通常用于表单提交或上传文件。</p></li><li><p><strong>功能</strong>：POST请求通过请求体传递数据，服务器处理数据并返回响应。它通常用于创建或更新资源。</p></li><li><p><strong>特性</strong>：POST请求不是幂等的（同样的请求多次执行可能会导致不同的效果），可以对服务器资源进行修改。</p></li><li><p>示例</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/submit-form</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.example.com<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>27<br><br><span class="language-ini"><span class="hljs-attr">name</span>=John&amp;age=<span class="hljs-number">30</span></span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>PUT</strong>：</p><ul><li><p><strong>用途</strong>：将数据上传到服务器，通常用于更新资源。</p></li><li><p><strong>功能</strong>：PUT请求通过请求体传递数据，服务器用传递的数据替换目标资源的内容。</p></li><li><p><strong>特性</strong>：PUT请求是幂等的。</p></li><li><p>示例</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">PUT</span> <span class="hljs-string">/users/1</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.example.com<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/json<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>18<br><br><span class="language-json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;John&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">30</span><span class="hljs-punctuation">&#125;</span></span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>DELETE</strong>：</p><ul><li><p><strong>用途</strong>：请求服务器删除指定的资源。</p></li><li><p><strong>功能</strong>：DELETE请求删除指定的资源，服务器返回删除结果。</p></li><li><p><strong>特性</strong>：DELETE请求是幂等的。</p></li><li><p>示例</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">DELETE</span> <span class="hljs-string">/users/1</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.example.com<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>HEAD</strong>：</p><ul><li><p><strong>用途</strong>：与GET请求类似，但服务器仅返回响应头，不返回响应体。</p></li><li><p><strong>功能</strong>：用于检查资源的元数据（如响应头信息）而不获取实际数据。</p></li><li><p><strong>特性</strong>：HEAD请求是幂等的。</p></li><li><p>示例</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">HEAD</span> <span class="hljs-string">/index.html</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.example.com<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>OPTIONS</strong>：</p><ul><li><p><strong>用途</strong>：查询服务器支持的请求方法和选项。</p></li><li><p><strong>功能</strong>：用于检查服务器允许的HTTP方法、CORS设置等。</p></li><li><p><strong>特性</strong>：OPTIONS请求是幂等的。</p></li><li><p>示例</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">OPTIONS</span> <span class="hljs-string">/index.html</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.example.com<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>PATCH</strong>：</p><ul><li><p><strong>用途</strong>：部分更新资源。</p></li><li><p><strong>功能</strong>：PATCH请求通过请求体传递数据，仅修改目标资源的部分内容。</p></li><li><p><strong>特性</strong>：PATCH请求不是幂等的。</p></li><li><p>示例</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">PATCH</span> <span class="hljs-string">/users/1</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.example.com<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/json<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>18<br><br><span class="language-json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">31</span><span class="hljs-punctuation">&#125;</span></span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>CONNECT</strong>：</p><ul><li><p><strong>用途</strong>：用于建立隧道连接，如通过HTTP代理建立SSL隧道。</p></li><li><p><strong>功能</strong>：通常用于HTTPS请求，通过HTTP代理进行中继。</p></li><li><p><strong>特性</strong>：CONNECT请求不是幂等的。</p></li><li><p>示例</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">CONNECT</span> <span class="hljs-string">www.example.com:443</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.example.com<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>TRACE</strong>：</p><ul><li><p><strong>用途</strong>：回显服务器收到的请求，主要用于诊断和调试。</p></li><li><p><strong>功能</strong>：服务器将收到的请求内容原样返回给客户端。</p></li><li><p><strong>特性</strong>：TRACE请求是幂等的。</p></li><li><p>示例</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">TRACE</span> <span class="hljs-string">/index.html</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.example.com<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="常见WIFI加密方式及发展历史"><a href="#常见WIFI加密方式及发展历史" class="headerlink" title="常见WIFI加密方式及发展历史"></a>常见WIFI加密方式及发展历史</h2><ul><li><p>WEP </p><ul><li>因为每个包都会以某种形式带有密码，收集足够多的包之后比对重复内容，直接获得</li></ul></li><li><p>WPA2</p><ul><li>不再持续发包，而是简化为了四步握手</li><li>获取到足够多的锁和钥匙之后依旧可以</li></ul></li><li><p>WPA3</p><ul><li>使用Dragonfly算法，旨在大幅增加观察到这个握手过程</li><li>问题是，如果网络中有任何WPA2设备，路由器就会退回WPA2状态</li></ul></li></ul><h2 id="为什么在插入网线之后WiFi断连了？"><a href="#为什么在插入网线之后WiFi断连了？" class="headerlink" title="为什么在插入网线之后WiFi断连了？"></a>为什么在插入网线之后WiFi断连了？</h2><p>当在插有便携 WiFi 的设备上插入网线时，路由冲突的原因主要与<strong>网络适配器的优先级、默认网关的选择</strong>和<strong>IP 地址分配</strong>有关。详细原因如下：</p><h3 id="1-网络适配器优先级和默认网关冲突"><a href="#1-网络适配器优先级和默认网关冲突" class="headerlink" title="1. 网络适配器优先级和默认网关冲突"></a>1. <strong>网络适配器优先级和默认网关冲突</strong></h3><ul><li>操作系统通常根据适配器的优先级来决定网络路由，当插入网线时，<strong>有线网络优先级往往比无线网络高</strong>，因此系统会选择有线网络的路由和网关作为默认路由。</li><li>此时，系统默认的网络路由会自动切换到网线连接，而 WiFi 适配器的路由可能被忽略或被系统暂时断开，以避免流量同时经过两个网关。这种切换可能导致 WiFi 掉线或暂时无法访问网络。</li></ul><h3 id="2-IP-地址和网段冲突"><a href="#2-IP-地址和网段冲突" class="headerlink" title="2. IP 地址和网段冲突"></a>2. <strong>IP 地址和网段冲突</strong></h3><ul><li>如果便携 WiFi 和有线网络分配的 IP 地址在同一网段（例如，两个网络的 IP 都在 <code>192.168.1.x</code>），系统可能出现 IP 地址和路由的混乱，从而导致路由冲突。</li><li>系统可能会尝试将同一个网关分配给两个适配器，这样一来就会导致数据包的去向无法确定，网络连接出现异常。</li></ul><h3 id="3-操作系统的网络切换机制"><a href="#3-操作系统的网络切换机制" class="headerlink" title="3. 操作系统的网络切换机制"></a>3. <strong>操作系统的网络切换机制</strong></h3><ul><li>部分操作系统在检测到新的有线连接时，可能会默认断开现有的 WiFi 连接，以节约资源或保证网络的稳定性。这种情况下，插入网线会自动触发 WiFi 断开，导致网络连接看似“掉线”。</li><li>有些便携 WiFi 适配器也有类似设计，当检测到有线网络时可能会自动断开 WiFi。</li></ul><h3 id="4-DNS-配置和路由表冲突"><a href="#4-DNS-配置和路由表冲突" class="headerlink" title="4. DNS 配置和路由表冲突"></a>4. <strong>DNS 配置和路由表冲突</strong></h3><ul><li>插入网线后，系统的 DNS 配置和路由表可能会自动刷新，优先使用有线连接的 DNS 服务器。如果有线网络的 DNS 解析不稳定或与无线网络冲突，可能会导致无法正常访问 WiFi 网络上的资源。</li><li>当路由表中的默认路由切换到有线连接时，WiFi 的路由可能被移除或不再被优先使用，这就会造成 WiFi 网络不可用的情况。</li></ul><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a><strong>解决方法</strong></h3><p>可以通过以下方式避免此类冲突：</p><ul><li><strong>确保两个网络的 IP 不同网段</strong>，如 WiFi 在 <code>192.168.0.x</code>、有线网络在 <code>192.168.1.x</code>。</li><li><strong>手动调整适配器优先级</strong>，让 WiFi 优先于有线网络，或调整默认路由。</li><li><strong>使用不同的 DNS 配置</strong>，保证两个网络的 DNS 服务器不会冲突。</li></ul><p>这种情况在系统默认的网络切换机制下是常见的，但可以通过手动配置适配器和网络优先级来实现并行连接。</p><h2 id="什么是跃点"><a href="#什么是跃点" class="headerlink" title="什么是跃点?"></a>什么是跃点?</h2><p>“跃点”（Hop）是网络中数据从一个设备（通常是路由器或交换机）传递到下一个设备的过程。每经过一个设备就算一个“跃点”。跃点数量用于衡量数据在网络中的传输路径长度，从发送方到接收方需要经过多少个中间设备。</p><h3 id="关键点："><a href="#关键点：" class="headerlink" title="关键点："></a>关键点：</h3><ol><li><p><strong>定义</strong>：跃点指的是数据在网络中从一个节点（例如路由器）传递到下一个节点的过程。</p></li><li><p><strong>用途</strong>：跃点数可以帮助判断网络路径的长短和延迟。网络管理工具如 <code>tracert</code> 或 <code>traceroute</code> 命令会显示从起始设备到目的设备的跃点数。</p></li><li><p><strong>TTL（Time to Live）与跃点</strong>：每个数据包都有一个 TTL 值，表示数据包在网络中允许的最大跃点数，每经过一个跃点这个值就减1。当 TTL 变为0时，数据包会被丢弃，防止它在网络中无限循环。</p></li></ol><h3 id="跃点数的意义："><a href="#跃点数的意义：" class="headerlink" title="跃点数的意义："></a>跃点数的意义：</h3><ul><li><strong>路由效率</strong>：跃点数越少，通常意味着数据的传输路径越短，网络的传输效率越高。</li><li><strong>故障排查</strong>：通过检查跃点数，可以定位网络问题发生在哪个设备上。</li></ul><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>假设你在一个公司网络内访问外部服务器，数据包可能会经过：</p><ul><li>内部路由器 -&gt; 防火墙 -&gt; ISP 路由器 -&gt; 若干个中间网络路由 -&gt; 目标服务器。</li></ul><p>假如经过了7个节点到达目标服务器，这7个节点就是7个跃点。</p><h2 id="无线网络的跃点数为什么会是自动的呢？它不应该是通过无线通讯直接连接到无线路由器的吗-跃点数应该是固定的啊-为什么会是自动跃点？"><a href="#无线网络的跃点数为什么会是自动的呢？它不应该是通过无线通讯直接连接到无线路由器的吗-跃点数应该是固定的啊-为什么会是自动跃点？" class="headerlink" title="无线网络的跃点数为什么会是自动的呢？它不应该是通过无线通讯直接连接到无线路由器的吗?跃点数应该是固定的啊?为什么会是自动跃点？"></a>无线网络的跃点数为什么会是自动的呢？它不应该是通过无线通讯直接连接到无线路由器的吗?跃点数应该是固定的啊?为什么会是自动跃点？</h2><p>无线网络的跃点数设为“自动”是因为跃点数不仅考虑物理连接的直接性（即从设备到无线路由器的路径），还考虑整体网络路径的复杂性和灵活性。以下是为什么会存在“自动”跃点数设置的主要原因：</p><ol><li><p><strong>动态网络路径</strong>：<br>尽管设备是直接通过无线电波连接到无线路由器，但数据包的最终传输路径可能会随着网络环境的变化而不同。例如，在连接到互联网的路径上，数据可能会经过多个不同的网络节点、交换机和路由器，这些路径的跃点数可能因网络状态变化而不同。</p></li><li><p><strong>多网关场景</strong>：<br>在一些网络配置中，尤其是公司或大型局域网中，可能存在多个路由器或网关，这些路由器或网关有不同的网络路径选择。如果有多个路由器提供了不同的默认网关，跃点数会用来帮助系统选择“更优”的路径。</p></li><li><p><strong>自动优化</strong>：<br>操作系统的“自动”跃点数配置可以动态调整网络优先级，以便根据网络状况（如路由器负载、网络流量等）选择合适的路由。这种自动化能够让系统在不同的网络环境下做出更智能的选择，以获得更好的连接稳定性和速度。</p></li><li><p><strong>灵活性与兼容性</strong>：<br>自动跃点允许设备在不固定网络架构的环境中（如加入新路由器、扩展网络）灵活适配。这种灵活性在移动设备上尤为重要，因为它们可能随时切换不同的网络或路由路径。</p></li></ol><h3 id="固定跃点数的情况"><a href="#固定跃点数的情况" class="headerlink" title="固定跃点数的情况"></a>固定跃点数的情况</h3><p>在某些简单网络（例如只有一个路由器的家庭网络）中，跃点数确实可以被认为是固定的，因为连接路径唯一且简明。但在更复杂的网络环境中，自动跃点数可以提高网络适应性。</p><h2 id="是不是可以通过设置跃点数的方法来给Windows上的所有网络适配器设置优先级-手动设置网络适配器的跃点数是否会导致网络连接出现问题"><a href="#是不是可以通过设置跃点数的方法来给Windows上的所有网络适配器设置优先级-手动设置网络适配器的跃点数是否会导致网络连接出现问题" class="headerlink" title="是不是可以通过设置跃点数的方法来给Windows上的所有网络适配器设置优先级?手动设置网络适配器的跃点数是否会导致网络连接出现问题?"></a>是不是可以通过设置跃点数的方法来给Windows上的所有网络适配器设置优先级?手动设置网络适配器的跃点数是否会导致网络连接出现问题?</h2><p>是的，通过调整“跃点数”（即 TTL，Time to Live）或“接口跃点数” (<code>Interface Metric</code>) 可以设置 Windows 上不同网络适配器的优先级。设置优先级通常是为了控制在多网络环境下哪个网络适配器应当被优先使用。对于网络适配器的优先级，<code>Interface Metric</code> 是直接影响优先选择的指标，比 TTL 更常用于适配器优先级配置。</p><h3 id="设置网络适配器优先级"><a href="#设置网络适配器优先级" class="headerlink" title="设置网络适配器优先级"></a>设置网络适配器优先级</h3><p>在 Windows 中，<code>Interface Metric</code> 是网络适配器的成本值，Windows 会优先选择成本较低的接口进行数据传输。因此，您可以通过以下方式手动设置优先级：</p><ol><li><p>打开 <strong>网络连接</strong>：</p><ul><li>Win + R，输入 <code>ncpa.cpl</code>，回车。</li></ul></li><li><p>选择目标网络适配器，右键点击选择 <strong>属性</strong>。</p></li><li><p>在 <strong>Internet 协议版本 4 (TCP&#x2F;IPv4)</strong> 中点击 <strong>属性</strong>，然后点击 <strong>高级</strong>。</p></li><li><p>在“高级 TCP&#x2F;IP 设置”中，勾选 <strong>自动跃点数</strong> 的勾选框，输入一个较低的值（例如 1 或 2）以增加优先级，输入较高的值以降低优先级。</p></li></ol><h3 id="手动设置-Interface-Metric-的注意事项"><a href="#手动设置-Interface-Metric-的注意事项" class="headerlink" title="手动设置 Interface Metric 的注意事项"></a>手动设置 <code>Interface Metric</code> 的注意事项</h3><ol><li><p><strong>优先级冲突</strong>：如果多个适配器被设置为相同的 <code>Interface Metric</code> 值，Windows 可能会随机选择一个适配器来发送流量，这可能会导致意外的网络切换或连接不稳定。</p></li><li><p><strong>网络连接延迟</strong>：如果将主要适配器的 <code>Interface Metric</code> 设置得过高，可能导致系统默认选择次要或速度较慢的网络适配器，影响网络性能。</p></li><li><p><strong>网络配置复杂性</strong>：手动调整适配器的优先级和跃点数可能导致在复杂的多网环境中不易追踪的问题，特别是在频繁切换网络或使用 VPN 时，配置不当可能造成连接失败或不稳定。</p></li></ol><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>手动调整网络适配器的 <code>Interface Metric</code> 是一种可靠的方法来设置优先级，适用于多网络环境。只要合理配置，通常不会导致网络连接问题，但建议测试每个适配器的设置，以确保不会影响到网络连接的稳定性和速度。</p><h2 id="我是否可以认为，172-21-10-1这个网关地址就是我在无线网络连接的路由器的公网ip地址"><a href="#我是否可以认为，172-21-10-1这个网关地址就是我在无线网络连接的路由器的公网ip地址" class="headerlink" title="我是否可以认为，172.21.10.1这个网关地址就是我在无线网络连接的路由器的公网ip地址?"></a>我是否可以认为，172.21.10.1这个网关地址就是我在无线网络连接的路由器的公网ip地址?</h2><p>不完全是这样。</p><p><strong><code>172.21.10.1</code> 并不是你的路由器的公网 IP 地址</strong>。它只是你本地网络（局域网）内的一个<strong>私有 IP 地址</strong>，是你设备在局域网内连接到路由器的入口。以下是它的意义和作用：</p><ol><li><p><strong>局域网内的路由器地址</strong>：<code>172.21.10.1</code> 是你局域网中（无线网络）路由器的网关 IP 地址，允许局域网中的设备通过它连接到外部网络。你的设备通过这个地址来进行网络请求，并由路由器转发这些请求到外部网络（如互联网）。</p></li><li><p><strong>私有 IP 地址 vs 公网 IP 地址</strong>：<code>172.21.10.1</code> 属于<strong>私有 IP 地址范围</strong>（172.16.0.0 - 172.31.255.255），这类地址只能在局域网内使用，不能直接在互联网中访问。你的路由器实际上有两个 IP 地址：</p><ul><li><strong>局域网（LAN）IP</strong>：在你的局域网中提供给设备使用，例如 <code>172.21.10.1</code>。</li><li><strong>广域网（WAN）IP</strong>（公网 IP）：这是路由器连接到互联网时向外部展示的 IP 地址，通常是由你的 ISP（互联网服务提供商）分配的，你可以用在线服务来查看该地址（如“我的 IP”查询工具）。</li></ul></li><li><p><strong>网络地址转换（NAT）</strong>：你的路由器会使用 NAT（网络地址转换）技术，把你局域网内设备的私有 IP 地址（如 <code>172.21.10.67</code>）映射到一个公网 IP 地址，从而让多个设备共享同一个公网 IP 与互联网通信。</p></li></ol><p>所以，总结来说，**<code>172.21.10.1</code> 是你路由器在局域网内的网关地址，并不是路由器的公网 IP 地址**。你的实际公网 IP 地址是分配给你路由器的 WAN 端口的，用于互联网连接，但它和局域网内的私有 IP 地址是不同的。</p><h2 id="我还见过很多局域网内的地址是192-168-xx开头的地址，这好像不在你所说的私有IP地址范围中，这是什么情况"><a href="#我还见过很多局域网内的地址是192-168-xx开头的地址，这好像不在你所说的私有IP地址范围中，这是什么情况" class="headerlink" title="我还见过很多局域网内的地址是192.168.xx开头的地址，这好像不在你所说的私有IP地址范围中，这是什么情况?"></a>我还见过很多局域网内的地址是192.168.xx开头的地址，这好像不在你所说的私有IP地址范围中，这是什么情况?</h2><p>实际上，**<code>192.168.xx.xx</code> 开头的 IP 地址也是私有 IP 地址<strong>，属于</strong>私有 IP 地址范围**的一部分。根据 <a href="https://tools.ietf.org/html/rfc1918">RFC 1918</a>，私有 IP 地址范围有三段，每段都是专门保留给局域网使用的，不会在公网中出现：</p><ol><li><strong>10.0.0.0 - 10.255.255.255</strong>（10.0.0.0&#x2F;8）：适用于大规模的私有网络（例如大型企业内部网络）。</li><li><strong>172.16.0.0 - 172.31.255.255</strong>（172.16.0.0&#x2F;12）：适用于中等规模的私有网络。</li><li><strong>192.168.0.0 - 192.168.255.255</strong>（192.168.0.0&#x2F;16）：适用于小型私有网络，也是最常见的家用和小型办公室网络范围。</li></ol><p>其中，**<code>192.168.xx.xx</code>** 是我们最常见的局域网 IP 地址范围，通常用于家庭路由器和小型办公室网络。例如，家庭网络中经常使用的网段是 <code>192.168.0.0/24</code> 或 <code>192.168.1.0/24</code>，这样可以分配 <code>192.168.0.1</code> 到 <code>192.168.0.254</code> 或 <code>192.168.1.1</code> 到 <code>192.168.1.254</code> 的 IP 地址给设备。</p><h3 id="为什么会有不同的私有-IP-范围？"><a href="#为什么会有不同的私有-IP-范围？" class="headerlink" title="为什么会有不同的私有 IP 范围？"></a>为什么会有不同的私有 IP 范围？</h3><p>这些私有 IP 地址范围是为了满足不同规模的网络需求，使用范围较小的段（如 <code>192.168.xx.xx</code>）可以减少地址管理的复杂性。因此，路由器和网络管理员可以根据网络规模和用途选择不同的私有 IP 地址段。</p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>192.168.xx.xx</strong> 也是一个私有 IP 地址范围，常用于家庭和小型局域网。</li><li>所有 <strong>10.x.x.x</strong>、<strong>172.16.x.x - 172.31.x.x</strong> 和 <strong>192.168.x.x</strong> 的 IP 地址都是私有 IP 地址，只能在局域网内部使用，不能直接在互联网中使用。</li><li>路由器会用 NAT 把局域网的私有 IP 转换成一个公共 IP，以连接到互联网。</li></ul><h2 id="我发现你在每段网络ip地址的范围后面括号中还有（192-168-0-0-16）这样的内容，这是什么意思"><a href="#我发现你在每段网络ip地址的范围后面括号中还有（192-168-0-0-16）这样的内容，这是什么意思" class="headerlink" title="我发现你在每段网络ip地址的范围后面括号中还有（192.168.0.0&#x2F;16）这样的内容，这是什么意思?"></a>我发现你在每段网络ip地址的范围后面括号中还有（192.168.0.0&#x2F;16）这样的内容，这是什么意思?</h2><p>括号中的 <strong><code>192.168.0.0/16</code></strong> 是一种表示 IP 地址范围的<strong>网络前缀表示法</strong>，称为 <strong>CIDR（Classless Inter-Domain Routing，无类别域间路由）表示法</strong>。在这种表示法中：</p><ul><li><strong>前面的 IP 地址</strong>（如 <code>192.168.0.0</code>）表示<strong>网络的起始地址</strong>。</li><li>斜杠后的数字 <strong>&#x2F;16</strong> 表示<strong>网络前缀长度</strong>，指明了 IP 地址中有多少位是固定的，用于定义网络部分。</li></ul><p>在 IP 地址（IPv4）的表示中，地址共有 <strong>32 位</strong>，每一位可以是 0 或 1。<code>/16</code> 意味着<strong>前 16 位被用作网络前缀</strong>，剩下的 16 位可以用来分配主机地址。</p><h3 id="举例说明-192-168-0-0-16"><a href="#举例说明-192-168-0-0-16" class="headerlink" title="举例说明 192.168.0.0/16"></a>举例说明 <code>192.168.0.0/16</code></h3><ol><li><p><strong>网络前缀</strong>：<code>192.168.0.0/16</code> 表示前 16 位是固定的，网络范围是 <code>192.168.x.x</code>，可以分配给局域网的设备。</p></li><li><p><strong>主机部分</strong>：剩下的 16 位可以用来分配主机地址，这意味着 <code>192.168.0.0/16</code> 包含了从 <strong><code>192.168.0.0</code> 到 <code>192.168.255.255</code></strong> 的所有 IP 地址。这共计 <strong>2^16 &#x3D; 65536</strong> 个地址。</p></li></ol><h3 id="其他示例"><a href="#其他示例" class="headerlink" title="其他示例"></a>其他示例</h3><ul><li><code>10.0.0.0/8</code> 表示前 8 位是网络前缀，因此地址范围是 **<code>10.0.0.0</code> 到 <code>10.255.255.255</code>**，共计 <strong>2^24 &#x3D; 16777216</strong> 个地址。</li><li><code>172.16.0.0/12</code> 表示前 12 位是网络前缀，因此地址范围是 **<code>172.16.0.0</code> 到 <code>172.31.255.255</code>**，共计 <strong>2^20 &#x3D; 1048576</strong> 个地址。</li></ul><h3 id="为什么使用-CIDR-表示法"><a href="#为什么使用-CIDR-表示法" class="headerlink" title="为什么使用 CIDR 表示法"></a>为什么使用 CIDR 表示法</h3><p>CIDR 表示法的好处在于可以灵活划分网络，而不受传统 A 类、B 类、C 类地址分类的限制。它让网络管理员可以更精确地分配地址，减少地址浪费，增强了 IP 地址管理的灵活性。</p><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>CIDR 表示法</strong>中的 <code>/n</code> 表示网络前缀的长度，即 IP 地址中有多少位是固定的网络部分。</li><li>例如，<code>192.168.0.0/16</code> 表示前 16 位是网络部分，后 16 位用于分配主机。</li><li>CIDR 使网络划分更灵活，允许更有效地管理 IP 地址。</li></ul><h2 id="fe80-ab30-c6f7-f5b0-59d-8-ipv6地址为什么是这么表示的？这是十六进制数吗"><a href="#fe80-ab30-c6f7-f5b0-59d-8-ipv6地址为什么是这么表示的？这是十六进制数吗" class="headerlink" title="fe80::ab30:c6f7:f5b0:59d%8 ipv6地址为什么是这么表示的？这是十六进制数吗?"></a>fe80::ab30:c6f7:f5b0:59d%8 ipv6地址为什么是这么表示的？这是十六进制数吗?</h2><p>是的，IPv6 地址的表示确实使用了<strong>十六进制</strong>。IPv6 地址采用 128 位的地址长度，为了更简洁地表示这些地址，IPv6 使用了<strong>冒号分隔的十六进制</strong>表示法。</p><h3 id="IPv6-地址表示法解析"><a href="#IPv6-地址表示法解析" class="headerlink" title="IPv6 地址表示法解析"></a>IPv6 地址表示法解析</h3><p>一个完整的 IPv6 地址包含 128 位，分为 8 组，每组 16 位，每组之间用冒号 <code>:</code> 分隔。每组的 16 位用<strong>四个十六进制数</strong>来表示。</p><p>例如，IPv6 地址 <code>fe80::ab30:c6f7:f5b0:59d%8</code> 可以分为以下部分：</p><ul><li><strong>fe80</strong> : <strong>0000</strong> : <strong>0000</strong> : <strong>0000</strong> : <strong>ab30</strong> : <strong>c6f7</strong> : <strong>f5b0</strong> : <strong>0059</strong></li></ul><h3 id="地址缩写规则"><a href="#地址缩写规则" class="headerlink" title="地址缩写规则"></a>地址缩写规则</h3><p>为了简化表示，IPv6 允许几种缩写规则：</p><ol><li><p><strong>去掉前导零</strong>：每一组的十六进制数前导零可以省略。例如，<code>0059</code> 可以写作 <code>59</code>。</p></li><li><p><strong>双冒号 <code>::</code> 表示连续的零</strong>：如果一段地址中有连续的 <code>0000</code>，可以用双冒号 <code>::</code> 来代替。但双冒号在同一个地址中只能使用一次，以避免歧义。例如：</p><ul><li><code>fe80:0:0:0:ab30:c6f7:f5b0:59d</code> 可以写成 <code>fe80::ab30:c6f7:f5b0:59d</code>。</li></ul><p>在这个例子中，<code>::</code> 表示有 3 组 <code>0000</code>。</p></li><li><p><strong>范围指示符 <code>%</code><strong>：在本地链路（link-local）IPv6 地址中，<code>%</code> 后面的数字 <code>8</code> 表示</strong>网络接口标识符</strong>，即在该设备上用于区分不同的网络接口。例如，在 <code>fe80::ab30:c6f7:f5b0:59d%8</code> 中，<code>%8</code> 表示这是第 8 个网络接口。</p></li></ol><h3 id="IPv6-地址的组成"><a href="#IPv6-地址的组成" class="headerlink" title="IPv6 地址的组成"></a>IPv6 地址的组成</h3><p>IPv6 地址由两部分组成：</p><ol><li><strong>网络前缀</strong>：前 64 位通常用于指定网络部分。</li><li><strong>主机标识</strong>：后 64 位通常用于标识特定设备（主机）在网络中的唯一性。</li></ol><p>例如，<code>fe80::/64</code> 是本地链路地址的网络前缀，而后面的部分（<code>ab30:c6f7:f5b0:59d</code>）用来唯一标识特定主机。</p><h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><ul><li>IPv6 地址使用 <strong>128 位</strong>，每 16 位一组，用十六进制表示。</li><li>IPv6 地址的表示允许缩写，如省略前导零和使用双冒号 <code>::</code> 表示连续的零。</li><li><code>%</code> 后面的数字表示<strong>网络接口标识符</strong>，仅用于本地链路地址。</li></ul><h2 id="你的设备在网络中的地址是-172-21-10-67，子网掩码是-255-255-255-0。这个子网掩码意味着-172-21-10-x-这一整个范围的IP地址都在同一个子网中。-你上面提到了这样的内容，为什么有这个子网掩码意味着这个信息呢-子网掩码又是什么意思"><a href="#你的设备在网络中的地址是-172-21-10-67，子网掩码是-255-255-255-0。这个子网掩码意味着-172-21-10-x-这一整个范围的IP地址都在同一个子网中。-你上面提到了这样的内容，为什么有这个子网掩码意味着这个信息呢-子网掩码又是什么意思" class="headerlink" title="你的设备在网络中的地址是 172.21.10.67，子网掩码是 255.255.255.0。这个子网掩码意味着 172.21.10.x 这一整个范围的IP地址都在同一个子网中。 你上面提到了这样的内容，为什么有这个子网掩码意味着这个信息呢?子网掩码又是什么意思?"></a>你的设备在网络中的地址是 172.21.10.67，子网掩码是 255.255.255.0。这个子网掩码意味着 172.21.10.x 这一整个范围的IP地址都在同一个子网中。 你上面提到了这样的内容，为什么有这个子网掩码意味着这个信息呢?子网掩码又是什么意思?</h2><p>子网掩码（subnet mask）是一种用于区分<strong>网络部分</strong>和<strong>主机部分</strong>的地址标识。它告诉设备哪一部分 IP 地址用于表示网络，哪一部分用于标识网络内的设备（主机）。</p><h3 id="子网掩码的原理"><a href="#子网掩码的原理" class="headerlink" title="子网掩码的原理"></a>子网掩码的原理</h3><p>在 IPv4 地址中（例如 172.21.10.67），一个 IP 地址由 32 位组成，通常分成 4 组，每组 8 位（1 个字节），用十进制表示成 <code>x.x.x.x</code> 的形式。</p><p>子网掩码也是一个 32 位的数字，它用来遮蔽 IP 地址的前几位以表示网络部分。子网掩码中的每个 <code>1</code> 表示网络部分，每个 <code>0</code> 表示主机部分。例如，<code>255.255.255.0</code> 的二进制形式是 <code>11111111.11111111.11111111.00000000</code>，表示前 24 位（即前三组 8 位）属于网络部分，最后 8 位属于主机部分。</p><h4 id="例子解释"><a href="#例子解释" class="headerlink" title="例子解释"></a>例子解释</h4><p>对于 IP 地址 <code>172.21.10.67</code> 和子网掩码 <code>255.255.255.0</code>，转换为二进制为：</p><ul><li>IP 地址：<code>10101100.00010101.00001010.01000011</code>  </li><li>子网掩码：<code>11111111.11111111.11111111.00000000</code></li></ul><p>根据子网掩码的设置，前 24 位是网络部分，后 8 位是主机部分。因此：</p><ul><li><strong>网络部分</strong>：<code>10101100.00010101.00001010</code>（即 <code>172.21.10</code>）</li><li><strong>主机部分</strong>：<code>01000011</code>（即 <code>67</code>）</li></ul><p>这意味着在 <code>172.21.10.x</code> 这个范围内的所有 IP 地址都属于同一个子网，因为它们共享相同的网络部分（前 24 位）。</p><h3 id="子网掩码的作用"><a href="#子网掩码的作用" class="headerlink" title="子网掩码的作用"></a>子网掩码的作用</h3><ol><li><p><strong>标识同一子网的范围</strong>：子网掩码决定了网络的大小和结构。例如，<code>255.255.255.0</code> 表示同一个子网内有 256 个 IP 地址（从 <code>172.21.10.0</code> 到 <code>172.21.10.255</code>），其中 <code>172.21.10.1</code> 到 <code>172.21.10.254</code> 可以分配给主机，而 <code>172.21.10.0</code> 是网络地址，<code>172.21.10.255</code> 是广播地址。</p></li><li><p><strong>帮助设备区分本地和外部网络</strong>：设备在通信时，会使用子网掩码来判断目标 IP 是否在同一子网内。如果是，则可以直接通信；如果不在同一子网内，则数据会通过网关发送到外部网络。</p></li></ol><h3 id="子网掩码的简写（CIDR）"><a href="#子网掩码的简写（CIDR）" class="headerlink" title="子网掩码的简写（CIDR）"></a>子网掩码的简写（CIDR）</h3><p>子网掩码也可以用一种简写形式，称为 CIDR 表示法（Classless Inter-Domain Routing）。例如，<code>255.255.255.0</code> 可以表示为 <code>/24</code>，因为它有 24 位是 <code>1</code>。同理：</p><ul><li><code>255.255.255.0</code> &#x3D; <code>/24</code></li><li><code>255.255.0.0</code> &#x3D; <code>/16</code></li><li><code>255.0.0.0</code> &#x3D; <code>/8</code></li></ul><h3 id="通过子网掩码得知同一子网范围的原因"><a href="#通过子网掩码得知同一子网范围的原因" class="headerlink" title="通过子网掩码得知同一子网范围的原因"></a>通过子网掩码得知同一子网范围的原因</h3><p>因为子网掩码中的 <code>1</code> 位指定了 IP 地址的网络部分，同一网络的设备需要具有相同的网络部分（即相同的子网掩码和网络地址），才能被视为在同一子网中。例如：</p><ul><li>IP 地址 <code>172.21.10.67</code> 和 <code>172.21.10.100</code> 在子网掩码 <code>255.255.255.0</code> 下同属一个子网，因为它们的网络部分（<code>172.21.10</code>）相同。</li></ul><p>因此，有了子网掩码 <code>255.255.255.0</code>，我们就知道 IP 地址 <code>172.21.10.x</code> 属于同一子网。</p><h2 id="那么，如果子网掩码这么写255-255-200-0是不是意味着有17151个ip地址分配给了局域网中的设备，其余地址分配给了网络"><a href="#那么，如果子网掩码这么写255-255-200-0是不是意味着有17151个ip地址分配给了局域网中的设备，其余地址分配给了网络" class="headerlink" title="那么，如果子网掩码这么写255.255.200.0是不是意味着有17151个ip地址分配给了局域网中的设备，其余地址分配给了网络?"></a>那么，如果子网掩码这么写255.255.200.0是不是意味着有17151个ip地址分配给了局域网中的设备，其余地址分配给了网络?</h2><p>其实，子网掩码写成 <code>255.255.200.0</code> 并不会产生你所说的 17151 个 IP 地址可分配。这种子网掩码并不符合标准的连续 <code>1</code> 位和 <code>0</code> 位的规则。</p><h3 id="为什么子网掩码必须是连续的-1-和-0"><a href="#为什么子网掩码必须是连续的-1-和-0" class="headerlink" title="为什么子网掩码必须是连续的 1 和 0"></a>为什么子网掩码必须是连续的 <code>1</code> 和 <code>0</code></h3><p>在 IPv4 中，子网掩码需要由连续的 <code>1</code> 和连续的 <code>0</code> 组成。像 <code>255.255.200.0</code> 这种子网掩码，转换为二进制是 <code>11111111.11111111.11001000.00000000</code>，<code>1</code> 和 <code>0</code> 并不连续，这样的子网掩码会导致网络计算上的问题。因此，这样的子网掩码并不被支持，也不会产生有效的 IP 地址范围。</p><h3 id="标准子网掩码格式"><a href="#标准子网掩码格式" class="headerlink" title="标准子网掩码格式"></a>标准子网掩码格式</h3><p>标准的子网掩码格式只允许使用以下形式：</p><ul><li><code>255.0.0.0</code> (即 <code>/8</code>)</li><li><code>255.255.0.0</code> (即 <code>/16</code>)</li><li><code>255.255.255.0</code> (即 <code>/24</code>)</li><li>以及其他以 <code>1</code> 位连续、<code>0</code> 位连续的格式，比如 <code>255.255.252.0</code> (即 <code>/22</code>)</li></ul><h3 id="如何计算一个子网的-IP-地址数量"><a href="#如何计算一个子网的-IP-地址数量" class="headerlink" title="如何计算一个子网的 IP 地址数量"></a>如何计算一个子网的 IP 地址数量</h3><p>如果使用标准的子网掩码，可以用以下公式计算同一子网内的可用 IP 地址数：<br>$$<br>\text{可用 IP 地址数} &#x3D; 2^{(32 - \text{子网掩码中的1的数量})} - 2<br>$$<br>例如：</p><ul><li><strong><code>255.255.255.0</code></strong> (<code>/24</code>)：32 - 24 &#x3D; 8，所以可用 IP 数是 ( 2^8 - 2 &#x3D; 256 - 2 &#x3D; 254 )</li><li><strong><code>255.255.252.0</code></strong> (<code>/22</code>)：32 - 22 &#x3D; 10，所以可用 IP 数是 ( 2^{10} - 2 &#x3D; 1024 - 2 &#x3D; 1022 )</li></ul><h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>子网掩码必须由连续的 <code>1</code> 和 <code>0</code> 位组成，像 <code>255.255.200.0</code> 这种格式是无效的。有效的子网掩码会产生固定数量的 IP 地址范围，具体数量取决于子网掩码的位数。</p><h2 id="WebSocket-是什么？"><a href="#WebSocket-是什么？" class="headerlink" title="WebSocket 是什么？"></a>WebSocket 是什么？</h2><p>WebSocket 是一种在单个 TCP 连接上进行<strong>全双工通信</strong>的网络协议。它允许服务器和客户端之间进行持久性的、双向的实时数据交换。</p><p>可以把它想象成在客户端（比如你的浏览器）和服务器之间建立了一条专门的“电话线”。一旦这条线接通，双方都可以随时通过这条线互相发送信息，而不需要每次都重新“拨号”（像传统的HTTP请求那样）。</p><h3 id="与传统-HTTP-的主要区别："><a href="#与传统-HTTP-的主要区别：" class="headerlink" title="与传统 HTTP 的主要区别："></a>与传统 HTTP 的主要区别：</h3><ol><li><p>**持久连接 (Persistent Connection)**：</p><ul><li><strong>HTTP</strong>: 通常是“请求-响应”模式。客户端发送一个请求，服务器响应后连接就可能关闭（HTTP&#x2F;1.0）或在一段时间后关闭（HTTP&#x2F;1.1 Keep-Alive）。如果客户端需要新数据，必须再次发起请求。</li><li><strong>WebSocket</strong>: 一旦建立连接（通过一个初始的HTTP握手），连接会保持打开状态，直到客户端或服务器明确关闭它。</li></ul></li><li><p>**全双工通信 (Full-Duplex Communication)**：</p><ul><li><strong>HTTP</strong>: 基本上是半双工的。客户端请求，服务器响应。服务器不能主动向客户端发送数据，除非客户端先发起请求（有一些变通方法如长轮询、SSE，但WebSocket更直接）。</li><li><strong>WebSocket</strong>: 客户端和服务器都可以独立地、同时地向对方发送数据。服务器可以主动推送信息给客户端，客户端也可以随时发送信息给服务器。</li></ul></li><li><p>**低延迟 (Low Latency)**：</p><ul><li>由于连接是持久的，并且数据帧的头部开销比HTTP小得多，WebSocket 在数据传输时延迟更低。这对于需要快速响应的应用（如在线游戏、实时聊天）非常重要。</li></ul></li><li><p>**协议开销小 (Reduced Overhead)**：</p><ul><li>初始连接建立后，后续的数据帧头部信息非常小（通常只有几个字节），而HTTP请求每次都需要携带完整的头部信息，开销较大。</li></ul></li></ol><h3 id="WebSocket-如何工作？"><a href="#WebSocket-如何工作？" class="headerlink" title="WebSocket 如何工作？"></a>WebSocket 如何工作？</h3><ol><li><p>**握手 (Handshake)**：</p><ul><li>WebSocket 连接的建立始于一个标准的 HTTP 请求，这个请求包含一些特殊的头部信息（如 <code>Upgrade: websocket</code> 和 <code>Connection: Upgrade</code>）。</li><li>如果服务器支持 WebSocket，它会响应一个 HTTP 101 Switching Protocols 状态码，表示同意将连接从 HTTP 升级到 WebSocket。</li><li>一旦握手成功，底层的 TCP 连接就被用于 WebSocket 通信了，不再遵循 HTTP 协议。</li></ul></li><li><p>**数据传输 (Data Transfer)**：</p><ul><li>握手成功后，客户端和服务器就可以通过这个连接双向发送 WebSocket 数据帧。</li><li>数据可以是文本（通常是UTF-8编码）或二进制数据。</li></ul></li><li><p>**关闭连接 (Closing Connection)**：</p><ul><li>任何一方都可以发起关闭连接的请求。</li></ul></li></ol><h3 id="WebSocket-的常见应用场景："><a href="#WebSocket-的常见应用场景：" class="headerlink" title="WebSocket 的常见应用场景："></a>WebSocket 的常见应用场景：</h3><ul><li><strong>实时聊天应用</strong>：如微信网页版、Slack等，消息可以即时推送到所有客户端。</li><li><strong>在线多人游戏</strong>：玩家的动作和游戏状态需要快速同步。</li><li><strong>实时数据仪表盘</strong>：如股票行情、系统监控数据等需要实时更新。</li><li><strong>协作编辑工具</strong>：如 Google Docs，多个用户可以同时编辑文档并看到对方的修改。</li><li><strong>通知系统</strong>：服务器可以即时向客户端推送通知。</li><li><strong>体育赛事直播更新</strong>：实时更新比分和赛况。</li></ul><h3 id="总结-WebSocket-的优势："><a href="#总结-WebSocket-的优势：" class="headerlink" title="总结 WebSocket 的优势："></a>总结 WebSocket 的优势：</h3><ul><li><strong>真正的双向通信</strong>：服务器可以主动向客户端推送数据。</li><li><strong>低延迟</strong>：快速的数据交换。</li><li><strong>减少网络流量</strong>：头部开销小。</li><li><strong>保持连接状态</strong>：避免了重复建立连接的开销。</li></ul><p>总而言之，WebSocket 提供了一种高效的方式来实现客户端和服务器之间的实时、双向通信，是构建现代交互式Web应用的强大工具。</p><p>​        </p><h2 id="掩码-Mask-是什么意思"><a href="#掩码-Mask-是什么意思" class="headerlink" title="掩码(Mask)是什么意思"></a>掩码(Mask)是什么意思</h2><ul><li><h3 id="子网掩码（Subnet-Mask）"><a href="#子网掩码（Subnet-Mask）" class="headerlink" title="子网掩码（Subnet Mask）"></a>子网掩码（Subnet Mask）</h3><h4 id="用途："><a href="#用途：" class="headerlink" title="用途："></a>用途：</h4><p>子网掩码用于区分 IP 地址中的网络部分和主机部分。它与 IP 地址结合使用，以确定一个特定的 IP 地址属于哪个子网。</p><h4 id="表示方式："><a href="#表示方式：" class="headerlink" title="表示方式："></a>表示方式：</h4><p>子网掩码通常以点分十进制形式表示，例如：255.255.255.0。</p><h4 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h4><p>子网掩码中的每个“1”表示网络部分，每个“0”表示主机部分。例如，子网掩码 255.255.255.0 转换为二进制是 11111111.11111111.11111111.00000000，这表示前24位是网络部分，后8位是主机部分。</p><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><p>假设 IP 地址是 192.168.1.10，子网掩码是 255.255.255.0，则网络部分是 192.168.1，主机部分是 10。</p></li><li><h3 id="位掩码（Bit-Mask）"><a href="#位掩码（Bit-Mask）" class="headerlink" title="位掩码（Bit Mask）"></a>位掩码（Bit Mask）</h3><h4 id="用途：-1"><a href="#用途：-1" class="headerlink" title="用途："></a>用途：</h4><p>在编程中，位掩码用于<strong>对二进制数据进行位级操作</strong>，如设置、清除、切换特定位或检查特定位的状态。</p><h4 id="表示方式：-1"><a href="#表示方式：-1" class="headerlink" title="表示方式："></a>表示方式：</h4><p>位掩码通常以二进制或十六进制形式表示。例如，位掩码 0xFF 表示二进制的 11111111。</p><h4 id="工作原理：-1"><a href="#工作原理：-1" class="headerlink" title="工作原理："></a>工作原理：</h4><p>位掩码通过按位与、按位或、按位异或等操作，对目标数据进行位操作。</p><h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><p>假设有一个8位的数据 0b11001100（204 十进制），你想清除最低的4位。你可以使用位掩码 0b11110000（240 十进制），通过按位与操作实现：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">python复制代码data = <span class="hljs-number">0b11001100</span><br>mask = <span class="hljs-number">0b11110000</span><br>result = data &amp; mask  # 结果是 <span class="hljs-number">0b11000000</span><br></code></pre></td></tr></table></figure></li><li><h3 id="网络掩码（Network-Mask）"><a href="#网络掩码（Network-Mask）" class="headerlink" title="网络掩码（Network Mask）"></a>网络掩码（Network Mask）</h3><h4 id="用途：-2"><a href="#用途：-2" class="headerlink" title="用途："></a>用途：</h4><p>在网络配置中，网络掩码用于指定网络前缀的长度。与子网掩码类似，但常用于 CIDR（无类别域间路由）表示法。</p><h4 id="表示方式：-2"><a href="#表示方式：-2" class="headerlink" title="表示方式："></a>表示方式：</h4><p>网络掩码通常以斜杠加上网络前缀长度的形式表示，例如：192.168.1.0&#x2F;24。</p><h4 id="工作原理：-2"><a href="#工作原理：-2" class="headerlink" title="工作原理："></a>工作原理：</h4><p>网络掩码指定了网络前缀的长度，例如 &#x2F;24 表示网络前缀长度为 24 位，等价于子网掩码 255.255.255.0。</p></li><li><h3 id="ACL-掩码（Access-Control-List-Mask）"><a href="#ACL-掩码（Access-Control-List-Mask）" class="headerlink" title="ACL 掩码（Access Control List Mask）"></a>ACL 掩码（Access Control List Mask）</h3><h4 id="用途：-3"><a href="#用途：-3" class="headerlink" title="用途："></a>用途：</h4><p>在访问控制列表（ACL）中，掩码用于指定哪些位应该被检查，以确定访问权限。</p><h4 id="表示方式：-3"><a href="#表示方式：-3" class="headerlink" title="表示方式："></a>表示方式：</h4><p>ACL 掩码通常以二进制或十六进制表示，每一位表示相应权限位是否应该被检查。</p><h4 id="工作原理：-3"><a href="#工作原理：-3" class="headerlink" title="工作原理："></a>工作原理：</h4><p>ACL 掩码通过与权限位进行按位与操作，决定哪些位应该被应用。例如，掩码 0xF0 表示只检查高4位。</p></li></ul><h2 id="Wifi的SSID是什么"><a href="#Wifi的SSID是什么" class="headerlink" title="Wifi的SSID是什么?"></a>Wifi的SSID是什么?</h2><p>Wi-Fi 的 <strong>SSID</strong> 是指：</p><blockquote><p><strong>Service Set Identifier（服务集标识符）</strong></p></blockquote><p>简单来说，它就是：</p><blockquote><p>📡 <strong>你看到的 Wi-Fi 名称</strong></p></blockquote><hr><h2 id="✅-举例说明"><a href="#✅-举例说明" class="headerlink" title="✅ 举例说明"></a>✅ 举例说明</h2><p>假设你用手机连接 Wi-Fi 时，看到这些名称：</p><ul><li><code>Home_WiFi_5G</code></li><li><code>Starbucks_Free_WiFi</code></li><li><code>TP-Link_301</code></li><li><code>Johns-iPhone</code></li></ul><p>这些名字就是对应的 <strong>SSID</strong>。</p><hr><h2 id="🔧-更具体一些："><a href="#🔧-更具体一些：" class="headerlink" title="🔧 更具体一些："></a>🔧 更具体一些：</h2><ul><li>一个 Wi-Fi 路由器可以广播一个或多个 SSID；</li><li>你连接 Wi-Fi 时选择的就是 SSID；</li><li>每个 SSID 可以设置不同密码和权限（比如访客网络）；</li><li>SSID 最长可以是 <strong>32 个字符</strong>；</li><li>你可以选择 <strong>隐藏 SSID</strong>，这样设备就不会自动广播它，连接时需要手动输入。</li></ul><hr><h2 id="🧠-小知识："><a href="#🧠-小知识：" class="headerlink" title="🧠 小知识："></a>🧠 小知识：</h2><ul><li><strong>SSID ≠ MAC 地址</strong>：SSID 是网络名，MAC 是设备硬件地址；</li><li><strong>多个路由器可用相同 SSID</strong>：比如你家有多个 Mesh 节点，名称可以统一为 <code>MyHomeWiFi</code>；</li><li><strong>一个 SSID 下可以有多个 BSSID（MAC 地址）</strong>：BSSID 是每个接入点的唯一标识。</li></ul><hr><h2 id="那么，为什么手机上获取SSID需要位置权限呢"><a href="#那么，为什么手机上获取SSID需要位置权限呢" class="headerlink" title="那么，为什么手机上获取SSID需要位置权限呢?"></a>那么，为什么手机上获取SSID需要位置权限呢?</h2><p>这是一个常见但很容易让人疑惑的问题。简单来说：</p><blockquote><p>📱<strong>手机上获取 Wi-Fi SSID 需要位置权限，是因为操作系统（如 Android 和 iOS）认为 Wi-Fi SSID 能间接暴露你的地理位置。</strong></p></blockquote><hr><h2 id="🧠-详细解释如下："><a href="#🧠-详细解释如下：" class="headerlink" title="🧠 详细解释如下："></a>🧠 详细解释如下：</h2><h3 id="✅-1-Wi-Fi-SSID-是地理位置的“线索”"><a href="#✅-1-Wi-Fi-SSID-是地理位置的“线索”" class="headerlink" title="✅ 1. Wi-Fi SSID 是地理位置的“线索”"></a>✅ 1. <strong>Wi-Fi SSID 是地理位置的“线索”</strong></h3><p>Wi-Fi 热点（SSID）通常是<strong>固定的物理位置</strong>，比如：</p><ul><li>你家路由器的 SSID 是 <code>JohnHomeWiFi</code>，只出现在你家；</li><li>星巴克的 SSID 是 <code>Starbucks_Wifi</code>，只能在那家门店附近看到。</li></ul><p>因此：</p><blockquote><p>如果一个 App 能扫描到附近有哪些 SSID，它基本就能<strong>推测你在什么地方</strong>（甚至不需要 GPS）。</p></blockquote><hr><h3 id="✅-2-Google-Apple-建了“Wi-Fi-定位数据库”"><a href="#✅-2-Google-Apple-建了“Wi-Fi-定位数据库”" class="headerlink" title="✅ 2. Google&#x2F;Apple 建了“Wi-Fi 定位数据库”"></a>✅ 2. <strong>Google&#x2F;Apple 建了“Wi-Fi 定位数据库”</strong></h3><ul><li>Google 和 Apple 都维护了一个庞大的 <strong>SSID → 地理坐标</strong> 的数据库；</li><li>当手机搜索到某些 Wi-Fi 热点，即便你没有打开 GPS，也可以精确定位（就是所谓的 “Wi-Fi 定位”）；</li><li>所以系统默认把 <strong>扫描 Wi-Fi 热点</strong> 也视为 <strong>位置访问行为</strong>。</li></ul><hr><h3 id="✅-3-操作系统强制权限控制（从-Android-6-iOS-13-开始）"><a href="#✅-3-操作系统强制权限控制（从-Android-6-iOS-13-开始）" class="headerlink" title="✅ 3. 操作系统强制权限控制（从 Android 6 &#x2F; iOS 13 开始）"></a>✅ 3. <strong>操作系统强制权限控制（从 Android 6 &#x2F; iOS 13 开始）</strong></h3><table><thead><tr><th>平台</th><th>要求位置权限的行为</th><th>起始版本</th></tr></thead><tbody><tr><td>Android</td><td>获取当前连接的 SSID &#x2F; 扫描 Wi-Fi</td><td>Android 6.0（API 23）起</td></tr><tr><td>iOS</td><td>获取 SSID（即使只获取当前连接）</td><td>iOS 13 起</td></tr></tbody></table><blockquote><p>🛡️ 这不是因为硬件或 API 本身需要位置，而是<strong>操作系统为了保护隐私，强制开发者声明位置权限</strong>。</p></blockquote><hr><h2 id="❓那我只想获取“当前连接的-Wi-Fi-名称”，也要位置权限？"><a href="#❓那我只想获取“当前连接的-Wi-Fi-名称”，也要位置权限？" class="headerlink" title="❓那我只想获取“当前连接的 Wi-Fi 名称”，也要位置权限？"></a>❓那我只想获取“当前连接的 Wi-Fi 名称”，也要位置权限？</h2><p>是的，<strong>即便你只想获取当前连接的 Wi-Fi（不是扫描附近的），操作系统仍然要求位置权限</strong>，因为这同样具有定位潜力。</p><hr><h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ 总结</h2><table><thead><tr><th>问题</th><th>原因</th></tr></thead><tbody><tr><td>为什么获取 SSID 需要位置权限？</td><td>因为 Wi-Fi 名称能间接泄露用户位置</td></tr><tr><td>是技术需要吗？</td><td>❌不是，是出于隐私政策</td></tr><tr><td>哪些平台强制这么做？</td><td>Android 6+、iOS 13+</td></tr></tbody></table><hr><p>如果你是开发者，想要获取当前 Wi-Fi SSID，我可以给你一个适配平台和权限的示例代码（比如 Android Java&#x2F;Kotlin 或 iOS Swift）— 需要的话告诉我你的平台就行。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NPM基础</title>
    <link href="/2024/06/07/Node%20Package%20Manager%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/06/07/Node%20Package%20Manager%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>npm，即node package manager，node.js的包管理工具，其默认安装行为是将库安装到本地项目目录，以确保项目依赖的隔离性和一致性。如果想要在全局范围内使用某个库，可以使用全局安装:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm install <span class="hljs-literal">-g</span> &lt;package&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些编程经验记录</title>
    <link href="/2024/05/31/%E4%B8%80%E4%BA%9B%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/05/31/%E4%B8%80%E4%BA%9B%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<ul><li>越是来不及就越是不能能跑就行，不然后面会埋更大的坑</li><li>中断工作的时候要有一个中断的标注状态，以便于之后的自己接手</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Visual Studio知识点</title>
    <link href="/2024/05/24/Viual%20Studio%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2024/05/24/Viual%20Studio%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h4 id="怎么在VS里修改快捷键？"><a href="#怎么在VS里修改快捷键？" class="headerlink" title="怎么在VS里修改快捷键？"></a>怎么在VS里修改快捷键？</h4><p>设置-工具-环境-键盘</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Visual Studio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简写说明</title>
    <link href="/2024/05/17/%E7%AE%80%E5%86%99%E8%AF%B4%E6%98%8E/"/>
    <url>/2024/05/17/%E7%AE%80%E5%86%99%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><table><thead><tr><th>简写</th><th>全名</th><th>说明</th></tr></thead><tbody><tr><td>ALU</td><td>Arithmetic Logic Unit</td><td>算数逻辑单元</td></tr><tr><td>API</td><td>Application Programming Interface</td><td>应用程序编程接口</td></tr><tr><td>APN</td><td>Access Point Name</td><td>接入点名称</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><table><thead><tr><th>简写</th><th>全名</th><th>说明</th></tr></thead><tbody><tr><td>BEP</td><td>Block Exchange Protocol</td><td>区块交换协议</td></tr></tbody></table><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><table><thead><tr><th>简写</th><th>全名</th><th>说明</th></tr></thead><tbody><tr><td>CPU</td><td>Central Processing Unit</td><td>中央处理器</td></tr><tr><td>COM</td><td>Communication Port</td><td>串行通信端口</td></tr><tr><td>CRC</td><td>Cyclic Redundancy Check</td><td>循环冗余校验</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><table><thead><tr><th>简写</th><th>全名</th><th>说明</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><table><thead><tr><th>简写</th><th>全名</th><th>说明</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><table><thead><tr><th>简写</th><th>全名</th><th>说明</th></tr></thead><tbody><tr><td>FSM</td><td>Finite State Machine</td><td>有限状态机</td></tr><tr><td>FBD</td><td>Function Block Diagram</td><td>功能块图</td></tr><tr><td>FWIW</td><td>For What Is Worth</td><td>仅供参考</td></tr></tbody></table><h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><table><thead><tr><th>简写</th><th>全名</th><th>说明</th></tr></thead><tbody><tr><td>GPIO</td><td>General Purpose Input&#x2F;Output</td><td>通用输入输出</td></tr></tbody></table><h1 id="H"><a href="#H" class="headerlink" title="H"></a>H</h1><table><thead><tr><th>简写</th><th>全名</th><th>说明</th></tr></thead><tbody><tr><td>HIT</td><td>Harbin Institute Technology</td><td>哈尔滨工业大学</td></tr></tbody></table><h1 id="I"><a href="#I" class="headerlink" title="I"></a>I</h1><table><thead><tr><th>简写</th><th>全名</th><th>说明</th></tr></thead><tbody><tr><td>ICMP</td><td>Internet Control Message Protocol</td><td>互联网消息控制协议</td></tr><tr><td>IoT</td><td>Internet of Things</td><td>物联网</td></tr><tr><td>ISS</td><td>Internal Space Station</td><td>国际空间站</td></tr><tr><td>IL</td><td>Instruction List</td><td>指令表</td></tr><tr><td>ISP</td><td>Internet Service Provider</td><td>互联网服务提供商</td></tr><tr><td>IPC</td><td>Inter-Process Communication</td><td>进程间通信</td></tr><tr><td>IoC</td><td>Inversion of Control</td><td>控制反转</td></tr></tbody></table><h1 id="J"><a href="#J" class="headerlink" title="J"></a>J</h1><table><thead><tr><th>简写</th><th>全名</th><th>说明</th></tr></thead><tbody><tr><td>JWT</td><td>Json Web Token</td><td>Json网络令牌</td></tr></tbody></table><h1 id="K"><a href="#K" class="headerlink" title="K"></a>K</h1><table><thead><tr><th>简写</th><th>全名</th><th>说明</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><h1 id="L"><a href="#L" class="headerlink" title="L"></a>L</h1><table><thead><tr><th>简写</th><th>全名</th><th>说明</th></tr></thead><tbody><tr><td>LD</td><td>Ladder Diagram</td><td>梯形图</td></tr></tbody></table><h1 id="M"><a href="#M" class="headerlink" title="M"></a>M</h1><table><thead><tr><th>简写</th><th>全名</th><th>说明</th></tr></thead><tbody><tr><td>MQTT</td><td>Message Queuing Telemetry Transport</td><td>消息队列遥测传输</td></tr><tr><td>MOM</td><td>Minutes Of Meeting</td><td>会议纪要</td></tr></tbody></table><h1 id="N"><a href="#N" class="headerlink" title="N"></a>N</h1><table><thead><tr><th>简写</th><th>全名</th><th>说明</th></tr></thead><tbody><tr><td>NIC</td><td>Network Interface Card</td><td>网卡</td></tr></tbody></table><h1 id="O"><a href="#O" class="headerlink" title="O"></a>O</h1><table><thead><tr><th>简写</th><th>全名</th><th>说明</th></tr></thead><tbody><tr><td>OPC</td><td>OLE for Process Control&#x2F;Open Platform Communications</td><td>开放平台通信</td></tr><tr><td>Ops</td><td>Operations &amp; Maintenance</td><td>运维</td></tr><tr><td>ORM</td><td>Object-Reactional Mapping</td><td>对象关系映射</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h1 id="P"><a href="#P" class="headerlink" title="P"></a>P</h1><table><thead><tr><th>简写</th><th>全名</th><th>说明</th></tr></thead><tbody><tr><td>PLC</td><td>Programmable Logic Controller</td><td>可编程逻辑控制器</td></tr><tr><td>PAM</td><td>Plugged Authentication Modules</td><td>可插拔认证模块</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h1 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h1><table><thead><tr><th>简写</th><th>全名</th><th>说明</th></tr></thead><tbody><tr><td>QoS</td><td>Quality of Service</td><td>服务质量</td></tr></tbody></table><h1 id="R"><a href="#R" class="headerlink" title="R"></a>R</h1><table><thead><tr><th>简写</th><th>全名</th><th>说明</th></tr></thead><tbody><tr><td>RTU</td><td>Remote Terminal Unit</td><td>远程终端单元</td></tr><tr><td>RAM</td><td>Random Access Memory</td><td>随机存取存储器</td></tr><tr><td>ROM</td><td>Read Only Memory</td><td>只读存储器</td></tr><tr><td>ROS</td><td>Robot Operating System</td><td>机器人操作系统</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h1 id="S"><a href="#S" class="headerlink" title="S"></a>S</h1><table><thead><tr><th>简写</th><th>全名</th><th>说明</th></tr></thead><tbody><tr><td>SSL</td><td>Secure Sockets Layer</td><td>安全套接字层</td></tr><tr><td>SLAM</td><td>Simultaneous Localization and Mapping</td><td>同时定位与建图</td></tr></tbody></table><h1 id="T"><a href="#T" class="headerlink" title="T"></a>T</h1><table><thead><tr><th>简写</th><th>全名</th><th>说明</th></tr></thead><tbody><tr><td>TLS</td><td>Transport Layer Security</td><td>传输层安全</td></tr></tbody></table><h1 id="U"><a href="#U" class="headerlink" title="U"></a>U</h1><table><thead><tr><th>简写</th><th>全名</th><th>说明</th></tr></thead><tbody><tr><td>USB</td><td>Universal Serial Bus</td><td>通用串行总线</td></tr></tbody></table><h1 id="V"><a href="#V" class="headerlink" title="V"></a>V</h1><table><thead><tr><th>简写</th><th>全名</th><th>说明</th></tr></thead><tbody><tr><td>VPN</td><td>Virtual Private Network</td><td>虚拟私人网络</td></tr></tbody></table><h1 id="W"><a href="#W" class="headerlink" title="W"></a>W</h1><table><thead><tr><th>简写</th><th>全名</th><th>说明</th></tr></thead><tbody><tr><td>WEP</td><td>Wired Equivalent Privacy</td><td>有线等效加密</td></tr><tr><td>WPA</td><td>Wifi Protected Access</td><td>Wi-Fi保护接入</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h1 id="X"><a href="#X" class="headerlink" title="X"></a>X</h1><table><thead><tr><th>简写</th><th>全名</th><th>说明</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><h1 id="Y"><a href="#Y" class="headerlink" title="Y"></a>Y</h1><table><thead><tr><th>简写</th><th>全名</th><th>说明</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><h1 id="Z"><a href="#Z" class="headerlink" title="Z"></a>Z</h1><table><thead><tr><th>简写</th><th>全名</th><th>说明</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>螳螂在后的抽象文章分享</title>
    <link href="/2024/05/15/%E8%9E%B3%E8%9E%82%E5%9C%A8%E5%90%8E%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%96%87%E7%AB%A0%E5%88%86%E4%BA%AB/"/>
    <url>/2024/05/15/%E8%9E%B3%E8%9E%82%E5%9C%A8%E5%90%8E%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%96%87%E7%AB%A0%E5%88%86%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.zhihu.com/question/300803311/answer/2338198897">自然界中，哪种动物活得最惬意？</a></p>]]></content>
    
    
    <categories>
      
      <category>分享</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>杂记-2</title>
    <link href="/2024/05/15/%E6%9D%82%E8%AE%B0-2/"/>
    <url>/2024/05/15/%E6%9D%82%E8%AE%B0-2/</url>
    
    <content type="html"><![CDATA[<p><img src="/../images/%E6%9D%82%E8%AE%B0-2/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_17157560101563.png" alt="企业微信截图_17157560101563"></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2024/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2024/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_17157557259621.png"></p><p>7层OSI参考模型:物联网淑慧试用</p><ul><li><strong>应用层</strong></li><li><strong>表示层</strong></li><li><strong>会话层</strong></li><li><strong>传输层</strong></li><li><strong>网络层</strong></li><li><strong>链路层</strong></li><li><strong>物理层</strong></li></ul><p>4层TCP&#x2F;IP参考模型：</p><ul><li><strong>应用层（Application Layer）</strong><ul><li>应用层是TCP&#x2F;IP协议族的最高层，负责提供各种网络应用程序和服务的接口</li><li>在应用层，包括HTTP、FTP、SMTP等各种应用协议，它们定义了数据的格式和交换方式，使得应用程序之间可以进行通信和数据交换</li></ul></li><li><strong>传输层（Transport Layer）</strong><ul><li>传输层负责提供端到端的数据传输服务，实现数据的可靠传输和流量控制</li><li>在传输层，主要有两个常用的协议：TCP（传输控制协议）和UDP（用户数据协议）。TCP提供可靠的、面向连接的数据传输，而UDP提供不可靠的、面向无连接的数据传输</li></ul></li><li><strong>网络层（Internet Layer）</strong><ul><li>网络层负责实现数据包的路由和转发，实现不同网络之间的通信</li><li>在网络层，主要有IP（Internet Protocol）协议，它定义了数据包的格式和交换方式，使得数据可以在不同的网络之间传输</li></ul></li><li><strong>链路层（Linke Layer）</strong><ul><li>链路层负责实现相邻节点之间的数据传输和通信，包括物理层面的数据传输和数据链路控制</li><li>在链路层，主要有以太网、Wi-Fi、PPP等各种链路层协议，它们定义了数据的传输方式和传输介质，使得数据可以在物理网络上进行传输</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git基本操作</title>
    <link href="/2024/05/15/Git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2024/05/15/Git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p><img src="/../images/Git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20240515144600594.png" alt="image-20240515144600594"></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XML知识点</title>
    <link href="/2024/05/14/XML%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2024/05/14/XML%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>基本结构是**标签(element)<strong>、</strong>属性(attribute)<strong>、</strong>文本内容(text content)<strong>、</strong>注释(comment)**组成</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bookstore</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">book</span> <span class="hljs-attr">category</span>=<span class="hljs-string">&quot;fiction&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>Harry Potter<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">author</span>&gt;</span>J.K. Rowling<span class="hljs-tag">&lt;/<span class="hljs-name">author</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">price</span>&gt;</span>29.99<span class="hljs-tag">&lt;/<span class="hljs-name">price</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">book</span> <span class="hljs-attr">category</span>=<span class="hljs-string">&quot;fiction&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>The Hobbit<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">author</span>&gt;</span>J.R.R. Tolkien<span class="hljs-tag">&lt;/<span class="hljs-name">author</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">price</span>&gt;</span>19.99<span class="hljs-tag">&lt;/<span class="hljs-name">price</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bookstore</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在上述例子中，<code>&lt;bookstore&gt;</code> 是根元素，包含了两个 <code>&lt;book&gt;</code> 元素，每个 <code>&lt;book&gt;</code> 元素又包含了 <code>&lt;title&gt;</code>、<code>&lt;author&gt;</code> 和 <code>&lt;price&gt;</code> 元素。<code>&lt;book&gt;</code> 元素的 <code>category</code> 属性表示书籍的分类，而 <code>&lt;title&gt;</code> 元素的 <code>lang</code> 属性表示书名的语言。<br>或者使用xml来描述用户界面的布局和外观</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Window</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;MyNamespace.MainWindow&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:x</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">Title</span>=<span class="hljs-string">&quot;My Application&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;350&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;525&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Grid</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;Click Me&quot;</span> <span class="hljs-attr">HorizontalAlignment</span>=<span class="hljs-string">&quot;Center&quot;</span> <span class="hljs-attr">VerticalAlignment</span>=<span class="hljs-string">&quot;Center&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Grid</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Window</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个例子描述了一个简单的窗口，其中包含一个按钮，当点击按钮时会触发某些操作。通过编写 XAML 代码，可以定义窗口的布局、控件的样式和行为，从而创建出各种各样的图形界面。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>XML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#反射和特性</title>
    <link href="/2024/05/14/C-sharp%E5%8F%8D%E5%B0%84%E5%92%8C%E7%89%B9%E6%80%A7/"/>
    <url>/2024/05/14/C-sharp%E5%8F%8D%E5%B0%84%E5%92%8C%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>反射是特性的充分条件，特性是反射的必要条件。</p><p>特性就是tags，给属性或者方法打标签，打了标签的属性和方法会在编译的时候特殊处理。</p><p><strong>反射可以在运行时拿到程序中的东西</strong></p><p>比如：</p><p><img src="/../images/C-sharp%E5%8F%8D%E5%B0%84%E5%92%8C%E7%89%B9%E6%80%A7/image-20240514164333617.png" alt="image-20240514164333617"></p><p>可以直接在特性中对其进行操作</p><p><img src="/../images/C-sharp%E5%8F%8D%E5%B0%84%E5%92%8C%E7%89%B9%E6%80%A7/image-20240514170409883.png"></p><p>有些特性只能写一个，有些特性可以写好几个，还可以放进一个[]中书写，用”,”隔开</p><p>比如，用<code>typeof</code>操作符举例:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C#">Type derivedType = <span class="hljs-keyword">typeof</span>(DerivedClass);<br>Type baseType = <span class="hljs-keyword">typeof</span>(BaseClass);<br><br><span class="hljs-keyword">if</span> (derivedType.IsSubclassOf(baseType))<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;DerivedClass 是 BaseClass 的子类&quot;</span>);<br>&#125;<br><span class="hljs-comment">//typeof就可以判断一个没有实例化的类是不是另一个没有实例化的类的基类</span><br></code></pre></td></tr></table></figure><h3 id="与-GetType-的区别"><a href="#与-GetType-的区别" class="headerlink" title="与 GetType() 的区别"></a><strong>与 <code>GetType()</code> 的区别</strong></h3><h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a><strong><code>typeof</code></strong></h4><ul><li><p><strong>作用</strong>：获取指定类型的元数据。</p></li><li><p><strong>特点</strong>：在编译时确定类型。</p></li><li><p>示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">Type type = <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">string</span>); <span class="hljs-comment">// 获取字符串类型的元数据</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="GetType"><a href="#GetType" class="headerlink" title="GetType()"></a><strong><code>GetType()</code></strong></h4><ul><li><p><strong>作用</strong>：获取实例对象的运行时类型。</p></li><li><p><strong>特点</strong>：在运行时根据对象动态获取。</p></li><li><p>示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">string</span> example = <span class="hljs-string">&quot;Hello&quot;</span>;<br>Type type = example.GetType(); <span class="hljs-comment">// 获取实例的类型</span><br>Console.WriteLine(type); <span class="hljs-comment">// 输出：System.String</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a><strong>对比总结</strong></h4><ul><li><code>typeof</code> 用于静态类型（不需要实例化）。</li><li><code>GetType()</code> 用于运行时动态类型（需要具体实例）。</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jupyter使用C#</title>
    <link href="/2024/05/11/jupyter%E4%BD%BF%E7%94%A8.NET/"/>
    <url>/2024/05/11/jupyter%E4%BD%BF%E7%94%A8.NET/</url>
    
    <content type="html"><![CDATA[<p>首先确保电脑上有jupyter和.NET环境</p><p>安装dotnet interactive全局工具</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">dotnet tool install <span class="hljs-literal">--global</span> Microsoft.dotnet<span class="hljs-literal">-interactive</span><br></code></pre></td></tr></table></figure><p>然后就可以用**<code>dotnet tool list -g</code>**命令来查看已经安装的全局工具</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">包 ID                              版本              命令<br><span class="hljs-literal">--------------------------------------------------------------------</span><br>microsoft.dotnet<span class="hljs-literal">-interactive</span>      <span class="hljs-number">1.0</span>.<span class="hljs-number">522904</span>      dotnet<span class="hljs-literal">-interactive</span><br></code></pre></td></tr></table></figure><p>然后运行**<code>dotnet interactive jupyter install</code>**命令来安装jupyter kernal</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs postgresql">Welcome <span class="hljs-keyword">to</span> .NET Interactive!<br><span class="hljs-comment">---------------------</span><br>Telemetry<br><span class="hljs-comment">---------</span><br>The .NET tools collect <span class="hljs-keyword">usage</span> data <span class="hljs-keyword">in</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">to</span> help us improve your experience. The data <span class="hljs-keyword">is</span> anonymous <span class="hljs-keyword">and</span> doesn<span class="hljs-string">&#x27;t include command-line arguments. The data is collected by Microsoft and shared with the community. You can opt-out of telemetry by setting the DOTNET_INTERACTIVE_CLI_TELEMETRY_OPTOUT environment variable to &#x27;</span><span class="hljs-number">1</span><span class="hljs-string">&#x27; or &#x27;</span>tru<span class="hljs-string">e&#x27; using your favorite shell.</span><br><span class="hljs-string"></span><br><span class="hljs-string">Installing using jupyter kernelspec module.</span><br><span class="hljs-string">Installed &quot;.NET (C#)&quot; kernel.</span><br><span class="hljs-string">Installing using jupyter kernelspec module.</span><br><span class="hljs-string">Installed &quot;.NET (F#)&quot; kernel.</span><br><span class="hljs-string">Installing using jupyter kernelspec module.</span><br><span class="hljs-string">Installed &quot;.NET (PowerShell)&quot; kernel.</span><br></code></pre></td></tr></table></figure><p>然后就可以使用了，但是效果其实没有想象中那么好,功能性上不如Roslyn或者csharprepl，但是毕竟也算是可以写即拿即用的脚本了。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jupyter</tag>
      
      <tag>Python</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#事件和委托</title>
    <link href="/2024/05/10/C-sharp%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%A7%94%E6%89%98/"/>
    <url>/2024/05/10/C-sharp%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%A7%94%E6%89%98/</url>
    
    <content type="html"><![CDATA[<p>委托能干什么？</p><p>作为函数传参，如LINQ，orderby，传入了一个函数将函数作为规则去筛选</p><blockquote><p> 回调函数:将一个函数传给另一个函数，并且在特定的事件发生或满足特定条件时被调用执行的函数</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#冷知识</title>
    <link href="/2024/05/04/C-sharp%E5%86%B7%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/05/04/C-sharp%E5%86%B7%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<ul><li><p>传递参数</p><ul><li><p>位置参数</p></li><li><p>命名参数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">Foo(<span class="hljs-string">&quot;Tom&quot;</span>,alive:<span class="hljs-literal">true</span>);<span class="hljs-comment">//一般用于某些参数已经给好了默认值，可以跳过这些参数</span><br>Foo(<span class="hljs-string">&quot;Tom&quot;</span>,age:<span class="hljs-number">18</span>,<span class="hljs-literal">true</span>);<span class="hljs-comment">//可以在一个命名参数后加一个位置参数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">int</span> age=<span class="hljs-number">18</span>, <span class="hljs-built_in">bool</span> alive</span>)</span><br>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>像Python一样写C#代码</title>
    <link href="/2024/05/04/%E5%83%8FPython%E4%B8%80%E6%A0%B7%E5%86%99C#%E4%BB%A3%E7%A0%81/"/>
    <url>/2024/05/04/%E5%83%8FPython%E4%B8%80%E6%A0%B7%E5%86%99C#%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C-sharp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程入门概念</title>
    <link href="/2024/04/29/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A8%E6%A6%82%E5%BF%B5/"/>
    <url>/2024/04/29/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A8%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h3><ul><li>线程是操作系统中能够独立运行的最小单位，也是程序中能够并发执行的一段指令序列。</li><li>线程是进程的一部分，一个进程可以包含多个线程，这些线程共享进程的资源。<ul><li>比如现在写了一个控制台程序，在运行之后它就会变成一个进程，入口函数所在的线程就会成为主线程或者入口线程，如果在主线程中创建了其他线程，这个进程就会包含不止一个线程，这些线程都可以访问进程中的资源。</li></ul></li><li>进程有入口线程，也可以创建更多的线程。</li></ul><h3 id="为什么需要多线程？"><a href="#为什么需要多线程？" class="headerlink" title="为什么需要多线程？"></a>为什么需要多线程？</h3><ul><li>批量重复任务希望同时进行（比如对数组中每个元素进行相同且耗时的操作）</li><li>多个不同任务希望同时进行，互不干扰（比如有多个后才线程需要做轮询等操作时）</li></ul><h3 id="什么是线程池？"><a href="#什么是线程池？" class="headerlink" title="什么是线程池？"></a>什么是线程池？</h3><ul><li>一组预先创建的线程，可以被重复使用来执行多个任务</li><li>线程的创建和删除等，生命周期比较耗时</li><li>避免频繁地创建和销毁线程，从而减少了线程创建和销毁的开销，提高了系统的性能和效率</li><li>异步编程默认使用线程池</li></ul><h3 id="什么是线程安全？"><a href="#什么是线程安全？" class="headerlink" title="什么是线程安全？"></a>什么是线程安全？</h3><ul><li><p>线程安全</p><ul><li>多个线程访问共享资源时，对共享资源的访问不会导致数据不一致或不可预期的结果</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> total = <span class="hljs-number">100</span>_000;<br><span class="hljs-built_in">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">object</span> lockObj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();<br><span class="hljs-keyword">var</span> thread1 = <span class="hljs-keyword">new</span> Thread(ThreadMethod);<br><span class="hljs-keyword">var</span> thread2 = <span class="hljs-keyword">new</span> Thread(ThreadMethod);<br>thread1.Start();<br>thread2.Start();<br>thread1.Join();<br>thread2.Join();<br>Console.WriteLine(<span class="hljs-string">$&quot;Count:<span class="hljs-subst">&#123;count&#125;</span>&quot;</span>);<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ThreadMethod</span>()</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; total; i++)<br>        <span class="hljs-keyword">lock</span>(lockObj)<br>            count ++;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述内容中，入果不加锁锁住的话，可能会出现在同一时间thread1和thread2同时调用total的请况，由于它们对total的操作是相同的，相当于只进行了一次计数操作，操作就被抵消掉了。</p></li><li><p>同步机制</p><ul><li>用于协调和控制多个线程之间执行顺序和互斥访问共享资源<ul><li>先到先得，不能同时访问一个资源</li></ul></li><li>确保线程按照特定的顺序执行，避免竞态条件和数据不一致的问题<ul><li>竞态条件就是两个线程在同时用一个资源</li></ul></li></ul></li><li><p>原子操作</p><ul><li><p>在执行过程中不会被中断的操作。不可分割，要么完全执行，要么完全不执行，没有中间态</p></li><li><p>在多线程环境下，原子操作能够保证数据的一致性和可靠性，避免出现竞态条件和数据竞争的问题</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment"><span class="hljs-doctag">///</span>dotnet自带了原子化操作的方法</span><br>Interlocked<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="C-的常用实现方式"><a href="#C-的常用实现方式" class="headerlink" title="C#的常用实现方式"></a>C#的常用实现方式</h3><ul><li><p>线程</p><ul><li>new一个线程</li></ul></li><li><p>线程池</p><ul><li>使用ThreadPool中的一些方法</li></ul></li><li><p>异步编程</p><ul><li>async await</li></ul></li><li><p>自带方法</p><ul><li>Parallel:For、ForEach、Invoke——好比传统的for循环，但是里面的每一个循环都能独立进行，Invoke可以传入多个回调函数，这些函数可以同时进行</li><li>PLINQ:AsParallel、AsSequental、AsOrdered</li></ul></li></ul><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul><li><p>线程的创建</p><ul><li>创建Thread实例，并传入ThreadStart委托——还可以配置线程，如是否为后台线程（前台线程只要终止了，那么后台线程也会跟着关闭掉）<ul><li>一般都是一个while循环</li></ul></li><li>调用Thread.Start方法，还可以传参</li></ul></li><li><p>线程的终止</p><ul><li><p>调用Thread.Join方法等待线程的结束——主线程会被阻塞，直到子线程结束才能停止</p></li><li><p>调用Thread.Interrupt方法，中断线程的执行</p><ul><li><p>会在相应线程中抛出ThreadInterruptedException</p></li><li><p>如果一个线程中包含一个while(true)循环，那么需要保证包含等待方法，如IO操作，Thread.Sleep等</p><ul><li><p>如果不包含，则这个线程会太忙了以至于无法抓到抛出的异常</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>&#123;<br>    Thread.Sleep(<span class="hljs-number">0</span>);<span class="hljs-comment">//可以添加一个sleep以改变cpu处理这个线程的模式，另，一般写sleep(1)的睡眠时间是会超过1ms的，因为还要调用系统方法什么的</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>不能用Abort?</p></li></ul></li><li><p>线程的挂起与恢复</p><ul><li>Thread.Suspend以及Thread.Resume<ul><li>和Abort一样，挂起和恢复可能让线程在任一位置停止，这一状况非常危险</li></ul></li><li>在较新版本的.NET中，这两个方法已经被标为Obsolete，且调用会报错</li><li>推荐使用锁、信号量等方式实现这一逻辑</li></ul></li></ul><h3 id="线程安全与同步机制"><a href="#线程安全与同步机制" class="headerlink" title="线程安全与同步机制"></a>线程安全与同步机制</h3><ul><li>原子操作</li><li>锁与信号量<ul><li>Lock&amp;Monitor</li><li>Mutex</li><li>Semaphore</li><li>WaitHandle</li><li>ReaderWriterLock</li></ul></li><li>轻量型</li><li>不要自己造轮子</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Modbus TCP/IP</title>
    <link href="/2024/04/28/Modbus%20TCPIP/"/>
    <url>/2024/04/28/Modbus%20TCPIP/</url>
    
    <content type="html"><![CDATA[<p>在TCP层上又封装了一层协议，在传输数据的时候可以定义地址，变量的存储、格式</p><p>纯TCP，双方要对协议，互相对接，测试，诊断也比较麻烦</p><p>ModBus只要把地址和数据的定义告诉上位机编程人员，代码可复用</p><p>互联网传递的，实际上是数据包，这是TCP&#x2F;IP族特性</p><p>基本步骤：</p><ol><li>给我一个地址，如IPV6地址 </li><li>遵守某个网络协议TCP&#x2F;UDP等把数据包发送到目的地<ol><li>数据报包的生成</li><li>寻址、根据IP地址寻找网络通路（可能不止一条）</li><li>需要穿透多少层路由后放弃</li></ol></li></ol><h5 id="数据包结构："><a href="#数据包结构：" class="headerlink" title="数据包结构："></a>数据包结构：</h5><ul><li>MBAP Header</li><li>Modbus TCP Function Codes</li><li>Modbus Data</li><li>TCP&#x2F;IP Packet</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Modbus</tag>
      
      <tag>TCP/IP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Microsoft Learn Visual Studio</title>
    <link href="/2024/04/22/Microsoft%20Learn%20Visual%20Studio/"/>
    <url>/2024/04/22/Microsoft%20Learn%20Visual%20Studio/</url>
    
    <content type="html"><![CDATA[<h1 id="软件测试概念简介"><a href="#软件测试概念简介" class="headerlink" title="软件测试概念简介"></a>软件测试概念简介</h1><h3 id="测试方法定义"><a href="#测试方法定义" class="headerlink" title="测试方法定义"></a>测试方法定义</h3><p>测试方法与常规方法相似。测试属于测试类，具有方法前面且接受参数。测试引用并调用产品代码（又称非测试代码），并将其行为与预期结果进行比较。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C#">[<span class="hljs-meta">TestMethod</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddTest</span>()</span><br>&#123;<br>    <span class="hljs-comment">// Arrange</span><br>    <span class="hljs-keyword">var</span> calculator = <span class="hljs-keyword">new</span> Calculator();<br><br>    <span class="hljs-comment">// Act</span><br>    <span class="hljs-keyword">var</span> actual = calculator.Add(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// Assert</span><br>    Assert.AreEqual(<span class="hljs-number">2</span>, actual);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Visual Studio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人收集计算机相关书籍分享</title>
    <link href="/2024/04/17/%E4%B8%AA%E4%BA%BA%E6%94%B6%E9%9B%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3%E4%B9%A6%E7%B1%8D%E5%88%86%E4%BA%AB/"/>
    <url>/2024/04/17/%E4%B8%AA%E4%BA%BA%E6%94%B6%E9%9B%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3%E4%B9%A6%E7%B1%8D%E5%88%86%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<p>个人的onedrive网盘分享链接：<a href="https://1drv.ms/f/s!AoACpu0RVGIahRXrS-3rwwY1Mfa5?e=uVqXwz">【计算机科学】</a></p>]]></content>
    
    
    <categories>
      
      <category>分享</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C#刷题笔记</title>
    <link href="/2024/04/17/C-sharp%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/04/17/C-sharp%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python网络爬虫</title>
    <link href="/2024/04/12/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    <url>/2024/04/12/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/</url>
    
    <content type="html"><![CDATA[<p>爬虫类型：</p><ul><li>通用网络爬虫<ul><li>搜索引擎</li></ul></li><li>聚焦网络爬虫<ul><li>自动下载网页的程序</li></ul></li><li>增量式网络爬虫</li><li>深层网络爬虫<ul><li>表层网页是指传统搜索引擎可以索引的页面。</li><li>深层网络是不能通过静态链接获取的、隐藏在搜索表单后的，只有用户提交一些关键词才能获得的Web页面</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br>r = requests.get(<span class="hljs-string">&#x27;https://xxxx&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;网页编码&#x27;</span>,r.encoding)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;响应状态码&#x27;</span>,r.status_code)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;字节方式响应体&#x27;</span>,r.content)<br></code></pre></td></tr></table></figure><table><thead><tr><th>使用方法</th><th>说明</th></tr></thead><tbody><tr><td>r.status_code</td><td>检测响应状态码。如果返回200，表示请求成功；如果返回的是4xx，表示客户端错误；返回5xx表示服务器错误响应</td></tr><tr><td>r.content</td><td>字节方式响应体，自动解码gzip和deflate编码的响应数据</td></tr><tr><td></td><td></td></tr></tbody></table><h4 id="定制请求头"><a href="#定制请求头" class="headerlink" title="定制请求头"></a>定制请求头</h4><blockquote><p>请求头Headers提供了关于请求，响应或其它发送实体的信息。对于爬虫而言，请求头十分重要。因为请求头可以反映出一些基础信息，包括浏览器的型号，版本，或者是爬虫python版本，等等。<br>对于一些基础的反爬虫，就会通过头部信息来拦截爬虫</p></blockquote><p>有些网站会根据头信息来判断反爬虫，没有头部信息的爬虫会被拦截拿不到任何信息。</p><p>有时候爬虫会遇到服务器长时间不返回，如果没有设置超时，爬虫就会一直等待。</p><p>在Request中有一个timeout函数，可以设置超时。</p><h4 id="发送post请求"><a href="#发送post请求" class="headerlink" title="发送post请求"></a>发送post请求</h4><p>有时候需要发送一些编码为表单形式的数据，比如在登录的时候需要账号密码就是用post请求发送的。如果用get请求密码就会显示在URL中，这样极其不安全。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>脚本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#数据结构</title>
    <link href="/2024/04/10/C-sharp%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2024/04/10/C-sharp%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>基于<a href="https://github.com/krahets/hello-algo">《Hello 算法》</a>项目的学习笔记。</p><h1 id="数组与链表"><a href="#数组与链表" class="headerlink" title="数组与链表"></a>数组与链表</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">5</span>];<span class="hljs-comment">//[0,0,0,0,0]</span><br><span class="hljs-built_in">int</span>[] nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><ul><li>索引本质上是内存地址的偏移量</li><li><strong>数组的长度是不可变的</strong><ul><li>如果希望扩容数组，就只能重新建立一个更大的数组，然后把原数组元素依次复制到新数组。</li></ul></li><li>数组的插入和删除操作有以下缺点<ul><li><strong>时间复杂度高</strong>：评价时间复杂度为O(n),其中n为数组长度</li><li><strong>丢失元素</strong>：由于数组长度不可变，插入元素后，超出数组长度范围的元素会丢失。</li><li><strong>内存浪费</strong>：可以初始一个比较长的数组，只用前面一部分，在插入数据时丢失的末尾元素都是无意义的，这样会造成部分内存空间浪费。</li></ul></li></ul><h3 id="数组的优点与局限性"><a href="#数组的优点与局限性" class="headerlink" title="数组的优点与局限性"></a>数组的优点与局限性</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li><strong>空间效率高</strong>：数组为数据分配了连续的内存块，无需额外的结构开销。</li><li><strong>支持随机访问</strong>：数组允许在O(1)时间内访问任何元素</li><li><strong>缓存局部性</strong>：当访问数组元素时，计算机不仅会加载它，还会缓存周围的其他数据，从而借助告诉缓存来提升后续操作的执行速度。</li></ul><h4 id="局限性："><a href="#局限性：" class="headerlink" title="局限性："></a>局限性：</h4><ul><li><strong>插入与删除效率低</strong>：当数组中元素较多时，插入与删除操作需要移动大量的元素。</li><li><strong>长度不可变</strong>：组在初始化后长度就固定了，扩容数组需要将所有数据复制到新数组，开销很大。</li><li><strong>空间浪费</strong>：如果数组分配的大小超过实际所需，那么多余的空间就被浪费了。</li></ul><h3 id="数组典型应用"><a href="#数组典型应用" class="headerlink" title="数组典型应用"></a>数组典型应用</h3><ul><li><strong>随机访问</strong>：根据索引实现随机抽样</li><li><strong>排序和搜索</strong>：排序和搜索算法最常用的数据结构。快速排序、归并排序、二分查找等都主要在数组上进行。</li><li><strong>查找表</strong>：当需要快速查找一个元素或其对应关系时，可以使用数组作为查找表。</li><li><strong>机器学习：</strong>神经网络中大量使用向量、矩阵、张量之间的线性代数运算，这些数据都是以数组的形式构建的。</li><li><strong>数据结构实现</strong>：数组可以用于实现栈、队列、哈希表、堆、图等数据结构。例如，图的邻接矩阵实际上是一个二维数组。</li></ul><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul><li><strong>在相同是数据量下，链表比数组占用更多的内存空间。</strong>链表节点除了包含值，还需额外保存一个引用（指针）</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span>(<span class="hljs-title">int</span> <span class="hljs-title">x</span>)&#123;<span class="hljs-comment">//构造函数</span><br>    <span class="hljs-built_in">int</span> val =x;  <span class="hljs-comment">//节点值</span><br>    ListNode? next;  <span class="hljs-comment">//指向下一节点的引用</span><br>&#125;<br>ListNode n0 = <span class="hljs-keyword">new</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//创建新实例的时候将节点值传入实例</span><br>ListNode n1 = <span class="hljs-keyword">new</span>(<span class="hljs-number">3</span>); <br>ListNode n2 = <span class="hljs-keyword">new</span>(<span class="hljs-number">2</span>);<br>n0.next = n1;<br>n1.next = n2;<br></code></pre></td></tr></table></figure><ul><li><p><strong>通常将头节点作为链表的代称</strong>，以上代码中的链表可记作链表<code>n0</code>。</p></li><li><p><strong>插入或删除节点只需改变两个节点引用（指针）即可</strong>，时间复杂度为O(1)</p><ul><li>相比之下，在数组中插入元素时间复杂度为O(n)，在大数据量下的效率较低。</li></ul></li><li><p><strong>在链表中访问节点的效率较低</strong>，需要从头向后遍历，时间复杂度为O(n)</p></li></ul><table><thead><tr><th></th><th>数组</th><th>链表</th></tr></thead><tbody><tr><td>存储方式</td><td>连续内存空间</td><td>分散内存空间</td></tr><tr><td>容量扩展</td><td>长度不可变</td><td>可灵活扩展</td></tr><tr><td>内存效率</td><td>元素占用内存少、但可能浪费空间</td><td>元素占用内存多</td></tr><tr><td>访问元素</td><td>O(1)</td><td>O(n)</td></tr><tr><td>添加元素</td><td>O(n)</td><td>O(1)</td></tr><tr><td>删除元素</td><td>O(n)</td><td>O(1)</td></tr></tbody></table><ul><li><strong>常见链表类型:</strong><ul><li><strong>单向链表 (singly linked list)：</strong></li><li><strong>环形链表（circular linked list）：</strong>如果令单链表的尾节点指向头节点（首尾相接），则得到一个环形链表。在环形链表中，任意节点都可以被视作头节点。</li><li><strong>双向链表：</strong></li></ul></li></ul><h3 id="链表典型应用"><a href="#链表典型应用" class="headerlink" title="链表典型应用"></a>链表典型应用</h3><ul><li><strong>单链表</strong>通常<strong>用于实现栈、队列、哈希表和图等数据结构</strong>。<ul><li><strong>栈与队列</strong>：<ul><li>当插入和删除操作都在链表的一段进行时，它表现出先进后出特性，对应<strong>栈</strong></li><li>当插入操作在链表的一端进行，删除操作在链表的另一端进行，它表现出先进先出的特性，对应<strong>队列</strong></li></ul></li><li><strong>哈希表</strong>：链表地址是解决哈希表冲突的主流方案之一，在该方案中，所有冲突的元素都会被放到一个链表中</li><li><strong>图</strong>：邻接表是表示图的一种方式，其中图的每个顶点都与一个链表相关联，链表中的每个元素都代表与该顶点相连的其他顶点。</li></ul></li><li><strong>双链表</strong>常用于<strong>需要快速查找前一个和后一个元素的场景</strong>。<ul><li><strong>高级数据结构</strong>：比如在<strong>红黑树、B树</strong>中，我们需要访问节点的父节点，这可以通过在节点中保存已给指向父节点的引用来实现，类似于双向链表。</li><li><strong>浏览器历史</strong>：在网页浏览器中，当用于点击前进或后退时，浏览器需要知道用户访问过的前一个和后一个网页。双链表使得这种操作变得简单。</li><li><strong>LRU算法</strong>：在缓存淘汰（LRU）算法中，我们需要快速找到最近最少使用的数据，以及支持快速添加和删除节点。这时候最适合使用双链表。</li></ul></li><li><strong>环形链表</strong>常用于需要周期性操作的场景，比如操作系统的资源调度。<ul><li><strong>时间片轮转调度算法</strong>：在操作系统中，时间片轮转调度算法是一种常见的CPU调度算法，它需要对一组进程进行循环。每个进程被赋予要给时间片，当时间片用完时，CPU将切换到下一个进程。这种循环操作可以通过环形链表来实现。</li><li><strong>数据缓冲区</strong>：在某些数据缓冲区的实现中，也可能会使用环形链表。比如在音频、视频播放器中，数据流可能会被分成多个缓冲块并放入一个环形链表，以便实现无缝播放。</li></ul></li></ul><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ul><li><p>当使用数组实现列表时，<strong>长度不可变的性质会导致列表的实用性降低</strong>，因此我们使用[动态数组 dynamic array]来实现列表。</p></li><li><p><strong>实际上许多编程语言中的标准库提供的列表是基于动态数组实现的</strong>，例如<strong>Python</strong>中的<code>list</code>,<strong>Java</strong>中的<code>Arraylist</code>,**C++<strong>中的<code>vector</code>和</strong>C#**中的<code>List</code>等。在接下来的讨论中，我们把“列表”和“动态数组”视为等同的概念。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">int</span>[] numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>];<br>List&lt;<span class="hljs-built_in">int</span>&gt; nums = [..numbers];<br><span class="hljs-built_in">int</span> num = nums[<span class="hljs-number">1</span>];<br>nums.Clear();<br>nums.Add(<span class="hljs-number">1</span>);<br>nums.Insert(<span class="hljs-number">3</span>,<span class="hljs-number">6</span>);<br>nums.RemoveAt(<span class="hljs-number">3</span>);<br>List&lt;<span class="hljs-built_in">int</span>&gt; nums1 = [<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>];<br>nums.AddRange(nums1);<span class="hljs-comment">//将nums1拼接到nums后</span><br>nums.Sort();<span class="hljs-comment">//排序后，列表元素从小到大排列</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="列表实现"><a href="#列表实现" class="headerlink" title="列表实现"></a>列表实现</h3><p>许多编程语言内置了列表，如Java，C++，Python等，它们的实现比较复杂，下面抽象一下它的设计。</p><ul><li><strong>初始容量</strong></li><li><strong>数量记录</strong></li><li><strong>扩容机制</strong></li></ul><h3 id="内存与缓存"><a href="#内存与缓存" class="headerlink" title="内存与缓存"></a>内存与缓存</h3><p>数组和链表分别代表了“连续存储”和“分散存储”两种物理结构。</p><p>实际上，<strong>物理结构在很大程度上决定了程序对内存和缓存的使用效率</strong>，进而影响算法程序的整体性能。</p><table><thead><tr><th>硬盘</th><th>内存</th><th>缓存</th></tr></thead><tbody><tr><td>长期存储数据，包括操作系统，程序，文件等</td><td>临时存储当前运行的程序和数据</td><td>存储经常访问的数据和指令，减少CPU访问内存次数</td></tr><tr><td>断电后数据不会消失</td><td>断电后数据丢失</td><td>断电后数据丢失</td></tr></tbody></table><ul><li><strong>硬盘难以被内存取代</strong></li><li><strong>缓存的大容量和高速度难以兼得</strong><ul><li>随着L1、L2、L3缓存容量的逐步增大，其<strong>物理尺寸会变大，与CPU之间的物理举例会变远</strong>，从而导致数据传输时间增加，元素访问延迟变高。在当前技术下，多层级的缓存结构是容量、速度和成本之间的最佳平衡点。</li></ul></li></ul><h3 id="数据结构的内存效率"><a href="#数据结构的内存效率" class="headerlink" title="数据结构的内存效率"></a>数据结构的内存效率</h3><ul><li><strong>内存是有限的，且同一块内存不能被多个程序共享</strong>，因此我们希望数据结构更高效地使用内存空间。数组不需要存储指针，明显空间效率更高，然而因其需要一次性申请大量内存，可能导致内存浪费，数组扩容也需要额外的时间和空间成本。相比之下链表以节点为单位进行内存分配和回收，提供了更大的灵活性。</li><li>在程序运行时，<strong>随着仿佛申请和释放内存，空闲内存的碎片化程度会越来越高</strong>，从而导致内存的利用效率降低。</li></ul><h3 id="数据结构的缓存效率"><a href="#数据结构的缓存效率" class="headerlink" title="数据结构的缓存效率"></a>数据结构的缓存效率</h3><p>由于缓存的容量有限，只能存储一小部分频繁访问的数据，因此当CPU尝试访问的数据不在缓存中时，就会发生<strong>缓存未命中 cache miss</strong>，此时CPU不得不从速度较慢的内存中加载所需数据。</p><p><strong>缓存未命中越少，CPU读写数据的效率就越高</strong>，程序性能也就越好。将CPU从缓存中成功获取数据的比例称为<strong>缓存命中率 cache hit rate</strong>,这个指标通常用来衡量缓存效率。</p><p>为了尽可能达到更高的效率，缓存会采取以下数据加载机制：</p><ul><li><strong>缓存行</strong>：缓存不是单个字节地存储与加载数据，而是以缓存行为单位。相比于单个字节的传输，缓存行的传输形式更加高效。</li><li><strong>预取机制</strong>：处理器会尝试预测数据访问模式（如顺序访问、固定步长跳跃访问等），并根据特定模式将数据加载至缓存之中，从而提升命中率。</li><li><strong>空间局部性</strong>:如果一个数据被访问，则它附近的数据可能近期也会被访问。因此，缓存加载某一数据时，也会加载其附近的数据，以提高命中率。</li><li><strong>时间局部性</strong>:如果一个数据被访问，则其未来也很可能被访问，因此缓存利用 这一原理保留最近访问过的数据以提升访问率。</li></ul><p><strong>数组和链表对缓存的利用效率是不同的</strong></p><ul><li><strong>占用空间</strong>：因为要存指针，因此同样量的有效数据空间占比链表更多</li><li><strong>缓存行</strong>：链表物理地址不相邻，但缓存行是<strong>按行加载</strong>的，因此数组更有优势</li><li><strong>预取机制</strong>：数组比链表的数据访问模式更具有”可预测性“，即系统更容易猜出即将被加载的数据。</li><li><strong>空间局部性</strong>：因为数组存储的物理地址是相邻的，被加载数据附近的数据更有可能被加载到。</li></ul><p>因此，<strong>数组具有更高的缓存命中率，因此它在操作效率上通常优于链表</strong>。这使得在解决算法问题时，基于数组实现的数据结构往往更受欢迎。</p><p>但是值得注意的是，<strong>高缓存效率并不意味着数组在所有情况下都优于链表</strong>。，例如数组和链表都可以实现栈，但它们适用于不同的场景。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><h4 id="Q-A"><a href="#Q-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><ul><li><p>为什么数组要求相同类型的元素，而在链表中却无此要求？</p><ul><li><p>链表通过引用连接，每个节点可存储的内容不同；</p></li><li><p>数组元素的类型必须是相同的，这样才能通过计算偏移量来获取对应元素位置。</p></li><li><blockquote><p>元素内存地址&#x3D;数组内存地址(首元素内存地址)+元素长度*元素索引</p></blockquote></li></ul></li></ul><h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><p>栈是只有一头开口的羽毛球筒，队列是两头开口的羽毛球筒。</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul><li><p>常用的栈操作命名为<code>push()</code>入栈,<code>pop()</code>出栈,<code>peek()</code>访问栈顶元素。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#">Stack&lt;<span class="hljs-built_in">int</span>&gt; stack = <span class="hljs-keyword">new</span>();<br>stack.Push(<span class="hljs-number">1</span>);<span class="hljs-comment">//入栈</span><br>stack.Peek();<span class="hljs-comment">//访问栈顶元素</span><br><span class="hljs-built_in">int</span> size = stack.Count;<span class="hljs-comment">//栈的长度</span><br><span class="hljs-built_in">bool</span> isEmpty = stack.Count == <span class="hljs-number">0</span>;<span class="hljs-comment">//判断是否为空</span><br>stack.Pop();<span class="hljs-comment">//出栈</span><br></code></pre></td></tr></table></figure></li><li><p><strong>栈可以视为一种受限制的数组或链表</strong>。换而言之，我们可以屏蔽数组或链表的部分无关操作，使其对外表现的逻辑符合栈的特性。</p></li></ul><h3 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h3><h3 id="栈的典型应用"><a href="#栈的典型应用" class="headerlink" title="栈的典型应用"></a>栈的典型应用</h3><ul><li><strong>浏览器中的后退和前进、软件中的撤销与反撤销</strong>。每当打开新的网页，浏览器就会对上一个网页执行入栈，这样我们可以通过后退操作回到上一个网页。后退操作实际上是在执行出栈。如果要同时支持后退和前进，那么需要两个栈来配合实现。</li><li><strong>程序内存管理</strong>。每次调用函数时，系统都会在栈顶添加一个栈帧，用于记录函数的上下文信息。在递归函数中，向下递推阶段会不断执行入栈操作，而向上回溯阶段会不断执行出栈操作。</li></ul><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#">Queue&lt;<span class="hljs-built_in">int</span>&gt; queue = <span class="hljs-keyword">new</span>();<br>queue.Enqueue(<span class="hljs-number">1</span>);<span class="hljs-comment">//元素入队</span><br><span class="hljs-built_in">int</span> peek=queue.Peek();<span class="hljs-comment">//访问队首原申诉</span><br><span class="hljs-built_in">int</span> pop = queue.Dequeue();<span class="hljs-comment">//元素出队</span><br><span class="hljs-built_in">int</span> size = queue.Count();<span class="hljs-comment">//队列的长度</span><br><span class="hljs-built_in">bool</span> isEmpty = queue.Count() == <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h3 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h3><h4 id="基于链表的实现"><a href="#基于链表的实现" class="headerlink" title="基于链表的实现"></a>基于链表的实现</h4><p>将链表的头节点和尾节点分别视为队首和队尾，规定队尾仅可添加节点，队首仅可删除节点。</p><h4 id="基于数组的实现"><a href="#基于数组的实现" class="headerlink" title="基于数组的实现"></a>基于数组的实现</h4><h3 id="队列典型应用"><a href="#队列典型应用" class="headerlink" title="队列典型应用"></a>队列典型应用</h3><ul><li><strong>淘宝订单</strong>：购物者下单后，订单将加入队列中，系统随后会根据顺序处理队列中的订单。在高并发环境下，当新的请求进入系统时，如果系统当前的处理能力已经饱和，新的请求就会被放入队列中等待处理。这样，即使在流量高峰期，系统也能保持稳定的运行状态。</li><li><strong>各类待办事项</strong>：任何需要实现先来后到功能的场景，例如打印机的任务队列，餐厅的出餐队列等，队列在这些场景中可以有效地维护处理顺序。</li></ul><h2 id="双向队列"><a href="#双向队列" class="headerlink" title="双向队列"></a>双向队列</h2><h3 id="双向队列应用"><a href="#双向队列应用" class="headerlink" title="双向队列应用"></a>双向队列应用</h3><p>双向队列兼具栈与队列的逻辑，<strong>因此它可以实现这两者的所有应用场景，同时提供更高的自由度。</strong></p><p>软件的撤销功能通常使用栈来实现，但是软件通常会限制撤销的步数，比如50步。当栈的长度超过50时，软件需要在栈底（队首）执行删除操作。<strong>但栈无法实现该功能，此时就需要用双向队列来代替栈</strong>。</p><p>撤销的核心逻辑依然遵循栈的先入后出原则，只是双向队列能够更加灵活地实现一些额外逻辑。</p><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><ul><li><p>哈希表又称<strong>散列表</strong>，它通过建立键<code>key</code>与值<code>value</code>之间的映射，实现高效的元素查询。具体而言，向哈希表中输入一个<code>key</code>，则可以在O(1)时间内获取对应的值<code>value</code>.</p></li><li><p>字典就是哈希表</p></li><li><p><strong>哈希表进行增删改查的时间复杂度都是O(1)</strong></p></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C#">Dictionary&lt;<span class="hljs-built_in">int</span>,<span class="hljs-built_in">string</span>&gt; map = <span class="hljs-keyword">new</span>()&#123;<br>    &#123;<span class="hljs-number">12836</span>,<span class="hljs-string">&quot;小哈&quot;</span>&#125;,<br>    &#123;<span class="hljs-number">15937</span>,<span class="hljs-string">&quot;小罗&quot;</span>&#125;<br>&#125;;<br><span class="hljs-comment">//查询</span><br><span class="hljs-built_in">string</span> name = map[<span class="hljs-number">15937</span>];<br><span class="hljs-comment">//删除</span><br>map.Remove(<span class="hljs-number">10583</span>);<br><span class="hljs-keyword">foreach</span>(<span class="hljs-keyword">var</span> kv <span class="hljs-keyword">in</span> map)<br>&#123;<br>    Console.WriteLine(kv.Key+<span class="hljs-string">&quot;-&gt;&quot;</span>kv.Value);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>我们可以通过哈希函数得到该<code>key</code>对应的键值对在数组中的存储位置。</strong></li></ul><p>输入一个key，哈希函数的计算过程可分为以下两步。</p><ol><li>通过某种哈希算法hash()计算得到哈希值</li><li>将哈希值对桶数量（数组长度）capacity取模，从而获取该key对应的数组索引index</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">index = hash(key)%capacity<br></code></pre></td></tr></table></figure><h3 id="哈希冲突与扩容"><a href="#哈希冲突与扩容" class="headerlink" title="哈希冲突与扩容"></a>哈希冲突与扩容</h3><p>哈希函数的作用是将所有key构成的输入空间映射到数组所有索引构成的输出空间，而输入空间往往远大于输出空间。</p><ul><li><strong>理论上一定存在“多个输入对应相同输出”的情况，这种情况称为【哈希冲突 hash collision】</strong></li></ul><p>当哈希表容量n越大，多个key被分配到同一个桶中的概率就越低，冲突就越少。</p><ul><li><strong>可以通过扩容哈希表来减少哈希冲突</strong></li></ul><h3 id="哈希算法的目标"><a href="#哈希算法的目标" class="headerlink" title="哈希算法的目标"></a>哈希算法的目标</h3><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h1 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h1><h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C# System</title>
    <link href="/2024/04/09/C-sharp%20System/"/>
    <url>/2024/04/09/C-sharp%20System/</url>
    
    <content type="html"><![CDATA[<h1 id="IDisposable"><a href="#IDisposable" class="headerlink" title="IDisposable"></a>IDisposable</h1><p>示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.ComponentModel;<br><br><span class="hljs-comment">// 以下示例演示了如何创建一个实现 IDisposable 接口</span><br><span class="hljs-comment">// 和 IDisposable.Dispose 方法的资源类。</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DisposeExample</span><br>&#123;<br>    <span class="hljs-comment">// 实现 IDisposable 的基类。</span><br>    <span class="hljs-comment">// 通过实现 IDisposable，你在声明</span><br>    <span class="hljs-comment">// 这种类型的实例分配了稀缺资源。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyResource</span>: <span class="hljs-title">IDisposable</span><br>    &#123;<br>        <span class="hljs-comment">// 指向外部非托管资源的指针。</span><br>        <span class="hljs-keyword">private</span> IntPtr handle;<br>        <span class="hljs-comment">// 此类使用的其他托管资源。</span><br>        <span class="hljs-keyword">private</span> Component component = <span class="hljs-keyword">new</span> Component();<br>        <span class="hljs-comment">// 跟踪是否已调用 Dispose。</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> disposed = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// 类构造函数。</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyResource</span>(<span class="hljs-params">IntPtr handle</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">this</span>.handle = handle;<br>        &#125;<br><br>        <span class="hljs-comment">// 实现 IDisposable。</span><br>        <span class="hljs-comment">// 不要使此方法成为虚方法。</span><br>        <span class="hljs-comment">// 派生类不应能够重写此方法。</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dispose</span>()</span><br>        &#123;<br>            Dispose(disposing: <span class="hljs-literal">true</span>);<br>            <span class="hljs-comment">// 此对象将由 Dispose 方法清理。</span><br>            <span class="hljs-comment">// 因此，你应该调用 GC.SuppressFinalize 来</span><br>            <span class="hljs-comment">// 将此对象从终结队列中取出</span><br>            <span class="hljs-comment">// 并防止此对象的终结代码</span><br>            <span class="hljs-comment">// 执行第二次。</span><br>            GC.SuppressFinalize(<span class="hljs-keyword">this</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// Dispose(bool disposing) 在两种不同的场景中执行。</span><br>        <span class="hljs-comment">// 如果 disposing 等于 true，该方法已直接或间接</span><br>        <span class="hljs-comment">// 由用户的代码调用。可以处置托管和非托管资源。</span><br>        <span class="hljs-comment">// 如果 disposing 等于 false，该方法已由运行时从</span><br>        <span class="hljs-comment">// 终结器内部调用，你不应引用其他对象。只能处置非托管资源。</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dispose</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> disposing</span>)</span><br>        &#123;<br>            <span class="hljs-comment">// 检查是否已调用 Dispose。</span><br>            <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>.disposed)<br>            &#123;<br>                <span class="hljs-comment">// 如果 disposing 等于 true，处置所有托管</span><br>                <span class="hljs-comment">// 和非托管资源。</span><br>                <span class="hljs-keyword">if</span>(disposing)<br>                &#123;<br>                    <span class="hljs-comment">// 处置托管资源。</span><br>                    component.Dispose();<br>                &#125;<br><br>                <span class="hljs-comment">// 在此处调用适当的方法来清理</span><br>                <span class="hljs-comment">// 非托管资源。</span><br>                <span class="hljs-comment">// 如果 disposing 为 false，</span><br>                <span class="hljs-comment">// 只执行以下代码。</span><br>                CloseHandle(handle);<br>                handle = IntPtr.Zero;<br><br>                <span class="hljs-comment">// 注意已进行处置。</span><br>                disposed = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 使用互操作调用必要的方法</span><br>        <span class="hljs-comment">// 来清理非托管资源。</span><br>        [<span class="hljs-meta">System.Runtime.InteropServices.DllImport(<span class="hljs-string">&quot;Kernel32&quot;</span>)</span>]<br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">extern</span> <span class="hljs-keyword">static</span> Boolean <span class="hljs-title">CloseHandle</span>(<span class="hljs-params">IntPtr handle</span>)</span>;<br><br>        <span class="hljs-comment">// 使用 C# 终结器语法进行终结代码。</span><br>        <span class="hljs-comment">// 此终结器只会在未调用 Dispose 方法时运行。</span><br>        <span class="hljs-comment">// 它给予你的基类机会进行终结。</span><br>        <span class="hljs-comment">// 不要在此类派生的类型中提供终结器。</span><br>        ~MyResource()<br>        &#123;<br>            <span class="hljs-comment">// 不要在此处重新创建 Dispose 清理代码。</span><br>            <span class="hljs-comment">// 调用 Dispose(disposing: false) 在可读性和可维护性方面是最佳的。</span><br>            Dispose(disposing: <span class="hljs-literal">false</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 在此处插入代码以创建</span><br>        <span class="hljs-comment">// 并使用 MyResource 对象。</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>执行与释放或重置非托管资源关联的应用程序定义的任务。</p><h1 id="System-Text-Json-Serialization"><a href="#System-Text-Json-Serialization" class="headerlink" title="System.Text.Json.Serialization"></a>System.Text.Json.Serialization</h1><h2 id="System-Attribute"><a href="#System-Attribute" class="headerlink" title="System.Attribute"></a>System.Attribute</h2><h2 id="System-GC"><a href="#System-GC" class="headerlink" title="System.GC"></a>System.GC</h2><p>Garbage Collector一个提供垃圾回收服务的类，垃圾回收器负责自动管理程序的内存分配和释放，不需要手动释放对象或管理内存</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#实例</title>
    <link href="/2024/04/09/C-sharp%E5%AE%9E%E4%BE%8B/"/>
    <url>/2024/04/09/C-sharp%E5%AE%9E%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="读取并编辑json数据"><a href="#读取并编辑json数据" class="headerlink" title="读取并编辑json数据"></a>读取并编辑json数据</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> Newtonsoft.Json;<br><span class="hljs-keyword">using</span> Newtonsoft.Json.Linq;<br><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.IO;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DoJson</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//读取外部json格式文件</span><br>        <span class="hljs-built_in">string</span> json = File.ReadAllText(<span class="hljs-string">@&quot;C:\Users\rolen\Documents\example\example_3.json&quot;</span>);<br>        <span class="hljs-comment">//反序列化json数据为.net对象</span><br>        JObject jo1 = (JObject)JsonConvert.DeserializeObject(json);<br>        <span class="hljs-comment">//第一层</span><br>        <span class="hljs-built_in">string</span> name = jo1[<span class="hljs-string">&quot;netbarname&quot;</span>].ToString();<br>        <span class="hljs-built_in">string</span> netbarCameraList = jo1[<span class="hljs-string">&quot;netbarCameraList&quot;</span>].ToString();<br>        Console.WriteLine(name);<br>        Console.WriteLine(netbarCameraList);<br>        <span class="hljs-comment">//第二层</span><br>        <span class="hljs-built_in">string</span> account = jo1[<span class="hljs-string">&quot;netbarCameraList&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;account&quot;</span>].ToString();<br>        Console.WriteLine(account);<br>        <span class="hljs-keyword">var</span> gid = jo1[<span class="hljs-string">&quot;netbarCameraList&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;gid&quot;</span>];<br>        <span class="hljs-built_in">int</span> gidValue = <span class="hljs-built_in">int</span>.Parse(gid.ToString());<br>        jo1[<span class="hljs-string">&quot;netbarCameraList&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;gid&quot;</span>] = gidValue * <span class="hljs-number">3</span>;<br>        Console.WriteLine(<span class="hljs-string">&quot;New gid value is:&quot;</span>+jo1[<span class="hljs-string">&quot;netbarCameraList&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;gid&quot;</span>]);<br>        String newjson =JsonConvert.SerializeObject(jo1,Formatting.Indented);<br>        File.WriteAllText(<span class="hljs-string">@&quot;C:\Users\rolen\Documents\example\example_3.json&quot;</span>,newjson);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment"><span class="hljs-doctag">///</span>Copyright(c) 2022,uZone All rights reserved.</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span>摘要：.json提取label数据脚本</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span>作者：Homovexillues</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span>日期：2024年4月3日</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span>说明：</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span>修订：</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span></span><br><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> Newtonsoft.Json;<br><span class="hljs-keyword">using</span> Newtonsoft.Json.Linq;<br><span class="hljs-keyword">using</span> YamlDotNet.Serialization;<br><br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">DoJson</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">JsonSerialzer</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Serialize</span>(<span class="hljs-params">JObject jo1, <span class="hljs-built_in">string</span> filePath</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">string</span> newJson = JsonConvert.SerializeObject(jo1, Formatting.Indented);<br>            File.WriteAllText(filePath, newJson);<br><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">JsonTools</span><br>    &#123;<br>        <span class="hljs-comment">//定义属性</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> x &#123;  <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> new_x &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> y &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> new_y &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> width &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;   <br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> new_width &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> height &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> new_height &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> image_width &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> image_height &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? type &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> new_type &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> frameIndex &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> instanceCount &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> framesCount &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> picture_frameIndex &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? imageUrl &#123;  <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? imageName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> imageFrameIndex &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? id &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> counter_keyhole &#123;<span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> counter_light&#123;<span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> counter_license_plate &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> counter_wheel &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> counter_bottom_edge &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> counter_side_bumper &#123;  <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> counter_supporting_leg &#123;  <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> jsonfilePath &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> targetfilePath &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> yamlfilePath &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Data_a</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a</span>)</span><br>        &#123;<br>            JObject jo1 = (JObject)JsonConvert.DeserializeObject(jsonfilePath);<br>            <span class="hljs-keyword">var</span> ymds = <span class="hljs-keyword">new</span> Deserializer();<br>            <span class="hljs-keyword">var</span> yamlObject = ymds.Deserialize&lt;<span class="hljs-built_in">dynamic</span>&gt;(<span class="hljs-keyword">new</span> StreamReader(yamlfilePath));<br>            <span class="hljs-keyword">var</span> c_names = yamlObject[<span class="hljs-string">&quot;c_names&quot;</span>];<br>            <br>            x = <span class="hljs-built_in">double</span>.Parse(jo1[<span class="hljs-string">&quot;instances&quot;</span>][a][<span class="hljs-string">&quot;children&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;cameras&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;frames&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;shape&quot;</span>][<span class="hljs-string">&quot;x&quot;</span>].ToString());<br>            y = <span class="hljs-built_in">double</span>.Parse(jo1[<span class="hljs-string">&quot;instances&quot;</span>][a][<span class="hljs-string">&quot;children&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;cameras&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;frames&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;shape&quot;</span>][<span class="hljs-string">&quot;y&quot;</span>].ToString());<br>            width = <span class="hljs-built_in">double</span>.Parse(jo1[<span class="hljs-string">&quot;instances&quot;</span>][a][<span class="hljs-string">&quot;children&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;cameras&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;frames&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;shape&quot;</span>][<span class="hljs-string">&quot;width&quot;</span>].ToString());<br>            height = <span class="hljs-built_in">double</span>.Parse(jo1[<span class="hljs-string">&quot;instances&quot;</span>][a][<span class="hljs-string">&quot;children&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;cameras&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;frames&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;shape&quot;</span>][<span class="hljs-string">&quot;height&quot;</span>].ToString());<br>            image_width = <span class="hljs-built_in">double</span>.Parse(jo1[<span class="hljs-string">&quot;frames&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;frames&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;imageWidth&quot;</span>].ToString());<br>            image_height = <span class="hljs-built_in">double</span>.Parse(jo1[<span class="hljs-string">&quot;frames&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;frames&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;imageHeight&quot;</span>].ToString());<br>            type = jo1[<span class="hljs-string">&quot;instances&quot;</span>][a][<span class="hljs-string">&quot;categoryName&quot;</span>].ToString();<br>            frameIndex = <span class="hljs-built_in">int</span>.Parse((jo1[<span class="hljs-string">&quot;instances&quot;</span>][a][<span class="hljs-string">&quot;children&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;cameras&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;frames&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;frameIndex&quot;</span>]).ToString());<br>            id = jo1[<span class="hljs-string">&quot;instances&quot;</span>][a][<span class="hljs-string">&quot;children&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;id&quot;</span>].ToString();<br><br>            <span class="hljs-comment">//处理图片数据 </span><br>            new_x = Math.Round(((x + width / <span class="hljs-number">2</span>) / image_width), <span class="hljs-number">6</span>);<br>            new_y = Math.Round(((y + height / <span class="hljs-number">2</span>) / image_height), <span class="hljs-number">6</span>);<br>            new_width = Math.Round((width / image_width), <span class="hljs-number">6</span>);<br>            new_height = Math.Round((height / image_height), <span class="hljs-number">6</span>);<br>            <span class="hljs-comment">//根据从yaml中读到的对应关系，将物品种类与数字对应</span><br>            <span class="hljs-keyword">if</span> (type == c_names[<span class="hljs-number">0</span>])<br>            &#123;<br><br>                new_type = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == c_names[<span class="hljs-number">1</span>])<br>            &#123;<br><br>                new_type = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == c_names[<span class="hljs-number">2</span>])<br>            &#123;<br><br>                new_type = <span class="hljs-number">2</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == c_names[<span class="hljs-number">3</span>])<br>            &#123;<br><br>                new_type = <span class="hljs-number">3</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == c_names[<span class="hljs-number">4</span>])<br>            &#123;<br><br>                new_type = <span class="hljs-number">4</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == c_names[<span class="hljs-number">5</span>])<br>            &#123;<br><br>                new_type = <span class="hljs-number">5</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == c_names[<span class="hljs-number">6</span>])<br>            &#123;<br><br>                new_type = <span class="hljs-number">6</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Data_b</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> b</span>)</span><br>        &#123;<br>            JObject jo1 = (JObject)JsonConvert.DeserializeObject(jsonfilePath);<br>            picture_frameIndex = <span class="hljs-built_in">int</span>.Parse(jo1[<span class="hljs-string">&quot;frames&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;frames&quot;</span>][b][<span class="hljs-string">&quot;frameIndex&quot;</span>].ToString());<br>            imageUrl = jo1[<span class="hljs-string">&quot;frames&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;frames&quot;</span>][b][<span class="hljs-string">&quot;imageUrl&quot;</span>].ToString();<br>            imageName = Path.GetFileName(imageUrl).Replace(<span class="hljs-string">&quot;.jpg&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>            imageFrameIndex = <span class="hljs-built_in">int</span>.Parse((jo1[<span class="hljs-string">&quot;frames&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;frames&quot;</span>][b][<span class="hljs-string">&quot;frameIndex&quot;</span>]).ToString());<br>        &#125;<br>        <span class="hljs-comment">//计数器 </span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Counter</span>()</span><br>        &#123;<span class="hljs-comment">//共标记了多少张图，每种图有多少张</span><br><br>            <span class="hljs-comment">//从yaml中提取集合数据</span><br>            <span class="hljs-keyword">var</span> ymds = <span class="hljs-keyword">new</span> Deserializer();<br>            <span class="hljs-keyword">var</span> yamlObject = ymds.Deserialize&lt;<span class="hljs-built_in">dynamic</span>&gt;(<span class="hljs-keyword">new</span> StreamReader(yamlfilePath));<br>            <span class="hljs-keyword">var</span> c_names = yamlObject[<span class="hljs-string">&quot;c_names&quot;</span>];<br><br>            <span class="hljs-keyword">if</span> (type == c_names[<span class="hljs-number">0</span>])<br>            &#123;<br>                counter_keyhole += <span class="hljs-number">1</span>;<br><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == c_names[<span class="hljs-number">1</span>])<br>            &#123;<br>                counter_light += <span class="hljs-number">1</span>;<br><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == c_names[<span class="hljs-number">2</span>])<br>            &#123;<br>                counter_license_plate += <span class="hljs-number">1</span>;<br><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == c_names[<span class="hljs-number">3</span>])<br>            &#123;<br>                counter_wheel += <span class="hljs-number">1</span>;<br><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == c_names[<span class="hljs-number">4</span>])<br>            &#123;<br>                counter_bottom_edge += <span class="hljs-number">1</span>;<br><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == c_names[<span class="hljs-number">5</span>])<br>            &#123;<br>                counter_side_bumper += <span class="hljs-number">1</span>;<br><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == c_names[<span class="hljs-number">6</span>])<br>            &#123;<br>                counter_supporting_leg += <span class="hljs-number">1</span>;<br><br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-comment">//三个参数（json文件位置，txt生成位置，yaml文件位置）已设置好默认位置，可手动修改</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">touch_txt</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> json_path= <span class="hljs-string">@&quot;C:\uzone\项目\2024\2024-02 PoC视觉\文档\图像训练第一批（20240403）\DataSet-HIT0805\raw.json&quot;</span>, <span class="hljs-built_in">string</span> target_path= <span class="hljs-string">@&quot;C:\uzone\项目\2024\2024-02 PoC视觉\文档\图像训练第一批（20240403）\DataSet-HIT0805\labels\train\&quot;</span>, <span class="hljs-built_in">string</span> yaml_path=<span class="hljs-string">@&quot;C:\uzone\项目\2024\2024-02 PoC视觉\文档\图像训练第一批（20240403）\HIT0403.yaml&quot;</span></span>)</span><br>        &#123;<br>            <span class="hljs-comment">//读取外部json格式文件</span><br>            jsonfilePath = File.ReadAllText(json_path);<br>            targetfilePath = target_path;<br>            yamlfilePath = yaml_path;<br>            JObject jo1 = (JObject)JsonConvert.DeserializeObject(jsonfilePath);<br>            <span class="hljs-built_in">int</span> instanceCount = ((JArray)jo1[<span class="hljs-string">&quot;instances&quot;</span>]).Count;<br>            <span class="hljs-built_in">int</span> framesCount = ((JArray)jo1[<span class="hljs-string">&quot;frames&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;frames&quot;</span>]).Count;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> b = <span class="hljs-number">0</span>; b &lt; framesCount; b++)<br>            &#123;<br>                Data_b(b);<br>                List&lt;<span class="hljs-built_in">string</span>&gt; toast_list = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">string</span>&gt;();<br>                <span class="hljs-built_in">string</span> text_name = imageName + <span class="hljs-string">&quot;.txt&quot;</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> a = <span class="hljs-number">0</span>; a &lt; instanceCount; a++)<br>                &#123;<br>                    <span class="hljs-comment">//从json中提取图片数据</span><br>                    Data_a(a);<br>                    <span class="hljs-built_in">string</span> toast_data = new_type + <span class="hljs-string">&quot; &quot;</span> + new_x + <span class="hljs-string">&quot; &quot;</span> + new_y + <span class="hljs-string">&quot; &quot;</span> + new_width + <span class="hljs-string">&quot; &quot;</span> + new_height;<br>                    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>)<br>                    &#123;<br>                        Counter();<br><br>                    &#125;<br>                    <span class="hljs-comment">//创建txt文档</span><br>                    <span class="hljs-keyword">if</span> (frameIndex == imageFrameIndex)<br>                    &#123;<br>                        toast_list.Add(toast_data);<br>                        File.WriteAllLines(targetfilePath + text_name, toast_list);<br>                    &#125;<br><br>                &#125;<br><br><br>            &#125;<br>            <span class="hljs-built_in">string</span> counter_data = <span class="hljs-string">$&quot;共标记了<span class="hljs-subst">&#123;instanceCount&#125;</span>张图，其中:\n锁洞(0)有<span class="hljs-subst">&#123;counter_keyhole&#125;</span>张\n车灯(1)有<span class="hljs-subst">&#123;counter_light&#125;</span>张\n车牌(2)有<span class="hljs-subst">&#123;counter_license_plate&#125;</span>张\n轮胎(3)有<span class="hljs-subst">&#123;counter_wheel&#125;</span>张\n集装箱底部(4)有<span class="hljs-subst">&#123;counter_bottom_edge&#125;</span>张\n护栏(5)有<span class="hljs-subst">&#123;counter_side_bumper&#125;</span>张\n撑脚有<span class="hljs-subst">&#123;counter_supporting_leg&#125;</span>张&quot;</span>;<br>            <span class="hljs-built_in">string</span> counter_path = <span class="hljs-string">@&quot;C:\uzone\项目\2024\2024-02 PoC视觉\文档\图像训练第一批（20240403）\&quot;</span>;<br>            File.WriteAllText(counter_path + <span class="hljs-string">&quot;Counter.txt&quot;</span>, counter_data);<br>        &#125;<br>    &#125;<br><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">OperateJson</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>        &#123;<br>            JsonTools jt = <span class="hljs-keyword">new</span> JsonTools();<br>            jt.touch_txt();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="从字符串中截取文件名-去掉字符串中的某部分"><a href="#从字符串中截取文件名-去掉字符串中的某部分" class="headerlink" title="从字符串中截取文件名&amp;去掉字符串中的某部分"></a>从字符串中截取文件名&amp;去掉字符串中的某部分</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//从地址中截取文件名</span><br><span class="hljs-built_in">string</span> yamlfilePath = <span class="hljs-string">@&quot;C:\Users\rolen\Documents\example\tangshan0805.yaml&quot;</span>;<br><span class="hljs-built_in">string</span> name = Path.GetFileName(yamlfilePath);<br><span class="hljs-comment">//去掉字符串中的某部分</span><br><span class="hljs-built_in">string</span> text = <span class="hljs-string">&quot;image.jpg&quot;</span>;<br><span class="hljs-built_in">string</span> name = text.Replace(<span class="hljs-string">&quot;.jpg&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-comment">//从字符串的第4个字符开始，提取长度为2的字符串</span><br><span class="hljs-built_in">string</span> name = text.SubString(<span class="hljs-number">4</span>,<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h3 id="从一个文件夹中抽取指定比例的文件转移到另一文件夹"><a href="#从一个文件夹中抽取指定比例的文件转移到另一文件夹" class="headerlink" title="从一个文件夹中抽取指定比例的文件转移到另一文件夹"></a>从一个文件夹中抽取指定比例的文件转移到另一文件夹</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Itype</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span>[]? allFiles &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span>[]? txtFiles &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span>[]? jsonFiles &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span>[]? jpgFiles &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sort</span>:<span class="hljs-title">Itype</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;<span class="hljs-built_in">string</span>&gt; fileNames = <span class="hljs-keyword">new</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Random rng = <span class="hljs-keyword">new</span>();<br><br>    <span class="hljs-comment">//向列表里添加内容</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addList</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] listName</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">string</span> fileName <span class="hljs-keyword">in</span> listName)<br>        &#123;<br>            <span class="hljs-keyword">var</span> name = Path.GetFileName(fileName);<br>            fileNames.Add(name);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//获取指定位置的所有文件名字添加到列表中</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getName</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> filePath</span>)</span><br>    &#123;<br>        <br>        Itype.allFiles = Directory.GetFiles(filePath);<br>        addList(Itype.allFiles);<br>    &#125;<br><br>    <span class="hljs-comment">//指定特定类型文档</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getName</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> filePath, <span class="hljs-built_in">string</span> type</span>)</span><br>    &#123;<br>        <br>        Itype.txtFiles = Directory.GetFiles(filePath, <span class="hljs-string">&quot;*.txt&quot;</span>);<br>        Itype.jsonFiles = Directory.GetFiles(filePath, <span class="hljs-string">&quot;*.json&quot;</span>);<br>        Itype.jpgFiles = Directory.GetFiles(filePath, <span class="hljs-string">&quot;*.jpg&quot;</span>);<br>        <span class="hljs-keyword">switch</span> (type)<br>        &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;txt&quot;</span>: addList(Itype.txtFiles); <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;json&quot;</span>: addList(Itype.jsonFiles); <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;jpg&quot;</span>: addList(Itype.jpgFiles); <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//随机抽指定比例的文件移动到另一文件夹</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">moveFile</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> sourcePath, <span class="hljs-built_in">string</span> targetPath,<span class="hljs-built_in">double</span> Rate</span>)</span><br>    &#123;<br>        getName(sourcePath);<br>        <span class="hljs-built_in">int</span> length = (<span class="hljs-built_in">int</span>)(fileNames.Count *(Rate));<br>        <span class="hljs-keyword">var</span> selectedFiles = fileNames.OrderBy(x =&gt; rng.Next()).Take(length);<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> file <span class="hljs-keyword">in</span> selectedFiles)<br>        &#123;<br>            <span class="hljs-keyword">var</span> sourceFile = Path.Combine(sourcePath, file);<br>            <span class="hljs-keyword">var</span> targetFile = Path.Combine(targetPath, file);<br>            File.Move(sourceFile, targetFile);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//string UnSortPictureFilePath = @&quot;C:\Users\rolen\Documents\Damage_picture（第二批）\&quot;;</span><br>        <span class="hljs-built_in">string</span> UnSortPictureFilePath = <span class="hljs-string">@&quot;C:\Users\rolen\Documents\Damage_picture（第二批）\train&quot;</span>;<br>        <span class="hljs-comment">//string SortedPictureFilePath = @&quot;C:\uzone\项目\2024\2024-02 PoC视觉\文档\图像训练第二批（20240407）\images\train\&quot;;</span><br>        <span class="hljs-built_in">string</span> SortedPictureFilePath = <span class="hljs-string">@&quot;C:\Users\rolen\Documents\Damage_picture（第二批）\val&quot;</span>;<br>        <br>        <span class="hljs-built_in">string</span> UnPickedLabeledFilePath = <span class="hljs-string">@&quot;C:\uzone\项目\2024\2024-02 PoC视觉\文档\图像训练第二批（20240407）\labels\train&quot;</span>;<br>        <span class="hljs-built_in">string</span> PickedLabledFilePath = <span class="hljs-string">@&quot;C:\uzone\项目\2024\2024-02 PoC视觉\文档\图像训练第二批（20240407）\labels\val\&quot;</span>;<br>        moveFile(UnSortPictureFilePath,SortedPictureFilePath,<span class="hljs-number">0.1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="编辑并处理EXCEl"><a href="#编辑并处理EXCEl" class="headerlink" title="编辑并处理EXCEl"></a>编辑并处理EXCEl</h3><p>使用NPOI</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> NPOI.SS.UserModel;<br><span class="hljs-keyword">using</span> NPOI.XSSF.UserModel;<span class="hljs-comment">//用于.xlsx</span><br><span class="hljs-keyword">using</span> NPOI.HSSF.UserModel;<span class="hljs-comment">//用于.xls</span><br></code></pre></td></tr></table></figure><h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> System;<br>Random random = <span class="hljs-keyword">new</span> Random();<br><span class="hljs-built_in">int</span> a = random.Next(<span class="hljs-number">1</span>,<span class="hljs-number">11</span>); <span class="hljs-comment">//1d10</span><br><span class="hljs-built_in">double</span> d = random.NextDouble();<span class="hljs-comment">//生成0到1的随机浮点数</span><br><span class="hljs-comment">//想要生成1.5到4.5之间的随机浮点数需要用</span><br><span class="hljs-built_in">double</span> real_d = min+(random.NextDouble()*(max-min));<br></code></pre></td></tr></table></figure><h2 id="批量生成数字"><a href="#批量生成数字" class="headerlink" title="批量生成数字"></a>批量生成数字</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">var</span> a = Enumerable.Repeat(<span class="hljs-number">1</span>, <span class="hljs-number">50</span>).ToList();<br><span class="hljs-comment">//生成包含50个1的List</span><br><span class="hljs-comment">//配合上面的随机数即可做出多d10的效果</span><br><span class="hljs-keyword">var</span> b = Enumerable.Repeat(<span class="hljs-number">1</span>, <span class="hljs-number">50</span>).Select(_=&gt;random.Next(<span class="hljs-number">1</span>,<span class="hljs-number">11</span>)).ToList();<br><span class="hljs-comment">//NextDouble可以生成0-1以内的随机小数，可以以此生成一定范围内的数据</span><br><span class="hljs-keyword">var</span> c = Enumerable.Repeat(<span class="hljs-number">1</span>, <span class="hljs-number">50</span>).Select(_=&gt;<span class="hljs-number">10</span>+(random.NextDouble()*<span class="hljs-number">2</span><span class="hljs-number">-1</span>)).ToList();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>报错和警告</title>
    <link href="/2024/04/09/%E6%8A%A5%E9%94%99%E5%92%8C%E8%AD%A6%E5%91%8A/"/>
    <url>/2024/04/09/%E6%8A%A5%E9%94%99%E5%92%8C%E8%AD%A6%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="warning"><a href="#warning" class="headerlink" title="warning"></a>warning</h2><ul><li><pre><code class="hljs">warning: in the working copy of &#39;tags/index.html&#39;, LF will be replaced by CRLF the next time Git touches it<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>- 这个警告是关于 Git 处理换行符的。在 Unix 系统（如 Linux 或 Mac）中，文本文件的行通常以 LF (Line Feed) 结尾，而在 Windows 中，它们通常以 CRLF (Carriage <span class="hljs-keyword">Return</span> Line Feed) 结尾。<br><br>- Git 有一个叫做 `core.autocrlf` 的设置，它可以帮助在不同系统间转换这些换行符。如果你在 Windows 上看到这个警告，那可能是因为你的 `core.autocrlf` 设置为 `true`。这意味着当你检出代码时，Git 会把 LF 转换为 CRLF，当你提交代码时，Git 会把 CRLF 转换回 LF。<br>- **这个警告的意思是**，当 Git 下一次触碰到 ‘tags/index.html’ 文件时，它会把文件中的 LF 换行符替换为 CRLF。这通常不会影响你的工作，除非你正在和期望保持 LF 换行符的系统（如某些 Unix 系统）共享代码。<br><br>- 如果你想关闭这个警告，你可以设置 `core.autocrlf` 为 `input`（在 Unix 系统上）或 `false`（在 Windows 系统上）。这样 Git 就不会试图转换换行符了。你可以用以下命令来改变这个设置：<br><br>  ```bash<br>  git config --global core.autocrlf <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>- 但是请注意，这可能会影响到你与其他系统共享代码的能力。在改变这个设置之前，最好先了解一下它的后果。如果你正在一个团队中工作，那么最好与你的团队成员商量一下这个设置应该设为什么。如果你是独自工作，那么你可以根据你的需要来设置。如果你不确定，那么保持默认设置（`core.autocrlf=true` 在 Windows 上，`core.autocrlf=input` 在 Unix 上）通常是最安全的选择。</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Microsoft Learn C-sharp 第二部分</title>
    <link href="/2024/04/06/Microsoft%20Learn%20C-sharp%20%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/"/>
    <url>/2024/04/06/Microsoft%20Learn%20C-sharp%20%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="安装并配置Visual-Studio-Code"><a href="#安装并配置Visual-Studio-Code" class="headerlink" title="安装并配置Visual Studio Code"></a>安装并配置Visual Studio Code</h1><h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><ul><li>下载并安装Visual Studio Code</li><li>检查Visual Studio Code用户界面</li><li>配置Visual Studio Code以使用C#扩展</li><li>安装.NET运行库</li><li>构建并运行控制台应用程序</li></ul><h2 id="练习-安装-NET-SDK"><a href="#练习-安装-NET-SDK" class="headerlink" title="练习-安装.NET SDK"></a>练习-安装.NET SDK</h2><p>.NET是一个跨平台的开源开发人员平台</p><h3 id="检查是否已安装-NET"><a href="#检查是否已安装-NET" class="headerlink" title="检查是否已安装.NET"></a>检查是否已安装.NET</h3><p>终端输入<code>dotnet --version</code></p><h3 id="安装-NET-8软件开发工具包"><a href="#安装-NET-8软件开发工具包" class="headerlink" title="安装.NET 8软件开发工具包"></a>安装.NET 8软件开发工具包</h3><h4 id="Windows上安装"><a href="#Windows上安装" class="headerlink" title="Windows上安装"></a>Windows上安装</h4><p>官网直接安装即可</p><p><a href="https://dotnet.microsoft.com/download">https://dotnet.microsoft.com/download</a></p><h4 id="Linux上安装"><a href="#Linux上安装" class="headerlink" title="Linux上安装"></a>Linux上安装</h4><h5 id="命令安装"><a href="#命令安装" class="headerlink" title="命令安装"></a>命令安装</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install dotnet-sdk-8.0<br></code></pre></td></tr></table></figure><h5 id="脚本安装"><a href="#脚本安装" class="headerlink" title="脚本安装"></a>脚本安装</h5><p>使用wget下载安装脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://dot.net/v1/dotnet-install.sh -O dotnet-install.sh<br></code></pre></td></tr></table></figure><p>运行此脚本之后，确保授予此脚本作为可执行文件运行的权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x ./dotnet-install.sh<br></code></pre></td></tr></table></figure><p>默认安装最新的长期支持（LTS）SDK版本，即.NET 8</p><h2 id="练习-创建、生成和运行应用程序"><a href="#练习-创建、生成和运行应用程序" class="headerlink" title="练习-创建、生成和运行应用程序"></a>练习-创建、生成和运行应用程序</h2><p>.NET软件开发工具包（SDK）包括一个可通过终端访问的命令行界面（CLI）。可以按照如下命令在指定文件夹位置生成一个新的控制台应用程序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dotnet new console -o ./CsharpProjects/TestProject<br></code></pre></td></tr></table></figure><p>命令参数是可选参数，如果不指定参数的话<code>dotnet new console</code>会在当前文件夹下创建新的控制台应用。</p><p>若要对应用程序的生成进行编译，可以使用以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dotnet build<br></code></pre></td></tr></table></figure><p>运行应用程序可用以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dotnet run<br></code></pre></td></tr></table></figure><h1 id="使用C-从-NET类库调用方法"><a href="#使用C-从-NET类库调用方法" class="headerlink" title="使用C#从.NET类库调用方法"></a>使用C#从.NET类库调用方法</h1><p>类库就像是巫师的魔法书一样，当然，前提是你施法必须有魔法书，或者法杖。</p><h3 id="学习目标-1"><a href="#学习目标-1" class="headerlink" title="学习目标"></a>学习目标</h3><ul><li>编写用于调用.NET类库中的方法的代码。</li><li>使用.NET类库类的新实例，以调用维护状态的方法。</li><li>使用Visual Studio Code中的Intellisense深入了解方法，包括其重载版本、其返回值类型及其输入参数数据类型。</li><li>使用learn.microsoft.com来研究方法的作用、其重载版本、其返回类型、其输入参数和每个参数所代表的内容等等。</li></ul><h2 id="NET库入门"><a href="#NET库入门" class="headerlink" title=".NET库入门"></a>.NET库入门</h2><p>当需要.NET运行时，用于在最终用户的计算机上执行代码时托管并管理代码。还将依赖于.NET类库，这是一个科长应用程序中使用的预先编写的编码资源集合。此单元介绍.NET类库的定义以及该类库对C#编程语言的补充方式。</p><h3 id="什么是-NET类库？"><a href="#什么是-NET类库？" class="headerlink" title="什么是.NET类库？"></a>什么是.NET类库？</h3><p>包含上千万个方法的数以千计的类的集合。如.NET类库包含<code>Console</code>类，供处理控制台应用程序的开发人员使用。<code>Console</code>类包含用于输入和输出操作的方法，如<code>Write()</code>、<code>WriteLine()</code>、<code>Read()</code>、<code>ReadLine()</code>等。</p><p>可以将类视为魔法书，法师通常需要将相关咒语保留在一本书中。</p><p>在许多情况下，可使用这些类和方法构建特定类型的应用程序。例如，可使用包含类和方法的一个较大子集创建动态Web应用程序。还存在好几个系列的类，使你能生成本机桌面应用程序，可使用另一个类和方法的子集访问数据库。.NET类库中有许多支持特定类型的应用程序的类。</p><h3 id="甚至数据类型也是-NET类型库的一部分"><a href="#甚至数据类型也是-NET类型库的一部分" class="headerlink" title="甚至数据类型也是.NET类型库的一部分"></a>甚至数据类型也是.NET类型库的一部分</h3><p>C#数据类型，例如(<code>string</code>和<code>int</code>)实际上是通过.NET类库中的类提供的。C#语言会屏蔽数据类型和.NET类之间的连接，以简化工作。但在幕后，数据类型的实现方式与.NET类库中的每个其他类都一样。此连接为日常变量提供了非常有用的内置方法。</p><h3 id="如何在-NET类库中查找所需的内容"><a href="#如何在-NET类库中查找所需的内容" class="headerlink" title="如何在.NET类库中查找所需的内容"></a>如何在.NET类库中查找所需的内容</h3><p>就像在图书馆中看书一样，你不会知道图书馆中所有区域是怎样的，但是如果你比较喜欢一类的书，你会对那部分比较熟悉。</p><h2 id="练习-调用-NET类的方法"><a href="#练习-调用-NET类的方法" class="headerlink" title="练习-调用.NET类的方法"></a>练习-调用.NET类的方法</h2><h3 id="调用-NET类库中不同种类的方法"><a href="#调用-NET类库中不同种类的方法" class="headerlink" title="调用.NET类库中不同种类的方法"></a>调用.NET类库中不同种类的方法</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#">Random dice = <span class="hljs-keyword">new</span> Random();<br><span class="hljs-built_in">int</span> roll = dice.Next(<span class="hljs-number">1</span>,<span class="hljs-number">7</span>);<br>Console.WriteLine(roll);<br></code></pre></td></tr></table></figure><p>在最后一句的代码中，包括对<code>Console</code>类的引用并直接调用<code>Console.WriteLine()</code>方法。不过，使用另一种技术调用<code>Random.Next()</code>方法。使用两种不同的技术进行调用的原因是，有些方法是有状态的，有些方法是无状态的，下一步是检查有状态方法和无状态方法之间的差异。</p><h3 id="有状态方法和无状态方法"><a href="#有状态方法和无状态方法" class="headerlink" title="有状态方法和无状态方法"></a>有状态方法和无状态方法</h3><p>在软件开发项目中，“状态”这个词用于描述执行环境在特定时刻的状态。代码逐行执行时，值存储在变量中在执行过程中的任何时候，应用程序当前的状态为存储在内存中的所有值的集合。</p><p>某些方法的正常工作不依赖于应用程序当前的状态。换言之，实现<strong>无状态方法</strong>是为了在不引用或更改内存中存储的任何值的情况下正常工作。无状态方法也被称为<strong>静态方法</strong>。</p><p>例如<code>Console.WriteLine()</code>方法不依赖于内存中存储的任何值。该方法执行其函数并完成工作，而不会以任何方式影响应用程序的状态。</p><p>但是，其他方法必须有权访问应用程序的状态，才能正常工作。换言之，有状态方法的构建方式使得这些方法依赖于先前已执行的代码行存储在内存中的值。或者，有状态方法通过更新值或新值存储在内存中来修改应用程序的状态。它们也称为<strong>实例方法</strong>。</p><p>有状态（实例方法）在字段中跟踪方法的状态，这些字段是在类上定义的变量。对于存储状态的这些字段，类的每个新实例都将获取其自己的副本。</p><p>单个类可支持有状态方法和 无状态方法。但是，需要调用有状态方法时，唏嘘首先创建类的实例，这样方法才能访问状态。</p><h3 id="创建类的实例"><a href="#创建类的实例" class="headerlink" title="创建类的实例"></a>创建类的实例</h3><p>类的实例称为对象。若要创建类的新实例，请使用<code>new</code>运算符。</p><p>下面这行代码可以创建<code>Random</code>类的新实例，以此创建名为<code>dice</code>的新对象</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">Random dice = <span class="hljs-keyword">new</span> Random();<br></code></pre></td></tr></table></figure><p><code>new</code>运算符执行以下几项重要操作</p><ul><li>首先请求足够大的计算机内存地址，用于存储基于<code>Random</code>类的新对象</li><li>创建新的对象，并将其存储在内存地址上</li><li>返回内存地址，使其保存在<code>dice</code>变量中</li></ul><p>从此时起，引用<code>dice</code>变量时，.NET运行时在幕后执行查找操作，这会造成一种直接使用对象本身的假象。</p><p>使用最新版本的.NET运行时可以实例化对象，而无需重复类型名称（目标类型的构造函数调用）。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">Random dice = <span class="hljs-keyword">new</span>();<br></code></pre></td></tr></table></figure><h3 id="为什么Next-方法是有状态的"><a href="#为什么Next-方法是有状态的" class="headerlink" title="为什么Next()方法是有状态的"></a>为什么Next()方法是有状态的</h3>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C-sharp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Microsoft Learn C-sharp 第一部分</title>
    <link href="/2024/04/04/Microsoft%20Learn%20C-sharp%20%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/"/>
    <url>/2024/04/04/Microsoft%20Learn%20C-sharp%20%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p>发现了微软官网的一个很有意思的教程，跟着再过一遍C#</p><h1 id="第一单元"><a href="#第一单元" class="headerlink" title="第一单元"></a>第一单元</h1><h2 id="练习-编写第一个代码"><a href="#练习-编写第一个代码" class="headerlink" title="练习- 编写第一个代码"></a>练习- 编写第一个代码</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">Console.WriteLine(<span class="hljs-string">&quot;hello world&quot;</span>);<br></code></pre></td></tr></table></figure><p>C#是大小写敏感的语言，对C#来说Console和console是完全不同的意思</p><p>如果用’hello world’会报错“Too many characters in character literal”（自变量）</p><p>代码编辑器会对代码进行预编译来监视潜在错误。</p><p>Console.WriteLine()比Console.Write()多加了个换行符</p><h2 id="了解工作原理"><a href="#了解工作原理" class="headerlink" title="了解工作原理"></a>了解工作原理</h2><p>这里我使用了一些个人色彩的解释而非较为严谨的解释，旨在传递感受。</p><h3 id="什么是编程语言"><a href="#什么是编程语言" class="headerlink" title="什么是编程语言"></a>什么是编程语言</h3><p>粤语（如果你不是以粤语为第一语言的话）</p><h3 id="什么是编译"><a href="#什么是编译" class="headerlink" title="什么是编译"></a>什么是编译</h3><p>广东翻译将粤语翻译成英语</p><h3 id="什么是语法"><a href="#什么是语法" class="headerlink" title="什么是语法"></a>什么是语法</h3><p>语法就是语法，你说话的方法，就像蜈蚣不会在意自己是从第几只脚开始走路一样，使用语法的人也不会在意自己说话是主谓宾还是定状补</p><h3 id="代码是如何工作的"><a href="#代码是如何工作的" class="headerlink" title="代码是如何工作的"></a>代码是如何工作的</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">Console.WriteLine(<span class="hljs-string">&quot;Hello World&quot;</span>);<br></code></pre></td></tr></table></figure><p>以上面的代码为例</p><p>Console部分称为【类】。【类】拥有【方法】，或者说【方法】存在于【类】中，若要访问方法 ，必须直到方法所在的类。</p><p>一个“.”将类和方法分隔，这是【成员访问运算符】。</p><p>WriteLine后的“（）”是【方法调用运算符】。</p><p>“；”是【句尾运算符】，语句是C#中的问政指令，分号指示编译器你已经完成了命令的输入。</p><h3 id="理解执行流"><a href="#理解执行流" class="headerlink" title="理解执行流"></a>理解执行流</h3><p>代码指令按顺序执行，一次一行，直到没有更多要执行的指令。某些指令要求CPU等待，其他指令可用于更改执行流。</p><h2 id="挑战：在-NET编辑器中编写代码，以显示两条消息"><a href="#挑战：在-NET编辑器中编写代码，以显示两条消息" class="headerlink" title="挑战：在.NET编辑器中编写代码，以显示两条消息"></a>挑战：在.NET编辑器中编写代码，以显示两条消息</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Output">This is the first line.<br>This is the second line.<br></code></pre></td></tr></table></figure><h2 id="查看解决方案"><a href="#查看解决方案" class="headerlink" title="查看解决方案"></a>查看解决方案</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#">Console.WriteLine(<span class="hljs-string">&quot;This is the first line.&quot;</span>);<br>Console.Write(<span class="hljs-string">&quot;This is &quot;</span>);<br>Console.Write(<span class="hljs-string">&quot;the second &quot;</span>);<br>Console.Write(<span class="hljs-string">&quot;line.&quot;</span>);<br></code></pre></td></tr></table></figure><h1 id="第二单元"><a href="#第二单元" class="headerlink" title="第二单元"></a>第二单元</h1><h2 id="练习-打印文本值"><a href="#练习-打印文本值" class="headerlink" title="练习- 打印文本值"></a>练习- 打印文本值</h2><h3 id="什么是文本值"><a href="#什么是文本值" class="headerlink" title="什么是文本值"></a>什么是文本值</h3><p>文本值是一种永不更改的常量值,用于演示而非计算。</p><h3 id="使用字符文本"><a href="#使用字符文本" class="headerlink" title="使用字符文本"></a>使用字符文本</h3><p>如果只希望将单个字母数字字符打印到屏幕，可以用单引号将一个字母数字字符括起来，创建char类型文本。</p><p><code>char</code>这个词是character（字符）的缩写。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">Console.WriteLine(<span class="hljs-string">&#x27;b&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="使用整数文本"><a href="#使用整数文本" class="headerlink" title="使用整数文本"></a>使用整数文本</h3><p>如果要将数字整数（无小数位）值显示在“输出”控制台中，可以使用int类型文本。<code>int</code>是integer（整数）的缩写。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">Console.WriteLine(<span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure><h3 id="使用浮点文本"><a href="#使用浮点文本" class="headerlink" title="使用浮点文本"></a>使用浮点文本</h3><p>浮点数是包含小数的数字，如3.1415926535。C#支持3种表示十进制数的数据类型：<code>float</code>、<code>double</code>和<code>decimal</code>。每种类型支持不同精度程度。</p><ul><li>float ~6-9 digits</li><li>double ~15-17 digits</li><li>decimal 28-29 digits</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">Console.WriteLine(<span class="hljs-number">0.25F</span>);<br></code></pre></td></tr></table></figure><p>若要创建Float类型文本可以在数字后加上字母F。在此上下文中，F称为文本后缀，文本后缀告诉编译器希望使用float类型的值。可使用小写的f或大写的F作为文本后缀。</p><p>输入小数不添加后缀编译器默认为double类型文本。</p><p>如果追加文本后缀<code>m</code>则指定为decimal类型。</p><h3 id="使用布尔文本"><a href="#使用布尔文本" class="headerlink" title="使用布尔文本"></a>使用布尔文本</h3><p><code>bool</code>是Boolean（布尔）的缩写</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#">Console.WriteLine(<span class="hljs-literal">true</span>)<br>Console.WriteLine(<span class="hljs-literal">false</span>)<br></code></pre></td></tr></table></figure><h2 id="数据类型定义功能"><a href="#数据类型定义功能" class="headerlink" title="数据类型定义功能"></a>数据类型定义功能</h2><h2 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h2><h3 id="什么是变量"><a href="#什么是变量" class="headerlink" title="什么是变量"></a>什么是变量</h3><p>变量是用于存储某个类型的值的容器。程序在执行过程中可以分配，读取和更改变量。</p><p>变量名称是编译器分配给内存地址的易记标签。需要将值存储在内存地址或更改该内存地址中的值时，或者每当需要检索存储的值时，只需要使用变量名称即可。</p><h3 id="声明变量-1"><a href="#声明变量-1" class="headerlink" title="声明变量"></a>声明变量</h3><p>要创建新的变量，必须先声明变量的数据类型，然后为其指定名称。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">string</span> firstName;<br></code></pre></td></tr></table></figure><p>可以选择任何名称，只要符合C#语法规则。</p><h3 id="变量名称规则和约定"><a href="#变量名称规则和约定" class="headerlink" title="变量名称规则和约定"></a>变量名称规则和约定</h3><p>注意事项</p><ul><li>变量名可以包含字母数字下划线，但不能用如哈希符号<code>#</code>或美元符号<code>$</code>等特殊字符</li><li>变量名必须以字母或下划线开头，不能以数字开头</li><li>变量名区分大小写</li><li>变量名不能为C#关键字，如<code>int</code>、<code>decimal</code>或<code>string</code></li></ul><p>一下是一些编码约定：</p><ul><li><p>变量名应使用驼峰式大小写形式，即第一个单词以小写字母开头，后续每个单词的首字母采用大写格式</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">string</span> thisIsCamelCase;<br></code></pre></td></tr></table></figure></li><li><p>变量名应以字母开头，以下划线开头用于特殊目的</p></li><li><p>变量名称在应用中应为有意义的描述性名称。</p></li><li><p>变量名应该是附加在一起的一个或多个完整字词，如非必要，不要使用缩写，以降低代码的阅读理解难度。</p></li><li><p>变量名应不包含变量的数据类型。</p></li></ul><h3 id="变量名称实例"><a href="#变量名称实例" class="headerlink" title="变量名称实例"></a>变量名称实例</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">char</span> userOption;<br><span class="hljs-built_in">int</span> gameScore;<br><span class="hljs-built_in">decimal</span> particlesPerMillion;<br><span class="hljs-built_in">bool</span> processedCustomer;<br></code></pre></td></tr></table></figure><h2 id="练习-设置变量中的值并从中获取值"><a href="#练习-设置变量中的值并从中获取值" class="headerlink" title="练习-设置变量中的值并从中获取值"></a>练习-设置变量中的值并从中获取值</h2><h2 id="声明隐式类型本地变量"><a href="#声明隐式类型本地变量" class="headerlink" title="声明隐式类型本地变量"></a>声明隐式类型本地变量</h2><h3 id="什么是隐式类型本地变量？"><a href="#什么是隐式类型本地变量？" class="headerlink" title="什么是隐式类型本地变量？"></a>什么是隐式类型本地变量？</h3><p>隐式类型本地变量是使用<code>var</code>关键字创建的，然后对其进行变量初始化。例如 :</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">var</span> massage = <span class="hljs-string">&quot;Hello World&quot;</span>;<br></code></pre></td></tr></table></figure><p>在此示例中，字符串变量是使用<code>var</code>关键字而不是<code>string</code>关键字创建的。</p><p><code>var</code>关键字告知C#编译器数据类型由分配的值暗示。暗示类型后，变量的行为与使用实际数据类型来声明它的行为相同。当类型很长或在上下文中明显可见时，<code>var</code>关键字用于减少击键次数。</p><p>在上面的实例中，由于变量message会被立即设置为<code>string</code>值”Hello World”，因此C#编译器了解其意向并将每个message实例视为<code>string</code>类型实例。</p><p>事实上，message变量的类型为string，且永远无法更改，如下代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">var</span> message = <span class="hljs-string">&quot;Hello World&quot;</span>;<br>message = <span class="hljs-number">10.703</span>m;<br></code></pre></td></tr></table></figure><p>如果运行此代码，将看到以下错误信息：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">(2,11): <span class="hljs-built_in">error</span> CS0029: Cannot implicitly convert<span class="hljs-built_in"> type </span><span class="hljs-string">&#x27;decimal&#x27;</span> <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;string&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>备注</strong>：其他预压采用不同方式使用var关键字。在C#中，无论是使用实际数据类型还是让编译器暗示数据类型，变量都是由编译器分配类型的。换句话说，声明时类型是锁定的，因此永远无法保存不同数据类型的值。</p><h3 id="使用var关键字的变量必须初始化"><a href="#使用var关键字的变量必须初始化" class="headerlink" title="使用var关键字的变量必须初始化"></a>使用var关键字的变量必须初始化</h3><h3 id="为什么使用var关键字"><a href="#为什么使用var关键字" class="headerlink" title="为什么使用var关键字"></a>为什么使用var关键字</h3><p>开始开发代码的时候，数据类型未必是显而易见的，因此一个模糊的类型有助于动态的调整代码的开发。</p><h1 id="第三单元"><a href="#第三单元" class="headerlink" title="第三单元"></a>第三单元</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>C#提供了许多种方法来合并数据和设置其格式。</p><h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><ul><li>创建包含制表符、换行符和其他特殊字符的字符串数据</li><li>创建包含Unicode字符的字符串数据</li><li>通过串联和内插将字符串数据合并为新的字符串值</li></ul><h2 id="练习-在C-中设置文本字符串的格式"><a href="#练习-在C-中设置文本字符串的格式" class="headerlink" title="练习-在C#中设置文本字符串的格式"></a>练习-在C#中设置文本字符串的格式</h2><h3 id="字符串转义序列"><a href="#字符串转义序列" class="headerlink" title="字符串转义序列"></a>字符串转义序列</h3><p>转义符以<code>\</code>开头，后面跟要转义的字符。\n添加一个新行，\t添加一个制表符。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#">Console.WriteLine(<span class="hljs-string">&quot;Hello\nWorld&quot;</span>);<br>Console.WriteLine(<span class="hljs-string">&quot;Hello\tWorld&quot;</span>);<br>Console.WriteLine(<span class="hljs-string">&quot;Hello\&quot;World\&quot;!&quot;</span>);<br>Console.WriteLine(<span class="hljs-string">&quot;C:\\source\\repos&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="使用字符转义序列来设置输出格式"><a href="#使用字符转义序列来设置输出格式" class="headerlink" title="使用字符转义序列来设置输出格式"></a>使用字符转义序列来设置输出格式</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#">Console.WriteLine(<span class="hljs-string">&quot;Generating invoices for customer \&quot;Contoso Corp\&quot; ...\n&quot;</span>);<br>Console.WriteLine(<span class="hljs-string">&quot;Invoice: 1021\t\tComplete!&quot;</span>);<br>Console.WriteLine(<span class="hljs-string">&quot;Invoice: 1022\t\tComplete!&quot;</span>);<br>Console.WriteLine(<span class="hljs-string">&quot;\nOutput Directory:\t&quot;</span>);<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#">Generating invoices <span class="hljs-keyword">for</span> customer <span class="hljs-string">&quot;Contoso Corp&quot;</span> ...<br><br>Invoice: <span class="hljs-number">1021</span>           Complete!<br>Invoice: <span class="hljs-number">1022</span>           Complete!<br><br>Output Directory:<br></code></pre></td></tr></table></figure><h3 id="逐字字符串"><a href="#逐字字符串" class="headerlink" title="逐字字符串"></a>逐字字符串</h3><p><code>@</code>将保留字符串中所有的空格和字符，无序转义反斜杠。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#">Console.WriteLine(<span class="hljs-string">@&quot;    c:\source\repos    </span><br><span class="hljs-string">        (this is where your code goes)&quot;</span>);<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#">c:\source\repos    <br>        (<span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">where</span> your code goes)<br></code></pre></td></tr></table></figure><h3 id="Unicode转义字符"><a href="#Unicode转义字符" class="headerlink" title="Unicode转义字符"></a>Unicode转义字符</h3><p>用<code>\u</code>输出utf-16的文本</p><h2 id="练习-使用字符串串联来生成新的字符串"><a href="#练习-使用字符串串联来生成新的字符串" class="headerlink" title="练习-使用字符串串联来生成新的字符串"></a>练习-使用字符串串联来生成新的字符串</h2><h3 id="连接文本字符串和变量"><a href="#连接文本字符串和变量" class="headerlink" title="连接文本字符串和变量"></a>连接文本字符串和变量</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C#">stirng Bob = <span class="hljs-string">&quot;Bob&quot;</span>;<br><span class="hljs-built_in">string</span> message = <span class="hljs-string">&quot;Hello &quot;</span>+firstName;<br><span class="hljs-built_in">string</span> message_2 = <span class="hljs-string">&quot;hello&quot;</span>+<span class="hljs-string">&quot; &quot;</span>+firstName+<span class="hljs-string">&quot;!&quot;</span>;<br>Console.WriteLine(message);<br>Console.WriteLine(message_2);<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#">Hello Bob<br>hello Bob!<br></code></pre></td></tr></table></figure><h2 id="练习-使用字符串内插合并字符串"><a href="#练习-使用字符串内插合并字符串" class="headerlink" title="练习-使用字符串内插合并字符串"></a>练习-使用字符串内插合并字符串</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">string</span> message = greeting+<span class="hljs-string">&quot; &quot;</span>+firstName+<span class="hljs-string">&quot;!&quot;</span>;<br><span class="hljs-built_in">string</span> message = <span class="hljs-string">$&quot;<span class="hljs-subst">&#123;greeting&#125;</span> <span class="hljs-subst">&#123;firstName&#125;</span>&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="合并逐字文本和字符串内插"><a href="#合并逐字文本和字符串内插" class="headerlink" title="合并逐字文本和字符串内插"></a>合并逐字文本和字符串内插</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">string</span> projectName = <span class="hljs-string">&quot;First-Project&quot;</span>;<br>Console.WriteLine(<span class="hljs-string">$@&quot;C:\Output\<span class="hljs-subst">&#123;projectName&#125;</span>\Data&quot;</span>);<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">C:\Output\First-Project\Data<br></code></pre></td></tr></table></figure><h1 id="第三单元-1"><a href="#第三单元-1" class="headerlink" title="第三单元"></a>第三单元</h1><h2 id="学习目标-1"><a href="#学习目标-1" class="headerlink" title="学习目标"></a>学习目标</h2><ul><li><p>对数字值进行数学运算</p></li><li><p>观察字符串和数值之间的隐式类型转换</p></li><li><p>暂时将一种数据类型转换为另一种数据类型</p></li></ul><h2 id="练习-使用隐式数据转换执行加法"><a href="#练习-使用隐式数据转换执行加法" class="headerlink" title="练习-使用隐式数据转换执行加法"></a>练习-使用隐式数据转换执行加法</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">int</span> firstNumber =<span class="hljs-number">12</span>;<br><span class="hljs-built_in">int</span> secondNumber =<span class="hljs-number">7</span>;<br>Console.WriteLine(firstNumber+secondNumber);<br></code></pre></td></tr></table></figure><h3 id="混合数据类型以强制执行隐式类型转换"><a href="#混合数据类型以强制执行隐式类型转换" class="headerlink" title="混合数据类型以强制执行隐式类型转换"></a>混合数据类型以强制执行隐式类型转换</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">string</span> firstName = <span class="hljs-string">&quot;Bob&quot;</span>;<br><span class="hljs-built_in">int</span> widgetsSold = <span class="hljs-number">7</span>;<br>Console.WriteLine(firstName + <span class="hljs-string">&quot; sold &quot;</span> + widgetsSold + <span class="hljs-string">&quot; widgets.&quot;</span>);<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Bob</span> sold <span class="hljs-number">7</span> widgets.<br></code></pre></td></tr></table></figure><p>在这种情况下，C#编译器会推断出此情况，并将int类变量暂时转换为string以便与字符串的其余部分连接。</p><h3 id="尝试添加数字和连接字符串的更高级情况"><a href="#尝试添加数字和连接字符串的更高级情况" class="headerlink" title="尝试添加数字和连接字符串的更高级情况"></a>尝试添加数字和连接字符串的更高级情况</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">string</span> firstName = <span class="hljs-string">&quot;Bob&quot;</span>;<br><span class="hljs-built_in">int</span> widgetsSold = <span class="hljs-number">7</span>;<br>Console.WriteLine(firstName + <span class="hljs-string">&quot; sold &quot;</span> + widgetsSold + <span class="hljs-number">7</span> + <span class="hljs-string">&quot; widgets.&quot;</span>);<br>Console.WriteLine(firstName + <span class="hljs-string">&quot; sold &quot;</span> +( widgetsSold + <span class="hljs-number">7</span> )+ <span class="hljs-string">&quot; widgets.&quot;</span>);<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Bob</span> sold <span class="hljs-number">77</span> widgets.<br><span class="hljs-attribute">Bob</span> sold <span class="hljs-number">14</span> widgets.<br></code></pre></td></tr></table></figure><h2 id="练习-执行数学运算"><a href="#练习-执行数学运算" class="headerlink" title="练习-执行数学运算"></a>练习-执行数学运算</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">int</span> sum = <span class="hljs-number">7</span>+<span class="hljs-number">5</span>;<br><span class="hljs-built_in">int</span> difference = <span class="hljs-number">7</span><span class="hljs-number">-5</span>;<br><span class="hljs-built_in">int</span> product = <span class="hljs-number">7</span>*<span class="hljs-number">5</span>;<br><span class="hljs-built_in">int</span> quotient = <span class="hljs-number">7</span>/<span class="hljs-number">5</span>;<br><span class="hljs-built_in">double</span> quotient_2 = <span class="hljs-number">7</span>/<span class="hljs-number">5</span>;<br><span class="hljs-built_in">double</span> quotient_3 = <span class="hljs-number">7</span>d/<span class="hljs-number">5</span>;<br><span class="hljs-built_in">decimal</span> quotient_4 = <span class="hljs-number">7.0</span>m/<span class="hljs-number">5</span>;<br><span class="hljs-built_in">int</span> Modulus = <span class="hljs-number">7</span>%<span class="hljs-number">5</span>;<br>Console.WriteLine(<span class="hljs-string">&quot;Sum: &quot;</span> + sum);<br>Console.WriteLine(<span class="hljs-string">&quot;Difference: &quot;</span> + difference);<br>Console.WriteLine(<span class="hljs-string">&quot;Product: &quot;</span> + product);<br>Console.WriteLine(<span class="hljs-string">&quot;Quotient: &quot;</span> + quotient);<br>Console.WriteLine(<span class="hljs-string">&quot;Quotient2: &quot;</span> + quotient_2);<br>Console.WriteLine(<span class="hljs-string">&quot;Quotient3: &quot;</span> + quotient_3);<br>Console.WriteLine(<span class="hljs-string">&quot;Quotient4: &quot;</span> + quotient_4);<br>Console.WriteLine(<span class="hljs-string">&quot;Modulus: &quot;</span> + Modulus);<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Sum</span>: <span class="hljs-number">12</span><br><span class="hljs-attribute">Difference</span>: <span class="hljs-number">2</span><br><span class="hljs-attribute">Product</span>: <span class="hljs-number">35</span><br><span class="hljs-attribute">Quotient</span>: <span class="hljs-number">1</span><br><span class="hljs-attribute">Quotient2</span>: <span class="hljs-number">1</span><br><span class="hljs-attribute">Quotient3</span>: <span class="hljs-number">1</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">Quotient4</span>: <span class="hljs-number">1</span>.<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>由于quotient被定义为int类，因此输出的quotient_1和2都是整数，但是在quotient_3的定义中，将7用文本后缀为double类的时候，输出的就是小数了。</p><h3 id="运算顺序"><a href="#运算顺序" class="headerlink" title="运算顺序"></a>运算顺序</h3><p>PEMDAS</p><ol><li>圆括号（P）</li><li>指数（E）</li><li>乘法（M）和除法（D）</li><li>加法（A）和减法(S)</li></ol><h2 id="练习-递增和递减值"><a href="#练习-递增和递减值" class="headerlink" title="练习-递增和递减值"></a>练习-递增和递减值</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span> =<span class="hljs-number">0</span>;<br><span class="hljs-keyword">value</span> = <span class="hljs-keyword">value</span>+<span class="hljs-number">5</span>;<br><span class="hljs-keyword">value</span> +=<span class="hljs-number">5</span>;<br><span class="hljs-keyword">value</span>++;<span class="hljs-comment">//先读取值再++</span><br>++<span class="hljs-keyword">value</span>;<span class="hljs-comment">//先++再读取值</span><br><span class="hljs-keyword">value</span> =<span class="hljs-number">10</span><br>Console.WriteLine(<span class="hljs-keyword">value</span>++);<span class="hljs-comment">//先输出10再++</span><br>Console.WriteLine(++<span class="hljs-keyword">value</span>);<span class="hljs-comment">//先++再输出12</span><br></code></pre></td></tr></table></figure><h3 id="符合赋值运算符"><a href="#符合赋值运算符" class="headerlink" title="符合赋值运算符"></a>符合赋值运算符</h3><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">+</span><span class="hljs-comment">=</span> <span class="hljs-literal">-</span><span class="hljs-comment">= *= /= %=</span> <span class="hljs-literal">++</span> <span class="hljs-literal">--</span><br></code></pre></td></tr></table></figure><h2 id="完成将华氏温度转换为摄氏温度的挑战"><a href="#完成将华氏温度转换为摄氏温度的挑战" class="headerlink" title="完成将华氏温度转换为摄氏温度的挑战"></a>完成将华氏温度转换为摄氏温度的挑战</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">int</span> fahrenheit = <span class="hljs-number">94</span>;<br><span class="hljs-built_in">decimal</span> celsius = (fahrenheit - <span class="hljs-number">32</span>m)*(<span class="hljs-number">5</span>m/<span class="hljs-number">9</span>m);<br></code></pre></td></tr></table></figure><h1 id="第四单元"><a href="#第四单元" class="headerlink" title="第四单元"></a>第四单元</h1><h2 id="准备指导项目"><a href="#准备指导项目" class="headerlink" title="准备指导项目"></a>准备指导项目</h2><h3 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h3><ul><li>将获得一个包含四名学生及其五次作业成绩的简短列表</li><li>每个作业成绩都表示为要给整数值</li><li>总分按照五次作业分数的平均分计算</li><li>应用程序需要执行基本的数学运算来计算每个学生的总分</li><li>应用程序需要输出&#x2F;显示每名学生的姓名和总分</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Sophia</span>: <span class="hljs-number">93</span>, <span class="hljs-number">87</span>, <span class="hljs-number">98</span>, <span class="hljs-number">95</span>, <span class="hljs-number">100</span><br><br><span class="hljs-attribute">Nicolas</span>: <span class="hljs-number">80</span>, <span class="hljs-number">83</span>, <span class="hljs-number">82</span>, <span class="hljs-number">88</span>, <span class="hljs-number">85</span><br><br><span class="hljs-attribute">Zahirah</span>:   <span class="hljs-number">84</span>, <span class="hljs-number">96</span>, <span class="hljs-number">73</span>, <span class="hljs-number">85</span>, <span class="hljs-number">79</span><br><br><span class="hljs-attribute">Jeong</span>:  <span class="hljs-number">90</span>, <span class="hljs-number">92</span>, <span class="hljs-number">98</span>, <span class="hljs-number">100</span>, <span class="hljs-number">97</span><br></code></pre></td></tr></table></figure><p>老师要求每名学生的计算成绩如下所示：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Student</span>     Grade<br><span class="hljs-attribute">Sophia</span>      <span class="hljs-number">94</span>.<span class="hljs-number">6</span>  A<br><span class="hljs-attribute">Nicolas</span>     <span class="hljs-number">83</span>.<span class="hljs-number">6</span>  B<br><span class="hljs-attribute">Zahirah</span>     <span class="hljs-number">83</span>.<span class="hljs-number">4</span>  B<br><span class="hljs-attribute">Jeong</span>       <span class="hljs-number">95</span>.<span class="hljs-number">4</span>  A<br></code></pre></td></tr></table></figure><p>可以用<code>(decimal)</code>将int类强制转换为decimal类</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">decimal</span> sophiaScore = (<span class="hljs-built_in">decimal</span>) sophiaSum / currentAssignments;<br><span class="hljs-built_in">decimal</span> nicolasScore = (<span class="hljs-built_in">decimal</span>) nicolasSum / currentAssignments;<br><span class="hljs-built_in">decimal</span> zahirahScore = (<span class="hljs-built_in">decimal</span>) zahirahSum / currentAssignments;<br><span class="hljs-built_in">decimal</span> jeongScore = (<span class="hljs-built_in">decimal</span>) jeongSum / currentAssignments;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C-sharp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Visual Studio快捷键</title>
    <link href="/2024/04/03/Visual%20Studio%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2024/04/03/Visual%20Studio%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h2><h4 id="小写-Ctrl-U"><a href="#小写-Ctrl-U" class="headerlink" title="小写 Ctrl+U"></a>小写 Ctrl+U</h4><h4 id="大写-Ctrl-Shift-U"><a href="#大写-Ctrl-Shift-U" class="headerlink" title="大写 Ctrl+Shift+U"></a>大写 Ctrl+Shift+U</h4><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><h4 id="选中所有相同单词-Alt-Shift"><a href="#选中所有相同单词-Alt-Shift" class="headerlink" title="选中所有相同单词 Alt+Shift+;"></a>选中所有相同单词 Alt+Shift+;</h4><h4 id="选中多行光标-Shift-Alt-上-下"><a href="#选中多行光标-Shift-Alt-上-下" class="headerlink" title="选中多行光标 Shift+Alt+上&#x2F;下"></a>选中多行光标 Shift+Alt+上&#x2F;下</h4><h4 id="整行移动-按住Alt-上下键可以将当前行或选中行上下移动"><a href="#整行移动-按住Alt-上下键可以将当前行或选中行上下移动" class="headerlink" title="整行移动 按住Alt+上下键可以将当前行或选中行上下移动"></a>整行移动 按住Alt+上下键可以将当前行或选中行上下移动</h4><h2 id="复制和剪切"><a href="#复制和剪切" class="headerlink" title="复制和剪切"></a>复制和剪切</h2><h4 id="复制当前行-Ctrl-D"><a href="#复制当前行-Ctrl-D" class="headerlink" title="复制当前行 Ctrl+D"></a>复制当前行 Ctrl+D</h4><h4 id="剪切-删除当前行-Ctrl-X"><a href="#剪切-删除当前行-Ctrl-X" class="headerlink" title="剪切&#x2F;删除当前行 Ctrl+X"></a>剪切&#x2F;删除当前行 Ctrl+X</h4><h3 id="资源解决方案管理器窗口-Ctrl-Alt-L"><a href="#资源解决方案管理器窗口-Ctrl-Alt-L" class="headerlink" title="资源解决方案管理器窗口 Ctrl+Alt+L"></a>资源解决方案管理器窗口 Ctrl+Alt+L</h3><h3 id="终端界面-Ctrl"><a href="#终端界面-Ctrl" class="headerlink" title="终端界面 Ctrl+~"></a>终端界面 Ctrl+~</h3><h2 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h2><h4 id="以单词为单位跳转-Ctrl-左键-Ctrl-右键"><a href="#以单词为单位跳转-Ctrl-左键-Ctrl-右键" class="headerlink" title="以单词为单位跳转 Ctrl+左键&#x2F;Ctrl+右键"></a>以单词为单位跳转 Ctrl+左键&#x2F;Ctrl+右键</h4><h4 id="跳转到指定行-Ctrl-G"><a href="#跳转到指定行-Ctrl-G" class="headerlink" title="跳转到指定行 Ctrl+G"></a>跳转到指定行 Ctrl+G</h4><h4 id="跳转到实现-F12"><a href="#跳转到实现-F12" class="headerlink" title="跳转到实现 F12"></a>跳转到实现 F12</h4><h4 id="跳转到定义-Shift-F12"><a href="#跳转到定义-Shift-F12" class="headerlink" title="跳转到定义 Shift+F12"></a>跳转到定义 Shift+F12</h4><h4 id="跳转到打开的文件-Ctrl-TAB"><a href="#跳转到打开的文件-Ctrl-TAB" class="headerlink" title="跳转到打开的文件 Ctrl+TAB"></a>跳转到打开的文件 Ctrl+TAB</h4><h4 id="跳转到文件开头或结尾-Ctrl-Home-End"><a href="#跳转到文件开头或结尾-Ctrl-Home-End" class="headerlink" title="跳转到文件开头或结尾 Ctrl+Home&#x2F;End"></a>跳转到文件开头或结尾 Ctrl+Home&#x2F;End</h4><h4 id="跳转到下一个，上一个Find-F3-Shift-F3"><a href="#跳转到下一个，上一个Find-F3-Shift-F3" class="headerlink" title="跳转到下一个，上一个Find F3&#x2F;Shift F3"></a>跳转到下一个，上一个Find F3&#x2F;Shift F3</h4><h2 id="展开"><a href="#展开" class="headerlink" title="展开"></a>展开</h2><h4 id="折叠所有代码Ctrl-M-O"><a href="#折叠所有代码Ctrl-M-O" class="headerlink" title="折叠所有代码Ctrl+M+O"></a>折叠所有代码Ctrl+M+O</h4><h4 id="展开所有代码Ctrl-M-L"><a href="#展开所有代码Ctrl-M-L" class="headerlink" title="展开所有代码Ctrl+M+L"></a>展开所有代码Ctrl+M+L</h4><h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><h3 id="region代码块-手写-region然后Tab"><a href="#region代码块-手写-region然后Tab" class="headerlink" title="#region代码块 手写#region然后Tab"></a>#region代码块 手写#region然后Tab</h3><h3 id="任意外侧代码-Ctrl-k-Ctrl-S"><a href="#任意外侧代码-Ctrl-k-Ctrl-S" class="headerlink" title="任意外侧代码 Ctrl+k+Ctrl+S"></a>任意外侧代码 Ctrl+k+Ctrl+S</h3><h2 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h2><h4 id="变量重命名-Ctrl-R-R"><a href="#变量重命名-Ctrl-R-R" class="headerlink" title="变量重命名 Ctrl+R+R"></a>变量重命名 Ctrl+R+R</h4><h2 id="剪切板"><a href="#剪切板" class="headerlink" title="剪切板"></a>剪切板</h2><h4 id="展示历史剪切板-Ctrl-Shift-V"><a href="#展示历史剪切板-Ctrl-Shift-V" class="headerlink" title="展示历史剪切板 Ctrl+Shift+V"></a>展示历史剪切板 Ctrl+Shift+V</h4>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快捷键</tag>
      
      <tag>Visual Studio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#进阶</title>
    <link href="/2024/04/02/C-sharp%E8%BF%9B%E9%98%B6/"/>
    <url>/2024/04/02/C-sharp%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h2 id="类、结构和记录"><a href="#类、结构和记录" class="headerlink" title="类、结构和记录"></a>类、结构和记录</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h4><p>扩展方法使你能向现有类型”添加”方法，而<strong>无需创建新的派生类型</strong>、<strong>重新编译</strong>或<strong>以其他方式修改原始类型</strong>.</p><p>扩展方法在LINQ查询操作中特别常见。</p><p>以下是关于扩展方法的关键点：</p><ol><li><strong>静态方法：</strong>扩展方法必须是静态方法。</li><li><strong>静态类：</strong>扩展方法必须定义在静态中</li><li><strong>第一个参数：</strong>扩展方法的第一个参数要扩展的类型，参数前必须使用<code>this</code>关键字。</li><li><strong>命名空间：</strong>如果扩展方法定义在不同的命名空间中，那么在使用扩展方法的地方必须包含命名空间的<code>using</code>指令。</li></ol><p>示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">StringExtensions</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ToLowerFirstLetter</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> <span class="hljs-built_in">string</span> str</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">string</span>.IsNullOrEmpty(str)||<span class="hljs-built_in">char</span>.IsLower(str,<span class="hljs-number">0</span>))<br>            <span class="hljs-keyword">return</span> str;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">char</span>.ToLowerInvariant(str[<span class="hljs-number">0</span>])+str.Substring(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子中，定义了一个扩展方法<code>ToLowerFirstLetter</code>将字符串的第一个字符转换为小写。这个方法可以像实例方法一样被调用：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">string</span> s = <span class="hljs-string">&quot;Hello&quot;</span>;<br>s = s.ToLowerFirstLetter();<span class="hljs-comment">//输出&quot;hello&quot;</span><br></code></pre></td></tr></table></figure><p>尽管扩展方法看起来像是类型的实例方法，但<strong>它们实际上是静态方法的语法糖</strong>。<strong>这意味着你不能在扩展方法中访问被扩展类型的私有或受保护的成员</strong>。扩展方法只能访问它们所扩展的类型的公共成员。此外，如果类型已经有一个实例方法和一个扩展方法具有相同的签名，那么实例方法将始终被调用。扩展方法只有在实例方法不存在的情况下才会被调用。这就是扩展方法的解析规则。</p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h4 id="using-关键字"><a href="#using-关键字" class="headerlink" title="using 关键字"></a>using 关键字</h4><p>任何C#程序中的第一条语句都是：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> System;<br></code></pre></td></tr></table></figure><p><strong>using</strong>关键字用于在程序中包含命名空间。一个程序可以包含多个using语句</p><p>using关键字通常用于实现IDisposable接口的对象，以确保它们使用完毕后能被正确地释放，如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> client = <span class="hljs-keyword">new</span> HttpClient())<br></code></pre></td></tr></table></figure><p>这是执行清理操作的一种简洁方式，特别是在处理那些需要明确释放的非托管资源或实现IDisposable接口的对象时。</p><p>当using块内的代码执行完毕后，无论正常退出还是异常退出，HttpClient实例都会自动调用Dispose方法。Dispose方法会释放与HttpClient实例相关联的所有资源，如网络链接。</p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><h4 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h4><h4 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h4><h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><p>使用<code>async</code>修饰符可将方法、lambda表达式或匿名方法指定为异步。</p><p>如果对方法或表达式使用此修饰符，则其成为异步方法。如下实例定义了一个名为<code>ExampleMethodAsync</code>的异步方法。如下示例定义了一个名为<code>ExampleMethodAsync</code>的异步方法:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">ExampleMethodAsync</span>()</span><br>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="访问关键字"><a href="#访问关键字" class="headerlink" title="访问关键字"></a>访问关键字</h3><h4 id="base"><a href="#base" class="headerlink" title="base"></a>base</h4><p><code>base</code>关键字用于从派生类中访问基类的成员。在执行以下操作的时候使用它：</p><ul><li>调用基类上已被其他方法重写的方法</li><li>指定创建派生类实例时调用的基类构造函数</li></ul><p>仅允许基类访问在构造函数、实例方法和实例属性访问器中进行。</p><p>在静态方法中使用<code>base</code>关键字将产生错误。</p><p>所访问的基类是类声明中指定的基类，如果指定<code>class ClassB:ClassA</code>则从ClassB访问ClassA的成员，而不考虑ClassA基类。</p><h5 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h5><p>在此示例中，基类 <code>Person</code> 和派生类 <code>Employee</code> 都有一个名为 <code>GetInfo</code> 的方法。 通过使用 <code>base</code> 关键字，可以从派生类中调用基类的 <code>GetInfo</code> 方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">string</span> ssn = <span class="hljs-string">&quot;444-55-6666&quot;</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">string</span> name = <span class="hljs-string">&quot;John L. Malgraine&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GetInfo</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Name: &#123;0&#125;&quot;</span>, name);<br>        Console.WriteLine(<span class="hljs-string">&quot;SSN: &#123;0&#125;&quot;</span>, ssn);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> : <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> id = <span class="hljs-string">&quot;ABC567EFG&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GetInfo</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// Calling the base class GetInfo method:</span><br>        <span class="hljs-keyword">base</span>.GetInfo();<br>        Console.WriteLine(<span class="hljs-string">&quot;Employee ID: &#123;0&#125;&quot;</span>, id);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">TestClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Employee E = <span class="hljs-keyword">new</span> Employee();<br>        E.GetInfo();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Output</span><br><span class="hljs-comment">Name: John L. Malgraine</span><br><span class="hljs-comment">SSN: 444-55-6666</span><br><span class="hljs-comment">Employee ID: ABC567EFG</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h5 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h5><p>本示例显示如何指定在创建派生类实例时调用的基类构造函数。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-built_in">int</span> num;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BaseClass</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;in BaseClass()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BaseClass</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i</span>)</span><br>    &#123;<br>        num = i;<br>        Console.WriteLine(<span class="hljs-string">&quot;in BaseClass(int i)&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetNum</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DerivedClass</span> : <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-comment">// This constructor will call BaseClass.BaseClass()</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DerivedClass</span>() : <span class="hljs-title">base</span>()</span><br>    &#123;<br>    &#125;<br><br>    <span class="hljs-comment">// This constructor will call BaseClass.BaseClass(int i)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DerivedClass</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">i</span>)</span><br>    &#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        DerivedClass md = <span class="hljs-keyword">new</span> DerivedClass();<br>        DerivedClass md1 = <span class="hljs-keyword">new</span> DerivedClass(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Output:</span><br><span class="hljs-comment">in BaseClass()</span><br><span class="hljs-comment">in BaseClass(int i)</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><h4 id="value"><a href="#value" class="headerlink" title="value"></a>value</h4><h2 id="运算符和表达式"><a href="#运算符和表达式" class="headerlink" title="运算符和表达式"></a>运算符和表达式</h2><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>Lambda表达式是一个匿名函数，可以用来创建委托或表达式树类型。Lambda表达式的形式为<code>(parameters)=&gt;expression-or-statement-block</code>.</p><p>Lambda表达式可以在任何方法或属性的内部定义，包括在其他方法中。它的可见性（如<code>public</code>,<code>private</code>）取决于它被复制的变量或属性的可见性。如这个例子中：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">static</span> Action&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">object</span>&gt; Write&#123;<span class="hljs-keyword">get</span>;<span class="hljs-keyword">set</span>;&#125;<br>Write = (sz,<span class="hljs-keyword">value</span>)=&gt;<br>&#123;<br><span class="hljs-keyword">try</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">string</span>.IsNullOrEmpty(sz))&#123;<span class="hljs-keyword">return</span>;&#125;<br>        <span class="hljs-keyword">if</span>(outputs[sz].Variable.TrySetValue(<span class="hljs-keyword">value</span>,<span class="hljs-keyword">typeof</span>(Helper)))<br>        &#123;<br>            outputs[sz].SetBugger(<span class="hljs-keyword">value</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">catch</span>(Exception ex)&#123;ex.Tolog();&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>它的可见性就取决于Write属性的可见性</p><h3 id="await运算符"><a href="#await运算符" class="headerlink" title="await运算符"></a>await运算符</h3><h3 id="as运算符"><a href="#as运算符" class="headerlink" title="as运算符"></a>as运算符</h3><p> 用于执行引用类型的显式转换。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> result = expression <span class="hljs-keyword">as</span> Type;<br></code></pre></td></tr></table></figure><p>如果expression可以成功转换为Type，那么 result就是转换后的对象，如果不能，result就是null</p><p>as运算符在转换失败时不会抛出异常</p><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="声明语句"><a href="#声明语句" class="headerlink" title="声明语句"></a>声明语句</h3><h3 id="异常处理语句"><a href="#异常处理语句" class="headerlink" title="异常处理语句"></a>异常处理语句</h3><h3 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h3><h3 id="选择语句"><a href="#选择语句" class="headerlink" title="选择语句"></a>选择语句</h3><h3 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h3><h3 id="checked和unchecked语句"><a href="#checked和unchecked语句" class="headerlink" title="checked和unchecked语句"></a>checked和unchecked语句</h3><h3 id="fixed语句"><a href="#fixed语句" class="headerlink" title="fixed语句"></a>fixed语句</h3><h3 id="lock语句"><a href="#lock语句" class="headerlink" title="lock语句"></a>lock语句</h3><h3 id="using语句"><a href="#using语句" class="headerlink" title="using语句"></a>using语句</h3><p><code>using</code>语句可确保正确使用IDsposable实例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">var</span> numbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();<br><span class="hljs-keyword">using</span> (StreamReader reader = File.OpenText(<span class="hljs-string">&quot;number.txt&quot;</span>))<br>&#123;<br>    <span class="hljs-built_in">string</span> lien;<br>    <span class="hljs-keyword">while</span> ((line = reader.ReadLine()) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">int</span>.TryParse(line, <span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> number))<br>        &#123;<br>            numbers.Add(number);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="yield语句"><a href="#yield语句" class="headerlink" title="yield语句"></a>yield语句</h3><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><h2 id="编译器读取的属性"><a href="#编译器读取的属性" class="headerlink" title="编译器读取的属性"></a>编译器读取的属性</h2><h2 id="编译器选项"><a href="#编译器选项" class="headerlink" title="编译器选项"></a>编译器选项</h2>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python库-json</title>
    <link href="/2024/03/31/Python%E5%BA%93-json/"/>
    <url>/2024/03/31/Python%E5%BA%93-json/</url>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#用loads()函数读取json</span><br>&gt;&gt;&gt;stringofjsonData =<span class="hljs-string">&#x27;&#123;&quot;name&quot;:&quot;Zophie&quot;,&quot;isCate&quot;:true,&quot;miceCaught&quot;:0,&quot;felineIQ&quot;:null&#125;&#x27;</span><br>&gt;&gt;&gt;<span class="hljs-keyword">import</span> json<br>&gt;&gt;&gt;jsonDataAsPythonValue = json.loads(stringofjsonData)<br>&gt;&gt;&gt;jsonDataAsPythonValue<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Zophie&#x27;</span>, <span class="hljs-string">&#x27;isCate&#x27;</span>: <span class="hljs-literal">True</span>, <span class="hljs-string">&#x27;miceCaught&#x27;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;felineIQ&#x27;</span>: <span class="hljs-literal">None</span>&#125;<br><span class="hljs-comment">#loads()函数会将数据返回为一个Python字典，但是python字典是没有顺序的，因此打印jsonDataAsPythonValue可能会以不同的顺序出现</span><br>&gt;&gt;&gt;data = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">[&#123;</span><br><span class="hljs-string">    &quot;name&quot;: &quot;小明&quot;,</span><br><span class="hljs-string">    &quot;height&quot;: &quot;170&quot;,</span><br><span class="hljs-string">    &quot;age&quot;: &quot;18&quot;</span><br><span class="hljs-string">&#125;, &#123;</span><br><span class="hljs-string">     &quot;name&quot;: &quot;小红&quot;,</span><br><span class="hljs-string">    &quot;height&quot;: &quot;165&quot;,</span><br><span class="hljs-string">    &quot;age&quot;: &quot;20&quot;</span><br><span class="hljs-string">&#125;]</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>&gt;&gt;&gt;new_data=json.loads(data)<br>&gt;&gt;&gt;<span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(data))<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;<br>&gt;&gt;&gt;<span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(new_data))<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;list&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br>data = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">[&#123;</span><br><span class="hljs-string">    &quot;name&quot;: &quot;小明&quot;,</span><br><span class="hljs-string">    &quot;height&quot;: &quot;170&quot;,</span><br><span class="hljs-string">    &quot;age&quot;: &quot;18&quot;</span><br><span class="hljs-string">&#125;, &#123;</span><br><span class="hljs-string">     &quot;name&quot;: &quot;小红&quot;,</span><br><span class="hljs-string">    &quot;height&quot;: &quot;165&quot;,</span><br><span class="hljs-string">    &quot;age&quot;: &quot;20&quot;</span><br><span class="hljs-string">&#125;]</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>new_data = json.loads(data)<br><br>name_1 = new_data[<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;name&#x27;</span>]<br>name_2 = new_data[<span class="hljs-number">1</span>][<span class="hljs-string">&#x27;name&#x27;</span>]<br><span class="hljs-built_in">print</span>(name_1)<br><span class="hljs-built_in">print</span>(name_2)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>python库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python库-shutil</title>
    <link href="/2024/03/31/Python%E5%BA%93-shutil/"/>
    <url>/2024/03/31/Python%E5%BA%93-shutil/</url>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#将文件复制到指定位置</span><br>&gt;&gt;&gt;shutil.copy(<span class="hljs-string">&#x27;test.py&#x27;</span>,<span class="hljs-string">&#x27;toast_picture&#x27;</span>)<br><span class="hljs-string">&#x27;toast_picture\\test.py&#x27;</span><br><span class="hljs-comment">#将整个文件夹复制到指定位置</span><br>&gt;&gt;&gt;shutil.copytree(<span class="hljs-string">&#x27;toast_picture&#x27;</span>,<span class="hljs-string">&#x27;toast_picture_backup&#x27;</span>)<br><span class="hljs-string">&#x27;toast_picture_backup&#x27;</span><br><span class="hljs-comment">#将文件移动到指定位置</span><br>&gt;&gt;&gt;shutil.move(<span class="hljs-string">&#x27;test.py&#x27;</span>,<span class="hljs-string">&#x27;toast_picture&#x27;</span>)<br><span class="hljs-string">&#x27;toast_picture\\test.py&#x27;</span><br><span class="hljs-comment">#shutil.rmtree(path)将删除path处的文件夹，包括子文件</span><br>&gt;&gt;&gt;shutil.rmtree(<span class="hljs-string">&#x27;toast_picture_backup&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>python库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python库-os</title>
    <link href="/2024/03/31/Python%E5%BA%93-os/"/>
    <url>/2024/03/31/Python%E5%BA%93-os/</url>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#用os.path.abspath()函数来获取绝对路径</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.abspath(<span class="hljs-string">&#x27;.&#x27;</span>)<br><span class="hljs-string">&#x27;C:\\Python34\\Scripts&#x27;</span><br><span class="hljs-comment">#用os.path.isabs(&#x27;.&#x27;)</span><br>&gt;&gt;&gt;os.path.isabs(<span class="hljs-string">&#x27;.&#x27;</span>)<br><span class="hljs-literal">False</span><br>&gt;&gt;&gt;os.path.isabs(os.path.abspath(<span class="hljs-string">&#x27;.&#x27;</span>))<br><span class="hljs-comment">#用os.listdir(path)将返回文件名字符串的列表</span><br>&gt;&gt;&gt;os.path.listdir(<span class="hljs-string">&#x27;.&#x27;</span>)<br>[<span class="hljs-string">&#x27;data.xlsx&#x27;</span>,<span class="hljs-string">&#x27;test.py&#x27;</span>]<br><span class="hljs-comment">#用os.path.join()可以返回一个文件路径的字符串</span><br>&gt;&gt;&gt;os.path.join(<span class="hljs-string">&#x27;C:\\&#x27;</span>,<span class="hljs-string">&#x27;Users&#x27;</span>,<span class="hljs-string">&#x27;Homovexillues&#x27;</span>,<span class="hljs-string">&#x27;Download&#x27;</span>)<br><span class="hljs-string">&#x27;C:\\Users\\Homovexillues\\Download&#x27;</span><br><span class="hljs-comment">#os.unlink(path)将删除path处的文件</span><br>&gt;&gt;&gt;os.unlink(<span class="hljs-string">&#x27;toast_picture\\test.py&#x27;</span>)<br><span class="hljs-comment">#os.rmdir(path)将删除path处的空文件夹</span><br>&gt;&gt;&gt;os.rmdir(path)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>python库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python库-openpyxl</title>
    <link href="/2024/03/30/Python%E5%BA%93-openpyxl/"/>
    <url>/2024/03/30/Python%E5%BA%93-openpyxl/</url>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#打开Excel文档</span><br>workbook = openpyxl.load_workbook(<span class="hljs-string">&#x27;data.xlsx&#x27;</span>)<br><span class="hljs-comment">#openpyxl.load_workbook()函数接收文件名，返回一个workbook数据类型的值。这个workbook对象代表这个Excel文件，有点类似File对象代表一个打开的文本文件。</span><br><span class="hljs-comment">#data.xlsx需要在当前工作目录才能处理它。可以使用os.getcwd()获取当前工作目录，再用os.chdir()改变当前工作目录。</span><br><span class="hljs-comment">#用get_sheet_names()方法可以取得工作薄中所有表名的列表</span><br>&gt;&gt;&gt;workbook.get_sheet_names()<br>[<span class="hljs-string">&#x27;Sheet1&#x27;</span>,<span class="hljs-string">&#x27;Sheet2&#x27;</span>,<span class="hljs-string">&#x27;Sheet3&#x27;</span>]<br>&gt;&gt;&gt;Sheet1=workbook[<span class="hljs-string">&#x27;Sheet1&#x27;</span>]<br>&gt;&gt;&gt;Sheet1<br>&lt;Worksheet <span class="hljs-string">&quot;Sheet1&quot;</span>&gt;<br>&gt;&gt;&gt;<span class="hljs-built_in">type</span>(Sheet1)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;openpyxl.worksheet.worksheet.Worksheet&#x27;</span>&gt;<br>&gt;&gt;&gt;Sheet1.title<br><span class="hljs-string">&#x27;Sheet1&#x27;</span><br><span class="hljs-comment">#可以按名字访问cell对象</span><br>&gt;&gt;&gt;<span class="hljs-built_in">print</span>(Sheet1[<span class="hljs-string">&#x27;A1&#x27;</span>].value)<br><span class="hljs-string">&#x27;Apples&#x27;</span><br><span class="hljs-comment">#Cell对象有一个value属性，它也有row（行数）、column（列数）和coordinate（坐标，如A1）属性</span><br><span class="hljs-comment">#也可以直接通过坐标来访问</span><br>&gt;&gt;&gt;Sheet1.cell(row=<span class="hljs-number">1</span>,column=<span class="hljs-number">2</span>)<br>&lt;Cell Sheet1.B1&gt;<br>&gt;&gt;&gt;Sheet1.cell(row=<span class="hljs-number">1</span>,column=<span class="hljs-number">2</span>).value<br><span class="hljs-string">&#x27;Apples&#x27;</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>python库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python处理Excel</title>
    <link href="/2024/03/30/Python%E5%A4%84%E7%90%86Excel/"/>
    <url>/2024/03/30/Python%E5%A4%84%E7%90%86Excel/</url>
    
    <content type="html"><![CDATA[<h3 id="根据Excel表格中的内容筛选文件"><a href="#根据Excel表格中的内容筛选文件" class="headerlink" title="根据Excel表格中的内容筛选文件"></a>根据Excel表格中的内容筛选文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#用来筛选文件夹中的文件是否以Excel表中某个特定范围内的格子内容为名，</span><br><span class="hljs-comment">#且结尾为指定内容结尾，剪切到另一文件夹下</span><br><span class="hljs-keyword">import</span> openpyxl<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> shutil<br><span class="hljs-comment">#选定Excel表格</span><br>workbook = openpyxl.load_workbook(<span class="hljs-string">&#x27;data.xlsx&#x27;</span>)<br><span class="hljs-comment">#选定工作表</span><br>worksheet = workbook[<span class="hljs-string">&#x27;E_CODE_Train&#x27;</span>]<br><span class="hljs-comment">#选定读取范围</span><br>read_range=worksheet[<span class="hljs-string">&#x27;G2&#x27;</span>:<span class="hljs-string">&#x27;G2103&#x27;</span>]<br><span class="hljs-comment">#先创建一个空数组，以后用来存放正确的文件名</span><br>right_name=[]<br><span class="hljs-keyword">for</span> cell <span class="hljs-keyword">in</span> read_range:<br>    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> cell:<br>        <span class="hljs-keyword">if</span>(c.value!=<span class="hljs-string">&#x27;Null&#x27;</span>):<br>            <span class="hljs-comment">#print(worksheet.cell(row=c.row,column=1).value)</span><br>            <span class="hljs-comment">#将G列不为Null那一行的A列数据写入数组</span><br>            right_name.append(worksheet.cell(row=c.row,column=<span class="hljs-number">1</span>).value)<br><span class="hljs-comment">#原文件夹</span><br>raw_picture_folder_path = <span class="hljs-string">&#x27;C:\\Users\\rolen\\Downloads\\HIT视觉POC\\raw_picture&#x27;</span><br><span class="hljs-comment">#目标文件夹</span><br>targat_folder_path =<span class="hljs-string">&#x27;C:\\Users\\rolen\\Downloads\\HIT视觉POC\\target_picture&#x27;</span><br><span class="hljs-comment">#另外的筛选条件</span><br>filter_1=[<span class="hljs-string">&#x27;RT.jpg&#x27;</span>,<span class="hljs-string">&#x27;TP.jpg&#x27;</span>,<span class="hljs-string">&#x27;RR.jpg&#x27;</span>,<span class="hljs-string">&#x27;LT.jpg&#x27;</span>,<span class="hljs-string">&#x27;FR.jpg&#x27;</span>]<br><span class="hljs-comment">#遍历这个文件夹下的文件</span><br><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> os.listdir(raw_picture_folder_path):<br>    <span class="hljs-comment">#如果文件名开头在数组里且结尾是给定的几个结尾之一</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(file.startswith(prefix) <span class="hljs-keyword">and</span> file.endswith(endfix) <span class="hljs-keyword">for</span> prefix <span class="hljs-keyword">in</span> right_name <span class="hljs-keyword">for</span> endfix <span class="hljs-keyword">in</span> filter_1):<br>        ex_file = os.path.join(raw_picture_folder_path,file)<br>        now_file = os.path.join(targat_folder_path,file)<br>        shutil.move(ex_file,now_file)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>脚本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo+Github搭建博客记录</title>
    <link href="/2024/03/29/hexo+GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/03/29/hexo+GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>温故而知新，加上疫情之后记忆力感觉不比从前了，所以要养成随手记笔记的好习惯，免得未来某一天连自己的代码和操作都看不懂了（捂脸）</p><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>使用Hexo+Github Pages搭建的个人博客属是一个静态网站，但是可以达到一些动态的交互效果。</p><blockquote><p>静态网站：用户和Web页面之间不能做一些交互</p><p>动态网站：允许用户和网站做一些交互</p></blockquote><p>静态网站大致运作流程如下</p><p><img src="/../images/hexo+GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/1460000022490307.png" alt="原图像来自https://segmentfault.com/a/1190000022490303"></p><p>Github pages是Github公司提供的免费静态网站托管服务,当把HTML等资源文件存放到GitHub指定的仓库中时，GitHub Pages服务会对这些文件进行处理并把它展示为一个网站，因此其可以代替Web服务器的功能，只需要将在本地生成的HTML等资源文件上传到GitHub的仓库中即可实现类似的Web服务器功能，可以响应请求并把相应的资源文件发送给客户端。</p><p>相比于Dijango、Flask、Spring等Web框架，hexo对相关编程语言基础的需求不高，可以将Markdown文本快速生成html文件，大大提升效率。</p><h2 id="①环境"><a href="#①环境" class="headerlink" title="①环境"></a>①环境</h2><p>node.js下载安装后npm安装hexo博客，代码使用如下</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>安装完成后运行</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">hexo -v<br></code></pre></td></tr></table></figure><p>来确认安装情况，出现如下报错：</p><h6 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h6><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">无法加载文件C:\Users\Administrator\AppData\Roaming\npm\hexo.ps1，因为在此系统中禁止执行脚本。有关详细信息，请参阅 &quot;get-<span class="hljs-built_in">help</span> about_signing&quot;。<br></code></pre></td></tr></table></figure><h6 id="解决方法如下"><a href="#解决方法如下" class="headerlink" title="解决方法如下"></a>解决方法如下</h6><p>管理员权限运行Powershell，执行</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">get-ExecutionPolicy</span><br>返回状态：Restricted表示状态是禁止的<br>执行命令<br><span class="hljs-built_in">set-ExecutionPolicy</span> RemoteSigned来开启<br>选择Y<br></code></pre></td></tr></table></figure><p>选定位置，用</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">hexo <span class="hljs-literal">-init</span> blog<br></code></pre></td></tr></table></figure><h6 id="出现问题"><a href="#出现问题" class="headerlink" title="出现问题"></a>出现问题</h6><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm ERR! Error: EPERM: operation not permitted, mkdir <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><h6 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因"></a>错误原因</h6><p>权限不够</p><h6 id="解决方法如下-1"><a href="#解决方法如下-1" class="headerlink" title="解决方法如下"></a>解决方法如下</h6><img src="../images/hexo+GitHub搭建博客记录/change_the_authority.png" /><p>在属性中将文件夹的用户完全控制权限打开，重新执行命令。</p><p>创建blog文件夹并初始化，此时可以尝试</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">hexo <span class="hljs-literal">-g</span> 静态部署<br>hexo <span class="hljs-literal">-s</span> 开始本地服务器<br></code></pre></td></tr></table></figure><h6 id="出现问题-1"><a href="#出现问题-1" class="headerlink" title="出现问题"></a>出现问题</h6><p>打开<a href="http://localhost:4000的尝试以失败告终">http://localhost:4000的尝试以失败告终</a></p><h6 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h6><p>4000端口被占用了，用</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">hexo server <span class="hljs-literal">-p</span> <span class="hljs-number">5000</span><br></code></pre></td></tr></table></figure><p>来更改端口号后重试，成功打开<a href="http://localhost:5000/">http://localhost:5000</a></p><h2 id="②部署"><a href="#②部署" class="headerlink" title="②部署"></a>②部署</h2><p>本地部分完成后，将其部署到Github上的自建库里</p><p>这里首先要新建一个GitHub库，命名为“用户名.github.io”的公共库，创建后会默认自动启动HTTPS</p><p>然后安装<strong>hexo-deployer-git</strong>插件：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm install hexo<span class="hljs-literal">-deployer-git</span> <span class="hljs-literal">--save</span><br></code></pre></td></tr></table></figure><p>安装成功后修改**_config.yml**文件内的URL部分和Deployment部分：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">url:</span> <span class="hljs-string">https://用户名.github.io</span><br><br><span class="hljs-attr">deploy:</span><br><span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br><span class="hljs-attr">repository:</span> <span class="hljs-string">git@github.com:用户名/用户名.github.io.git</span><br><span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br></code></pre></td></tr></table></figure><p>上传之前别忘了先连接github并配置ssh密匙:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;Github用户名&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;Github邮箱&quot;</span><br>ssh-keygen -t rsa -C <span class="hljs-string">&quot;Github邮箱&quot;</span><br></code></pre></td></tr></table></figure><p>再将</p><p>Windows：C:\Users\用户名\.ssh下的id_rsa.pub</p><p>Linux： &#x2F;root&#x2F;.ssh&#x2F;id_rsa</p><p>文件中的密匙添加到GitHub上的个人设置-ssh keys中，配置好后可以用<code>ssh -T git@github.com</code>来验证是否连接成功</p><p>然后运行<code>hexo d</code>将网站部署到Github页面</p><p>这样访问https:&#x2F;&#x2F;用户名.github.io就能看到刚才做好的Hexo网站了</p><h2 id="③解决图床问题"><a href="#③解决图床问题" class="headerlink" title="③解决图床问题"></a>③解决图床问题</h2><p>建立一个新的Github库用来存放图片，下载并安装工具<a href="https://github.com/Molunerfinn/PicGo">PicGo</a>用于快速上传图片到Github图床库并获取图片URL链接</p><p>在Github的Setting最下方的Developer Settings，Personal access tokens生成一个token，只选repo那栏就成，在PicGo中设置好之后直接拖拽上传就成了</p><p>2024&#x2F;05&#x2F;14</p><p>这是个蠢办法，直接在source里加一个images文件夹，设置typora将复制进来的图片都放在那里并自动根据文件名创建文件夹，设置地址为相对地址，齐活。</p><h2 id="将hexo文件夹同步并自动上传"><a href="#将hexo文件夹同步并自动上传" class="headerlink" title="将hexo文件夹同步并自动上传"></a>将hexo文件夹同步并自动上传</h2><p>将hexo文件夹放到OneDrive上以便Windows多端方便对其进行编辑，并在服务器上安装<a href="https://github.com/abraunegg/onedrive">OneDrive</a>(非官方)以便在手机上通过ssh进行编辑和设置定时上传到GitHub功能</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows CMD命令</title>
    <link href="/2024/03/29/Windows%E5%91%BD%E4%BB%A4/"/>
    <url>/2024/03/29/Windows%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<ul><li><p>getmac &#x2F;v<br>获得mac地址</p></li><li><p>assoc<br>assoc .mp4&#x3D;VLC.vlc</p></li><li><p>chkdsk<br>chkdsk &#x2F;f</p></li><li><p>tasklist | findstr script<br>找到进程中的脚本</p></li><li><p>netsh wlan show wlanrepor<br>展示wlan的报告</p></li><li><p>netsh interface ip show address | find “IP Adress”<br>显示ip地址</p></li><li><p>netsh advfirewall set allprofiles state off<br>  关闭Windows防火墙<br>  netsh advfirewall set allprofiles state on</p></li><li><p>netstat<br>查看打开的接口</p></li><li><p>powercfg -h off</p><p>关闭休眠模式</p><p>btw,这锤子模式真的消耗了C盘的大量空间</p></li><li><p>ncpa.cpl</p><p>打开网络适配器</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令</title>
    <link href="/2024/03/29/Linux%E5%91%BD%E4%BB%A4/"/>
    <url>/2024/03/29/Linux%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="cal"><a href="#cal" class="headerlink" title="cal"></a>cal</h3><p>  输出一个简单的日历</p><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>  显示文件内容</p><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p>  更改目录并进入</p><ul><li>cd ..<br>回到上一个目录</li><li>cd<br>回到home文件夹</li></ul><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> [<span class="hljs-built_in">who</span>] [operator] [permission] [file]<br>[<span class="hljs-built_in">who</span>]<br>u文件所有者<br>g文件所属组<br>o其他用户<br>a所有用户<br>[operator]<br>+增加权限<br>-删除权限<br>=设置权限<br>[permission]<br>r可读 4<br>w可写 2<br>x可执行 1<br>无权限 0<br>7=4+2+1 读写运行权限<br>5=4+1 读和运行权限<br>4=4 只读权限<br><br><span class="hljs-built_in">chmod</span> 444 file.txt <span class="hljs-comment">#赋予文件只读权限，或者</span><br><span class="hljs-built_in">chmod</span> -r--r--r-- file.txt<br></code></pre></td></tr></table></figure><h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><p>  清理屏幕</p><h3 id="cmp"><a href="#cmp" class="headerlink" title="cmp"></a>cmp</h3><p>  比较两个文件的异同</p><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p>  复制文件到新的文件夹或者将一个文件复制到另一个文件</p><h3 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h3><p>  从网络下载文件</p><ul><li>curl [] -&gt; []</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#显示详细的请求和响应信息，用于调试</span><br><span class="hljs-comment">#-v --verbose</span><br>curl -v https://www.baicu.com<br><span class="hljs-comment">#指定代理服务器</span><br><span class="hljs-comment">#-x --proxy</span><br>curl -x socks5://proxy.server.com:port https://www.youtube.com<br><span class="hljs-comment">#将输出保存到指定文件</span><br><span class="hljs-comment">#-o --output</span><br>curl -o output.html https://www.baidu.com<br><span class="hljs-comment">#将输出保留为远程文件的文件名</span><br><span class="hljs-comment">#-O --remote-name</span><br>curl -O https://www.example.com/file.zip<br><span class="hljs-comment">#发送Post请求数据</span><br><span class="hljs-comment">#-d --data</span><br>curl -d <span class="hljs-string">&quot;param1=value1&amp;param2=value2&quot;</span> https://baidu.com<br><span class="hljs-comment">#添加自定义请求头</span><br><span class="hljs-comment">#-H, --header</span><br>curl -H <span class="hljs-string">&quot;Content-Type: application/json&quot;</span> -d <span class="hljs-string">&#x27;&#123;&quot;key&quot;:&quot;value&quot;&#125;&#x27;</span> https://www.example.com<br></code></pre></td></tr></table></figure><h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><p>  比较两个文件的异同并告诉我们差异之处</p><h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><p>  内存占用情况</p><h3 id="du"><a href="#du" class="headerlink" title="du"></a>du</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">du</span><br><span class="hljs-comment"># 显示目录和文件所占空间</span><br><span class="hljs-built_in">du</span> file_name/dir_name<br><span class="hljs-comment"># 显示特定文件或文件夹大小</span><br><span class="hljs-built_in">du</span> -h<br><span class="hljs-comment"># 以方便阅读的格式显示所占空间</span><br><span class="hljs-built_in">du</span> -s<br><span class="hljs-comment"># 显示指定目录或文件的总大小</span><br></code></pre></td></tr></table></figure><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><p>  输出一些内容或向文件中添加内容</p><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>  查找文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">find . file.txt<br><span class="hljs-comment"># 找到当前目录下名为file.txt的文件</span><br>find /bin -name <span class="hljs-string">&quot;hello*&quot;</span><br><span class="hljs-comment"># 找到bin文件夹下所有以“hello&quot;开头的文件</span><br><span class="hljs-comment">#####################-size</span><br>find /home -size +1M<br><span class="hljs-comment"># 找到/home目录下大于1MB的文件</span><br>find /home -size -1M<br><span class="hljs-comment"># 找到/home目录下小于1MB的文件</span><br>finde /home -size +10M -size -1G<br><span class="hljs-comment"># 找到/home目录下大于1MB小于1G的文件</span><br><span class="hljs-comment"># k:KB;M:MB;G:GB</span><br><span class="hljs-comment">####################-a/c/m+min/time</span><br>find /home -mtime +7<br><span class="hljs-comment"># 查找/home目录下在7*24小时外修改过文件数据的文件</span><br>find . -ctime 30<br><span class="hljs-comment"># 当前目录及其子目录下所有正好30天前修改过文件状态的文件</span><br>find . -atime +365<br><span class="hljs-comment"># 当前目录及其子目录下一年外被访问的文件</span><br>find / -<span class="hljs-built_in">type</span> d -name <span class="hljs-string">&quot;zhman&quot;</span> 2&gt;/dev/null<br><span class="hljs-comment"># -type </span><br><span class="hljs-comment"># d表示只查找目录</span><br><span class="hljs-comment"># f表示普通文件</span><br></code></pre></td></tr></table></figure><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>  输出内存状况</p><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep [options] pattern [files]<br></code></pre></td></tr></table></figure><ul><li>pattern 正则表达式</li><li>files 要查找的文件名，可以同时查找多个文件，如果省略files参数，则默认从标准输入中读取数据</li></ul><p>常用选项包括</p><ul><li>-i 忽略大小写进行匹配</li><li>-v 反向查找，只打印不匹配的行</li><li>-n 显示匹配行的行号</li><li>-r 递归查找子目录中的文件</li><li>-l 只打印匹配的文件名</li><li>-c 只打印匹配的行数</li></ul><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><p>  只看文档的开头</p><h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p>  查看所有执行过的历史记录</p><h3 id="htop"><a href="#htop" class="headerlink" title="htop"></a>htop</h3><p>  用一种更花哨的方式看系统性能的进程</p><h3 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h3><p>用于管理和查看网络接口，包括物理网卡和虚拟接口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">ip link <br><span class="hljs-meta prompt_"># </span><span class="language-bash">用于管理和查看网络接口，包括物理网卡和虚拟接口</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">常见用法包括启用或禁用接口，修改接口属性，查看接口状态等</span><br>ip link show <br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示所有网络接口的状态，包括链路层信息，IP地址等</span><br>ip link set dev eth0 up <br><span class="hljs-meta prompt_"># </span><span class="language-bash">启用名为eth0的网卡</span><br>ip link set eth0 mtu 1500<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置eth0的最大传输单元（MTU）为1500字节</span><br>ip link set eth0 name vbird<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将eth0的名称修改为vbird（需要在网卡关闭时进行）</span><br><br>ip addr<br><span class="hljs-meta prompt_"># </span><span class="language-bash">用于管理和查看ip地址信息</span><br>ip addr add 192.168.1.10/24 dev eth0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将IP地址192.168.1.10添加到eth0网卡</span><br>ip addr del 192.168.1.10/24 dev eth0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">从网卡中删除指定的IP地址</span><br></code></pre></td></tr></table></figure><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>  结束系统进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps -aux | grep thisbash<br><span class="hljs-comment"># 显示所有进程，并抓取内容中含有“thisbash”内容的进程，然后查看process ID，也就是PID</span><br><br><span class="hljs-built_in">kill</span> -9 6599<br><span class="hljs-comment"># -9表示强制杀掉进程</span><br></code></pre></td></tr></table></figure><h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>  只看文档的一页</p><h3 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h3><p>  链接文件</p><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -l<br><span class="hljs-comment"># 查看文件列表，包括属性</span><br><br><span class="hljs-built_in">ls</span> -al<br><span class="hljs-comment"># 查看隐藏文件</span><br><br><span class="hljs-built_in">ls</span> -ld */<br><span class="hljs-comment">#查看当前位置下所有以/结尾的文件，实际上就是目录，遇到目录输出目录名而非目录</span><br></code></pre></td></tr></table></figure><h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># man命令可以给出命令的帮助文档</span><br>apt install manpages-zh<br><span class="hljs-comment"># 下载中文包将其汉化</span><br>apt install language-pack-zh-han*<br><span class="hljs-comment"># 如果系统没有预装中文语言包，需要以此命令安装</span><br>locale -a<br><span class="hljs-comment"># 可以通过此命令查看系统中的语言环境</span><br>vim ~/.bashrc<br><span class="hljs-built_in">alias</span> cman=<span class="hljs-string">&#x27;man -M /usr/share/man/zh_CN&#x27;</span><br><span class="hljs-comment"># 编辑.bashrc命令以将cman命令添加到shell中</span><br><span class="hljs-built_in">source</span> ~/.bashrc<br><span class="hljs-comment"># 重新加载shell以使之生效</span><br></code></pre></td></tr></table></figure><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p>  创建新的文件夹</p><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p>  将要查看的文件内容直接输出在终端上</p><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p>  移动文件</p><h3 id="neofetch"><a href="#neofetch" class="headerlink" title="neofetch"></a>neofetch</h3><p>  显示系统字符图像和系统信息</p><h3 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h3><p>  更改密码</p><ul><li>sudo passwd nick<br>修改密码</li></ul><h3 id="pkill"><a href="#pkill" class="headerlink" title="pkill"></a>pkill</h3><p>  不需要知道PID</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">pkill -f thisbash<br><span class="hljs-comment"># 直接结束含有thisbash的进程</span><br></code></pre></td></tr></table></figure><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>  查看系统进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps -A<br><span class="hljs-comment"># 列出所有的进程</span><br>ps -aux<br><span class="hljs-comment"># 查看系统所有包含其他使用者的进程，输出格式为:</span><br><span class="hljs-comment"># USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND</span><br>ps -u root<br><span class="hljs-comment"># 显示root用户进程信息</span><br></code></pre></td></tr></table></figure><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>  我在哪儿，显示目前的位置</p><h3 id="reboot"><a href="#reboot" class="headerlink" title="reboot"></a>reboot</h3><p>  重启</p><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>  删除文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> -r<br><span class="hljs-comment"># 删除目录以及其下的所有文件</span><br><span class="hljs-built_in">rm</span> -i<br><span class="hljs-comment"># 删除前逐一询问确认</span><br><span class="hljs-built_in">rm</span> -f<br><span class="hljs-comment"># 即使是只读的档案，也直接删除，无需确认</span><br></code></pre></td></tr></table></figure><h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><p>  关机，默认60s</p><ul><li>shutdown now<br>立刻关机</li></ul><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>  将文件按字母顺序对内容进行排序</p><h3 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h3><h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><p>  以管理员权限执行命令</p><h3 id="su"><a href="#su" class="headerlink" title="su"></a>su</h3><p>  切换用户</p><ul><li>su cyber_eye</li><li>exit<br>退出用户</li></ul><h3 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h3><p>  涉及到操控系统方方面面的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl reboot<br><span class="hljs-comment"># 重启系统</span><br><br>sudo systemctl poweroff<br><span class="hljs-comment"># 关闭系统，切断电源</span><br><br>sudo systemctl halt<br><span class="hljs-comment"># CPU停止工作</span><br><br>sudo systemctl <span class="hljs-built_in">suspend</span><br><span class="hljs-comment"># 暂停系统</span><br><br>sudo systemctl hibernate<br><span class="hljs-comment"># 让系统进入冬眠状态</span><br><br>sudo systemctl hybird-sleep<br><span class="hljs-comment"># 让系统进入交互式休眠状态</span><br><br>sudo systemctl rescue<br><span class="hljs-comment"># 启动进入救援状态（单用户状态）</span><br></code></pre></td></tr></table></figure><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>  只看文档的末尾</p><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><p>  创建一个文件</p><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>  查看正在消耗系统性能的进程</p><h5 id="U-根据用户来筛选"><a href="#U-根据用户来筛选" class="headerlink" title="-U 根据用户来筛选"></a>-U 根据用户来筛选</h5><h5 id="k-给某一个pid一个信号-可以用来杀死进程-9"><a href="#k-给某一个pid一个信号-可以用来杀死进程-9" class="headerlink" title="-k 给某一个pid一个信号,可以用来杀死进程(9)"></a>-k 给某一个pid一个信号,可以用来杀死进程(9)</h5><h5 id="X-5显示完整用户名"><a href="#X-5显示完整用户名" class="headerlink" title="-X 5显示完整用户名"></a>-X 5显示完整用户名</h5><h3 id="unzip"><a href="#unzip" class="headerlink" title="unzip"></a>unzip</h3><p>  解压缩文件</p><h3 id="useradd-adduser"><a href="#useradd-adduser" class="headerlink" title="useradd&#x2F;adduser"></a>useradd&#x2F;adduser</h3><p>  添加一个新用户&#x2F;添加一个用户，可以指定密码等参数</p><h3 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h3><p>  所有命令所在文件夹</p><h3 id="which"><a href="#which" class="headerlink" title="which"></a>which</h3><p>  找到命令的位置</p><h3 id="whoami"><a href="#whoami" class="headerlink" title="whoami"></a>whoami</h3><p>  输出我的用户名</p><h3 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h3><p>  从网络下载文件</p><h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><p>  创建压缩文件</p><ul><li>zip [] []</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Typora的LaTex使用</title>
    <link href="/2024/03/29/%E5%9F%BA%E4%BA%8ETypora%E7%9A%84Latex%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/03/29/%E5%9F%BA%E4%BA%8ETypora%E7%9A%84Latex%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>使用前需要先配置好[Typora](<a href="https://typora.io/">Typora — a markdown editor, markdown reader.</a>)及<a href="https://github.com/jgm/pandoc/releases/latest">pandoc</a>以便能将写好的内容导出为LaTex形式</p><p>用$$以创建公式段</p><h4 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h4><ul><li>\\或者\newline</li></ul><p>$$<br>a\newline b \newline c<br>$$</p><h4 id="上标"><a href="#上标" class="headerlink" title="上标"></a>上标</h4><ul><li>a^2</li><li>a^{2222}</li></ul><p>$$<br>a^2<br>a^{2222}<br>$$</p><h4 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h4><ul><li>a_2</li><li>a_{2222}</li></ul><p>$$<br>a_2<br>a_{2222}<br>$$</p><h4 id="水平线"><a href="#水平线" class="headerlink" title="水平线"></a>水平线</h4><ul><li>\overline{}</li><li>\underline{}</li></ul><h1 id="overline-a-b-c"><a href="#overline-a-b-c" class="headerlink" title="$$\overline{a+b+c}"></a>$$<br>\overline{a+b+c}</h1><p>\underline{a+b+c}<br>$$</p><h4 id="平方根"><a href="#平方根" class="headerlink" title="平方根"></a>平方根</h4><ul><li>\sqrt[n]{a+b+c}</li></ul><p>$$<br>\sqrt[n]{a+b+c}<br>$$</p><h4 id="水平大括号"><a href="#水平大括号" class="headerlink" title="水平大括号"></a>水平大括号</h4><ul><li>\overbrace{2,3,4,\cdots,100}^{99}</li><li>\underbrace{2,3,4,…,100}^{99}</li></ul><p>$$<br>\overbrace{2,3,4,…,100}^{99}<br>\\underbrace{2,3,4,…,100}^{99}<br>$$</p><h4 id="分数"><a href="#分数" class="headerlink" title="分数"></a>分数</h4><ul><li>\frac{1}{2}</li></ul><p>$$<br>\frac{1}{2}<br>$$</p><h4 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h4><ul><li>\int_{a}^{b}</li></ul><p>$$<br>\int_{a}^{b}<br>$$</p><h4 id="箭头"><a href="#箭头" class="headerlink" title="箭头"></a>箭头</h4><ul><li>\to</li></ul><p>$$<br>\to<br>$$</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LaTex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python库-time</title>
    <link href="/2024/03/29/Python%E5%BA%93-time/"/>
    <url>/2024/03/29/Python%E5%BA%93-time/</url>
    
    <content type="html"><![CDATA[<h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点:"></a>知识点:</h4><ul><li><p>时间戳timestamp </p><p>自1970年1月1日8:00以来的秒数</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">1700143008</span>.<span class="hljs-number">9008837</span><br></code></pre></td></tr></table></figure></li><li><p>时间对象struct_time</p><p>即一个时间元组</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">time.struct_time(<span class="hljs-attribute">tm_year</span>=2023, <span class="hljs-attribute">tm_mon</span>=11, <span class="hljs-attribute">tm_mday</span>=16, <span class="hljs-attribute">tm_hour</span>=14, <span class="hljs-attribute">tm_min</span>=1, <span class="hljs-attribute">tm_sec</span>=10, <span class="hljs-attribute">tm_wday</span>=3, <span class="hljs-attribute">tm_yday</span>=320, <span class="hljs-attribute">tm_isdst</span>=0)<br></code></pre></td></tr></table></figure></li><li><p>默认时间字符串default_time</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Thu</span> Nov <span class="hljs-number">16</span> <span class="hljs-number">21</span>:<span class="hljs-number">58</span>:<span class="hljs-number">46</span> <span class="hljs-number">2023</span><br></code></pre></td></tr></table></figure></li><li><p>自定义时间字符串format_time</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Thu</span> Nov <span class="hljs-number">16</span> <span class="hljs-number">23</span>:<span class="hljs-number">27</span>:<span class="hljs-number">54</span> <span class="hljs-number">2023</span><br></code></pre></td></tr></table></figure></li><li><p>GMT</p><p>格林尼治时间，是世界时和地球经线的起点</p></li><li><p>UTC</p><p>通用协调时间，一般可以当成GMT一眼的使用</p></li></ul><h4 id="获取时间"><a href="#获取时间" class="headerlink" title="获取时间"></a>获取时间</h4><ul><li><p>time.time()</p><p>获取当前时间的时间戳</p></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-number">1700143008.9008837</span><br></code></pre></td></tr></table></figure><ul><li><p>time.ctime()</p><p>返回一个表示当前日期和时间的字符串</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">Thu Nov <span class="hljs-number">16</span> <span class="hljs-number">21</span>:<span class="hljs-number">58</span>:<span class="hljs-number">46</span> <span class="hljs-number">2023</span><br></code></pre></td></tr></table></figure><ul><li><p>time.gmtime()</p><p>接受时间戳并返回时间对象，此时间为UTC时间</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">time.struct_time(tm_year=<span class="hljs-number">2023</span>, tm_mon=<span class="hljs-number">11</span>, tm_mday=<span class="hljs-number">16</span>, tm_hour=<span class="hljs-number">14</span>, tm_min=<span class="hljs-number">1</span>, tm_sec=<span class="hljs-number">10</span>, tm_wday=<span class="hljs-number">3</span>, tm_yday=<span class="hljs-number">320</span>, tm_isdst=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><ul><li><p>time.localtime()</p><p>和上一函数功能相同，但返回的是本地时间</p></li></ul><h4 id="时间转换"><a href="#时间转换" class="headerlink" title="时间转换"></a>时间转换</h4><ul><li><p>time.asctime(time)</p><p>接受时间元组并返回默认时间字符串，time不传入会自动获取系统时间</p><p>返回默认格式为<code>%a %b %d %H:%M:%S %Y</code>，含义为:</p><ul><li>%A本地完整星期名称February</li><li>%a星期Feb</li><li>%m月份7</li><li>%B本地完整的月份名称November</li><li>%b月份Nov</li><li>%d日期27</li><li>%p上午&#x2F;下午AM</li><li>%H24小时制时间23</li><li>%I12小时制时间11</li><li>%M分钟 06</li><li>%S秒 36</li><li>%Y年份2023</li><li>%c完整的时间输出</li><li>%z与UTC时间的差值+HHMM或-HHMM表示</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">Thu Nov <span class="hljs-number">16</span> <span class="hljs-number">22</span>:<span class="hljs-number">57</span>:<span class="hljs-number">00</span> <span class="hljs-number">2023</span><br></code></pre></td></tr></table></figure></li><li><p>time.mktime(time)</p><p>接受时间元组并返回时间戳</p></li></ul><h4 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h4><ul><li><p>time.strftime(format,time)</p><p>接收以时间对象<strong>struct_time</strong>,并返回以自定义字符串所表示的当地时间，格式由format决定，time不传入会自动获取系统时间</p></li><li><p>time.striptime(string,format)</p><p>根据format规定的格式把一个时间字符串解析为时间元组</p></li></ul><h4 id="程序计时"><a href="#程序计时" class="headerlink" title="程序计时"></a>程序计时</h4><ul><li>time.process_counter()</li></ul><p>​返回当前进程执行CPU的时间总和，不包含睡眠时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">0.671875</span><br></code></pre></td></tr></table></figure><ul><li><p>time.perf_counter()</p><p>返回计时器的精准时间（系统运行时间），包含整个系统的睡眠时间</p></li><li></li></ul><h4 id="暂停时间（The-World）"><a href="#暂停时间（The-World）" class="headerlink" title="暂停时间（The World）"></a>暂停时间（The World）</h4><ul><li>time.sleep(secs)</li></ul><p>​推迟调用线程的运行，secs以秒数为单位</p><p>内容参考：<a href="https://zhuanlan.zhihu.com/p/107919729">学会掌控时间，python中时间模块（time）的用法</a>及微软copilot返回内容</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>python库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vscode快捷键</title>
    <link href="/2024/03/29/Vscode%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2024/03/29/Vscode%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<h4 id="注释与取消注释"><a href="#注释与取消注释" class="headerlink" title="注释与取消注释"></a>注释与取消注释</h4><ul><li><p>Ctrl+K+C &#x2F;Ctrl+&#x2F;注释 </p></li><li><p>Ctrl+K+U &#x2F;Ctrl+&#x2F;取消注释</p></li></ul><h4 id="批量重命名"><a href="#批量重命名" class="headerlink" title="批量重命名"></a>批量重命名</h4><ul><li>F2更改变量名</li><li>Ctrl+F2更改所有匹配项</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Visual Studio Code</tag>
      
      <tag>快捷键</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓笔记</title>
    <link href="/2024/03/29/%E5%AE%89%E5%8D%93%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/03/29/%E5%AE%89%E5%8D%93%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="如何将视频资源放进apk中播放"><a href="#如何将视频资源放进apk中播放" class="headerlink" title="如何将视频资源放进apk中播放"></a>如何将视频资源放进apk中播放</h4><ol><li>将视频文件放到项目工程的 res&#x2F;raw 文件下</li><li>视频文件必须是Android支持的视频格式3gp, wmv, mp4, 且命名必须是小写字母，数字，下划线</li><li>在代码中引用这个资源文件时，必须使用R statics类，同时去除文件的后缀名—— R.name</li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序员笑话集</title>
    <link href="/2024/03/29/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%AC%91%E8%AF%9D%E9%9B%86/"/>
    <url>/2024/03/29/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%AC%91%E8%AF%9D%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p>程序员笑话是程序员界的一大瑰宝，不可不尝（乐）</p><p>本文用以搜集一些在网上找到的程序员笑话以供我自己和看到这篇文章的人图一乐，因为解释笑点本身会杀死笑话的乐趣，我会另开一篇文章以解释笑话内涵的知识</p><ol><li><p>我印象最深刻的笑话</p><p>老婆给当程序员的老公打电话</p><p>“下班顺路买一斤包子回来，如果遇到卖西瓜的就买一个”</p><p>然后程序员带着一个包子回家了</p><p>老婆勃然大怒</p><p>”我电话里怎么跟你说的？你就买一个包子回来？“</p><p>”啊？我看到卖西瓜的了啊？“</p></li><li><p>一个测试工程师走进一家酒吧，要了一杯啤酒</p><p>一个测试工程师走进一家酒吧，要了一杯咖啡</p><p>一个测试工程师走进一家酒吧，要了0.7杯啤酒</p><p>一个测试工程师走进一家酒吧，要了-1杯啤酒</p><p>一个测试工程师走进一家酒吧，要了2^32杯啤酒</p><p>一个测试工程师走进一家酒吧，要了一杯洗脚水</p><p>一个测试工程师走进一家酒吧，要了一杯蜥蜴</p><p>一个测试工程师走进一家酒吧，要了一份asdfQwer@24dg!&amp;*(@</p><p>一个测试工程师走进一家酒吧，什么也没要</p><p>一个测试工程师走进一家酒吧，又走出去又从窗户进来又从后门出去从下水道钻进来</p><p>一个测试工程师走进一家酒吧，又走出去又进来又出去又进来又出去，最后在外面把老板打了一顿</p><p>一个测试工程师走进一</p><p>一个测试工程师走进一家酒吧，要了一杯烫烫烫的锟斤拷</p><p>一个测试工程师走进一家酒吧，要了NaN杯Null</p><p>1T测试工程师冲进一家酒吧，要了500T啤酒咖啡洗脚水野猫狼牙棒奶茶</p><p>1T测试工程师把酒吧拆了</p><p>一个测试工程师化装成老板走进一家酒吧，要了500杯啤酒并且不付钱</p><p>一万个测试工程师在酒吧门外呼啸而过</p><p>一个测试工程师走进一家酒吧，要了一杯啤酒’;DROP TABLE 酒吧</p><p>测试工程师们满意地离开了酒吧。然后一名顾客点了一份炒饭，酒吧炸了</p></li><li><p>来一个黑客军团笑话</p></li></ol><p>​你地址多少？ What‘s your address?</p><p>​173.168.15.10</p><p>​不，我问的是你的本地地址 No,your local address</p><p>​127.0.0.1</p><p>​我的意思是你的物理地址 I mean your physical address</p><p>​29:01:38:62:31:58</p><p>​…fuck</p><ol start="4"><li><p>早晨一女生背着一堆书出了图书馆，结果警报响了，大妈让女生看看是哪本书把警报弄响了，那女生把书倒出来，准备一本一本的测。大妈见状急了，把书分成两份，第一份过了一下，响了。又把这一份分成两份接着测，三回就找到了，大妈用鄙视的眼神看着女生，仿佛在说O(n)和O(logn)都分不清。</p><p>|</p><p>|</p><p>|</p><p>|</p><p>|</p><p>|</p><p>|</p><p>|</p><p>|</p><p>|</p><p>|</p><p>|</p><p>|</p><p>|</p><p>|</p><p>|</p><p>|</p><p>|</p><p>|</p><p>|</p><p>|</p><p>|</p><p>|</p><p>|</p><p>|</p><p>|</p><p>|</p><p>|</p><p>|</p><p>|</p><p>|</p><p>|</p><p>|</p><p>|</p><p>|</p><p>|</p><p>|</p><p>|</p><p>|</p><p>|</p><p>|</p></li></ol><p>​结果图书馆丢了n-1本书。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笑话</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性表的增删改查</title>
    <link href="/2024/03/29/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"/>
    <url>/2024/03/29/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</url>
    
    <content type="html"><![CDATA[<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><h4 id="C-1"><a href="#C-1" class="headerlink" title="C#"></a>C#</h4>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux操作</title>
    <link href="/2024/03/29/Linux%E6%93%8D%E4%BD%9C/"/>
    <url>/2024/03/29/Linux%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h4 id="Linux查看系统信息"><a href="#Linux查看系统信息" class="headerlink" title="Linux查看系统信息"></a>Linux查看系统信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">lsb_release -a<br></code></pre></td></tr></table></figure><p>这个工具属于Linux Standard Base（LSB）的一部分。LSB 是一套为 Linux 系统制定的标准化规范，旨在提高不同 Linux 发行版之间的兼容性。</p><table><thead><tr><th align="left">选项</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left"><code>-a</code> 或 <code>--all</code></td><td align="left">显示所有系统信息，包括发行版名称、版本号、描述和代号</td></tr><tr><td align="left"><code>-i</code> 或 <code>--id</code></td><td align="left">显示发行版的标识符（如 Ubuntu、Debian）</td></tr><tr><td align="left"><code>-d</code> 或 <code>--description</code></td><td align="left">显示发行版的详细描述</td></tr><tr><td align="left"><code>-r</code> 或 <code>--release</code></td><td align="left">显示发行版的版本号</td></tr><tr><td align="left"><code>-c</code> 或 <code>--codename</code></td><td align="left">显示发行版的代号（如 Ubuntu 的 <code>focal</code> 或 Debian 的 <code>buster</code>）</td></tr><tr><td align="left"><code>-s</code> 或 <code>--short</code></td><td align="left">以简洁格式输出信息，不显示标签</td></tr><tr><td align="left"><code>-h</code> 或 <code>--help</code></td><td align="left">显示帮助信息</td></tr></tbody></table><h4 id="Linux换源"><a href="#Linux换源" class="headerlink" title="Linux换源"></a>Linux换源</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vim /etc/apt/sources.list<br><br><span class="hljs-comment">#中科大</span><br>deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib<br>deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib<br><span class="hljs-comment">#阿里云</span><br>deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib<br>deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib<br><span class="hljs-comment">#清华大学</span><br>deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free<br>deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free<br></code></pre></td></tr></table></figure><h4 id="kali安装工具集"><a href="#kali安装工具集" class="headerlink" title="kali安装工具集"></a>kali安装工具集</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install kali-linux-default<br>包含了Kali linux默认的工具集，大概有9GB左右<br>sudo apt install kali-linux-everything<br>包含了所有的kali工具，大小非常大，约11GB左右<br></code></pre></td></tr></table></figure><h4 id="转移WSL下安装的linux系统位置"><a href="#转移WSL下安装的linux系统位置" class="headerlink" title="转移WSL下安装的linux系统位置"></a>转移WSL下安装的linux系统位置</h4><p>常见的教程是手写命令行，比较麻烦，可以直接用GitHub上写好的<a href="https://github.com/pxlrbt/move-wsl">powershell脚本</a></p><h4 id="Linux命令后台运行"><a href="#Linux命令后台运行" class="headerlink" title="Linux命令后台运行"></a>Linux命令后台运行</h4><ul><li>在执行程序时命令的最后加&amp;</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">./test.py &amp;<br><span class="hljs-comment"># 在后台执行文件</span><br>ps -ef|grep <span class="hljs-built_in">test</span><br><span class="hljs-comment"># 查看是否在后台运行</span><br>killall <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p><strong>缺点：</strong> 此方法查看运行日志不方便</p><h4 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h4><p>经过了<strong>一整天</strong>的折腾之后，事实证明用linux自带的sendmail和mailx发邮件是相当愚蠢的，而且我也没有在网上找到21年之后有什么相关的技术博客，所以最终我选择使用python的yagmail库，问题迎刃而解了，mad人生苦短</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install yagmail<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> yagmail<br>mail=yagmail.SMTP(<span class="hljs-string">&#x27;发送邮箱的账号&#x27;</span>，<span class="hljs-string">&#x27;发送邮箱的授权码&#x27;</span>，<span class="hljs-string">&#x27;smtp163.com&#x27;</span>)<br>mail.send(<span class="hljs-string">&#x27;接受邮件的账号&#x27;</span>，<span class="hljs-string">&quot;(标题)测试邮件&quot;</span>,<span class="hljs-string">&quot;邮件文本&quot;</span>)<br>mail.close()<br><br><span class="hljs-comment">#多个收件人</span><br>receiver=[<span class="hljs-string">&quot;xxx@qq.com&quot;</span>,<span class="hljs-string">&quot;xxx@163.com&quot;</span>]<br><span class="hljs-comment">#文本内容</span><br>text=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Dear Toph,\n\n</span><br><span class="hljs-string">这是一段文本内容</span><br><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure><h4 id="将命令添加到环境变量中"><a href="#将命令添加到环境变量中" class="headerlink" title="将命令添加到环境变量中"></a>将命令添加到环境变量中</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 以miniconda举例</span><br><span class="hljs-comment"># 已将miniconda3安装到/home/homovexillues/miniconda3</span><br><span class="hljs-comment"># 使用的是bash shell，配置~/.bashrc，如果是别的shell也可以配置~/.zshrc 或 ~/.cshrc</span><br>vim ~/.bashrc<br><span class="hljs-comment"># 在配置文件中添加如下内容</span><br><span class="hljs-built_in">export</span> PATH=/home/homovexillues/miniconda3/conda/bin:<span class="hljs-variable">$PATH</span><br><span class="hljs-comment"># 然后关闭并保存配置文件，运行</span><br><span class="hljs-built_in">source</span> ~/.bashrc<br><span class="hljs-comment"># 重新加载配置文件以使之生效</span><br></code></pre></td></tr></table></figure><h4 id="解压文件"><a href="#解压文件" class="headerlink" title="解压文件"></a>解压文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 解包</span><br>tar -xf 文件名.tar<br><span class="hljs-comment"># 打包</span><br>tar -cf 压缩包名.tar 文件或目录<br><span class="hljs-comment"># zip格式需要下载</span><br>sudo apt install zip<br><span class="hljs-comment"># 解压</span><br>unzip 文件名.zip<br><span class="hljs-comment"># 压缩</span><br>zip -r 压缩包名.zip 文件或目录<br><span class="hljs-comment"># 7z格式需要下载</span><br>sudo apt install p7zip-full<br><span class="hljs-comment"># 解压</span><br>7z x 文件名.7z<br><span class="hljs-comment"># 压缩</span><br>7z a 文件名.7z 文件名or文件夹名<br></code></pre></td></tr></table></figure><h4 id="重启bash"><a href="#重启bash" class="headerlink" title="重启bash"></a>重启bash</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bashrc <span class="hljs-comment">#可以使bash读取最新配置文件，但不会改变当前的进程ID和环境变量</span><br><span class="hljs-built_in">exec</span> bash <span class="hljs-comment"># 启动一个新的bash进程，同时继承当前的进程ID和环境变量</span><br></code></pre></td></tr></table></figure><h4 id="添加一个用户"><a href="#添加一个用户" class="headerlink" title="添加一个用户"></a>添加一个用户</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">adduser homojupyter <span class="hljs-comment"># 添加一个用户</span><br>su homojupyter <span class="hljs-comment"># 切换到此用户</span><br></code></pre></td></tr></table></figure><h4 id="赋予sudo权限"><a href="#赋予sudo权限" class="headerlink" title="赋予sudo权限"></a>赋予sudo权限</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 编辑/etc/sudoers配置文件</span><br><span class="hljs-comment">## Allow root to run any commands anywhere</span><br>root    ALL=(ALL)       ALL<br>homojupyter  ALL=(ALL)       ALL<br></code></pre></td></tr></table></figure><h4 id="Linux系统文档改为中文"><a href="#Linux系统文档改为中文" class="headerlink" title="Linux系统文档改为中文"></a>Linux系统文档改为中文</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 先下载中文语言包</span><br>apt install language-pack-zh-hans<br><span class="hljs-comment"># 更新系统默认语言</span><br>apt update-locale LANG=zh_CN.UTF-8<br><span class="hljs-comment"># 重启系统或重新登录让语言设置生效</span><br>reboot<br></code></pre></td></tr></table></figure><h4 id="查看系统版本"><a href="#查看系统版本" class="headerlink" title="查看系统版本"></a>查看系统版本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/os-release<br></code></pre></td></tr></table></figure><h4 id="查看当前位置下的所有文件夹"><a href="#查看当前位置下的所有文件夹" class="headerlink" title="查看当前位置下的所有文件夹"></a>查看当前位置下的所有文件夹</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -ld */<br>ls -l | grep ^d<br></code></pre></td></tr></table></figure><h4 id="如何增删改查Linux正在运行的所有服务"><a href="#如何增删改查Linux正在运行的所有服务" class="headerlink" title="如何增删改查Linux正在运行的所有服务"></a>如何增删改查Linux正在运行的所有服务</h4>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>WSL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>梗与解构主义</title>
    <link href="/2024/03/29/%E6%A2%97%E4%B8%8E%E8%A7%A3%E6%9E%84%E4%B8%BB%E4%B9%89/"/>
    <url>/2024/03/29/%E6%A2%97%E4%B8%8E%E8%A7%A3%E6%9E%84%E4%B8%BB%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<p>网络用语和梗是一种新时代的切口和赛博黑话，而这种梗的创作是新时代的个体对新时代话语权的争夺和对权威的消解，而梗小鬼和烂梗和云的出现正是年轻的个体急于融入互联网团体又东施效颦的写照,本文旨在收集整理一些日常生活中可能会用到的梗和一些有趣的使用场景，以达到信手拈来的目的。</p><ul><li><p>刃牙道</p></li><li><p>海虎</p></li><li><p>是，大臣</p><ul><li><p><strong>拖延战术五个阶段：</strong></p><ol><li><p>部门&#x2F;项目新建，有很多事情要处理</p></li><li><p>你说的很对，但你确定这就是达成目的的最好方法？</p></li></ol><p>如果还没有被唬住就会转移方向，从告诉你怎么作改为告诉你什么时候做</p><ol start="3"><li>现在不是恰当的时机，出于各种原因</li></ol><p>若还未妥协</p><ol start="4"><li><p>实施起来有种种困难 技术上，行政上，法律上，法律是最好的托辞，因为玄虚莫名</p></li><li><p>下一届选举近在咫尺，你能确保着政策通过？</p></li></ol></li></ul></li><li><p>尚未分类</p><ul><li>你在橘子树上挂着不要动我给你买个火车站去</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>梗</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见奇幻设定及其问题总结</title>
    <link href="/2024/03/29/%E5%B8%B8%E8%A7%81%E5%A5%87%E5%B9%BB%E8%AE%BE%E5%AE%9A%E5%8F%8A%E5%85%B6%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2024/03/29/%E5%B8%B8%E8%A7%81%E5%A5%87%E5%B9%BB%E8%AE%BE%E5%AE%9A%E5%8F%8A%E5%85%B6%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>本文整理了常见影视作品，神话，志怪故事，小说中的设定及槽点</p><ul><li>请神<br>  或者说是出马，神打，将某种灵体召唤并附身，理想情况下可以形成英灵殿那种设定，并在出现杰出人物之后将其召唤并解决问题，但是由于前面成为灵体的个体太过强力了，很容易在出现这样一个杰出个体之后让体系内的个体强大自身不如直接请神，然后整个体系都变成这个功能的附庸。还有一个比较有槽点的是，如果一个个体的杰出能力本身就是优秀的召唤能力，然后这个个体进入了“英灵殿”，那请这种个体算不算嵌套召唤啊？这个系统支持递归调用吗？是不是可以开发基于神打系统的逻辑门和计算机啊？</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小说</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>赛博英雄传设定集</title>
    <link href="/2024/03/29/%E8%B5%9B%E5%8D%9A%E8%8B%B1%E9%9B%84%E4%BC%A0%E8%AE%BE%E5%AE%9A%E9%9B%86/"/>
    <url>/2024/03/29/%E8%B5%9B%E5%8D%9A%E8%8B%B1%E9%9B%84%E4%BC%A0%E8%AE%BE%E5%AE%9A%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p>本文旨在收集并整理小说《赛博英雄传》的设定，内容基于群友整理文档“赛博英雄传设定·格式调整版.docx”,由于是设定集，因此内容包含大量<strong>剧透</strong>，如有侵权我会立刻删除。</p><h1 id="一、-世界观"><a href="#一、-世界观" class="headerlink" title="一、 世界观"></a>一、 世界观</h1><h2 id="时代背景"><a href="#时代背景" class="headerlink" title="时代背景"></a>时代背景</h2><p>什么是武？武功是技术，一种让弱者窥得机会向强者挥刀的技术。</p><p>什么是侠？侠义是暴力，是被逼上梁山者为暴君打造的刺刀。</p><p>这是一个武侠的故事。21世纪30年代，几个志同道合的年轻人走到一起，为了改变世界而努力。二百多年后，某个垃圾填埋场内，当初重开天地自成体系的赛博武道初祖向山，却在失去了一切记忆体的情况下，念着仇敌的名字醒了过来。世界被他的旧友兼仇敌统治了两百年，大部分人类都生活在恶劣的环境中，一切都变得更糟了。</p><p>“或许就是因为当初我输了，所以世界才会变成这个样子……”</p><p>“那么这一次，我再不会败！”</p><p>这是一个人，再一次改变世界的故事…..</p><h2 id="特殊概念"><a href="#特殊概念" class="headerlink" title="特殊概念"></a>特殊概念</h2><h3 id="基准人-Homo-Vexillues"><a href="#基准人-Homo-Vexillues" class="headerlink" title="基准人(Homo Vexillues)"></a><strong>基准人(Homo Vexillues)</strong></h3><p>（第一卷原文：</p><p>Vexillues，拉丁文vexillum的变体，standard&#x2F;基准之意。“基准人”&#x2F;Homo vexillues是生物学上有别于智人的物种。将智人改造成基准人的基因疗法，是义体改造的前置。基准人需要补充更多的金属元素，其身体密度大于智人，可以自主产生金属簇蛋白质层，不会受到21世纪初所有已知原生病原体的感染，其细胞拥有极强的抗机械损伤能力、抗缺氧能力，且拥有抗衰老能力。基准人寿命远高于智人，理论自然寿命有三百至四百年。</p><p>最重要的是，基准人可以依靠电场能替代部分ATP水解来给细胞供能。这一技术最开始似乎是为了解决人类的吃饭问题，让世界再无饥荒，解放更多劳动力。）</p><p>是智人进行手术改造而产生的全新的人种，基准人可以依靠电场能替代部分ATP水解来给细胞供能，大脑能通过金属基蛋白覆盖脑血屏障形成的脑机屏障直接操控电子元件。基准人只需要电能与少量营养物质就可以维持生命，体温高达56℃，并因此免疫地球原生的绝大多数病菌，抗损伤能力远高于智人，理论自然寿命有三百至四百年。基准人是“超人类主义公司”为了“消灭饥荒与疾病”而努力得到的研究成果，是人类实现义体化的前置条件。</p><h3 id="戴森原则"><a href="#戴森原则" class="headerlink" title="戴森原则"></a><strong>戴森原则</strong></h3><p>第零条：所有没有明确拒绝遵守戴森原则、或没有明确违反原则行为的个体，均默认遵守戴森原则，接受文明庇护。戴森原则为人类文明唯一普世原则。任何不违反戴森原则的行为都应被许可。</p><p>第一条：所有人类都有义务维持人类基因多样性。拒绝此项义务，将自动失去文明庇护。</p><p>第二条：禁止损害他人生物脑。</p><p>第三条：禁止制造、使用、销售成瘾类药剂。</p><p>第四条：私有财产存在且被保护。</p><p>第五条：允许且仅允许任何人以“个体向另一个体宣示效忠”的形式建立组织。</p><h3 id="武神更生"><a href="#武神更生" class="headerlink" title="武神更生"></a><strong>武神更生</strong></h3><p>在武祖向山被独裁者约格莫夫宣告处决后，为了保持侠客们对侠义之道的信心，部分向山的好友制造出了第二武神，但因对其的看法不同而导致了侠客阵营的分裂；部分侠客转投庇护者阵营，“图灵”因此退隐。约格莫夫将武祖的部分记忆以区块链的形式上传，为了保证武祖的形象不被歪曲，武祖的旧识们也将自己与武祖有关的记忆上传到同一区块链。此后不断有人访问此区块链，下载武祖的记忆，通过特殊的训练使自己的大脑拥有武祖向山的记忆与思维方式，等效于使武祖向山用自己的大脑中复活。这一现象被称为“武神更生”，在主角苏醒之前已经产生过十位武神。</p><p>任意个体需要满足两个条件才会被认定为武神：</p><ol><li>获取向山的记忆并自愿成为向山；</li><li>得到向山的昔日好友们的承认。</li></ol><h3 id="图灵机"><a href="#图灵机" class="headerlink" title="图灵机"></a><strong>图灵机</strong></h3><p>现代计算机的起源，是人类研究数学的过程中获得的最伟大的产物，也是一切内功的起源。在庇护者操控的计算机深入包括人脑在内的一切事物的时代，计算机的基本模型依然是图灵机，只有超脱图灵机结构的人脑可以反抗拥有近乎无限计算资源的庇护者。</p><h3 id="赛博内功"><a href="#赛博内功" class="headerlink" title="赛博内功"></a><strong>赛博内功</strong></h3><p>由祝心雨发明的赛博黑客手段，使得基准人可以用大脑直接输出程序，发挥智人时代的黑客技术。分为指令境,语言境,编译境,汇编境,机械境,以及传说之中的数学境,还有传说之上的图灵境。目前明确达到了图灵境的只有“图灵”祝心雨一人。</p><h3 id="神速王庭"><a href="#神速王庭" class="headerlink" title="神速王庭"></a><strong>神速王庭</strong></h3><p>一艘目前人类最高技术结晶的战舰，最高速度可以达到百分之十光速，主要任务是寻找一条可以以亚光速抵达太阳系之外的安全航路。</p><h3 id="伊沃路细胞"><a href="#伊沃路细胞" class="headerlink" title="伊沃路细胞"></a><strong>伊沃路细胞</strong></h3><p>约格莫夫的肿瘤细胞，在二十一世纪被本人捐献出来，希望其成为基准人的“海拉”细胞，但在主角的年代已经被改造为武器用于镇压侠客。</p><h3 id="人格覆面"><a href="#人格覆面" class="headerlink" title="人格覆面"></a><strong>人格覆面</strong></h3><p>所有“模拟而成的、社会化的人格”的总称。分为“真性人格覆面”和“假性人格覆面”两种。</p><p>假性人格覆面是指“计算机模拟的人格”。它的界定方式是图灵测试的逻辑，即一个程序若是可以扮演一人，并成功的欺骗被扮演者的亲友，则可被认定为是“假性人格覆面”。</p><p>真性人格覆面则是人的生物脑在特定技术的帮助下，借助特定个体的记忆，成功实现对特定的个体的“扮演”，并产生了“我就是记忆原主人”的自我认知。可以看作原主人的精神在全新生物脑上的重现。</p><p>在目前的世界观由于“假性人格覆面”没有生物脑，所有无法单独使用内功。仅有第八武神与图灵一脉掌握了使人格覆面借助他人生物脑能够使用内功的技术，主角向山在接纳了第八武神的AI后也继承了这项技术。</p><h3 id="极道共识疗法"><a href="#极道共识疗法" class="headerlink" title="极道共识疗法"></a><strong>极道共识疗法</strong></h3><p>东亚弧形列岛的黑帮中，一位内功天才创造的一项技术，由拓世者为降低学习成本的技术衍生而来，本意是让人们接受同一份集体记忆，从而能够用相同的情感看待社会、维系团体，创造大同社会。但由于“共识记忆”之中“对非团体成员的仇恨与破坏欲”不断放大，最终形成了一种精神瘟疫。现在被绿林作为洗脑手段用在新加入的成员身上。</p><h2 id="技术发展"><a href="#技术发展" class="headerlink" title="技术发展"></a>技术发展</h2><p><strong>概况</strong></p><p>在二十一世纪中叶，伴随着约格莫夫破解酶系统，各项技术得到了飞速的发展。超人企业作为一家几乎领导着技术发展方向的，巨无霸型的跨国公司，以“<strong>人类基准化</strong>”“<strong>全身义体化改造</strong>”“<strong>新文化潮流</strong>”“<strong>网络赛博空间</strong>”四个目标为主要方向而前进。（后面写义体化，但是写不动了）</p><p>尽管向山苏醒后的这个时代看起来像是废土时代，但却并没有发生“科技退步”的事情。科研骑士团的存在，让技术始终保持着进步。只不过，由于“江湖”的存在，这个时代的军事技术与网络安全技术（即赛博内功与外功）发展得有些畸形。</p><p>在学术交流层面上，科研骑士团和江湖人其实算一个整体。他们和科研骑士做学术交流，通常都维持着一个“杀进去、抢论文、杀出来”的流程。但是，由于实际需要不同，出于不“资敌”的考虑，虽然共用一个理论基础，但是侠客与官府甚至开始有意识地创造两条平行的技术发展路线。侠客们会琢磨“如何让一个玩意在更恶劣的条件下长时间工作”，而官府则会偏向于“在短时间内发挥最大功用”。正因如此，侠客往往很难利用大部分官府的装备，需要频繁维护与更换部件。</p><p>所以在这个时代，很多科技的工业化生产和民用化研究都处于停滞状态。一些高精尖设备只能通过实验室生产出来，领主取得尖端设备的难易程度，取决于自己境内科研骑士团的研究方向与关系网。从某种意义上，这也是官府的必然选择，因为侠客们都具备一定的工程学知识，知道如何养护尖端武装，如何获取补给。一种装备，如果数量多起来了，那就会不可避免的流入江湖，成为侠客的助力。</p><p>技术层面的割裂在其它方面也广泛存在。甚至在硬件层面上的协议也几乎不兼容。江湖基本遵循“知识共享”的传统，依靠区块链散播入门之径，而门派内部则依靠磁力链共享知识。</p><p>（后面写后门的广泛存在及原因，侠客必须自己造轮子，信息在网路上传播的途径等等，写不动了……主要我对计算机网络不了解，也没办法把思路理清楚）</p><p><strong>生物科学</strong></p><p><strong>破解酶系统</strong></p><p><strong>基准人化</strong></p><p><strong>还丹酶、玉鼎菌、炉鼎菌</strong></p><p>还丹酶是一种可以逆转神经细胞生命周期的特殊酶，可以使人类的神经网络重置回到初始状态。可以做到一次只还原一小部分神经网络，但是人类没有彻底破译大脑的运算方式，无法做到精准的删除某个部分的记忆。还丹酶入脑之后，接受治疗的人就会飞快的出现遗忘症状，将过去的知识、记忆全部淡忘。在早期的记录之中，甚至连性格偏好都可以稍作改变。</p><p>“玉鼎菌”和“炉鼎菌”都是被改造的酵母菌。玉鼎菌的细胞核被植入了大量基因片段，还有大量携带独立遗传信息的细胞器，可以自发合成还丹酶。</p><p>“炉鼎菌”是一种较为稳定，专门用来与“存神病毒”共生的酵母菌。只要经过特殊手段处理，就可以从炉鼎菌中分离出有一定活性的毒株。</p><p>它们都是很重要的资源，对“索绪尔神域”的成型有着非常关键的作用。</p><p><strong>基因疗法</strong></p><p><strong>认知科学</strong></p><p><strong>索绪尔神域</strong></p><p>“内功”诞生之前，在神经科学项目中，利用基准人强大的抗损伤能力，往志愿者脑内植入柔性电极，观察他们学习第二语言的过程，并用这种研究方法，敲定了他们大脑中负责“语言机能”的区域。这一块最先被称作“索绪尔区”。</p><p>为了习得“无意识写代码”的能力，最初的内功高手对自己展开针对性训练，利用人体的代偿功能，借助激素、酶、病毒与有意识的训练将“索绪尔区”的神经网络进行特化，从而强化“索绪尔区”的神经网络与其他功能区的连接。到最后，“索绪尔区”的神经网络会重新与其他功能区进行另一种额外的“桥接”，形成一个名为“索绪尔神域”的整体结构。内功越是精深，大脑并入“索绪尔神域”的区域比例就越大。</p><p>由于语言与思维相关，所以索绪尔神域的开发，会导致思维的“升级”，并非每个人都能承受这种来自于内的痛苦。并且，索绪尔神域的成型，初期是从负责语言机能的“索绪尔区”开始，最终要扩展到大半个大脑上。想要修得强大的内力必须经过这一步，这个过程中忘记什么都是正常的。靠谱的做法，是将大脑内的东西，提前转移到硬盘之中，用电子设备代替自己记住那些东西。</p><p>可是，总有一部分东西很难无损转码。比如说绝大部分非陈述性的情感，又比如外功之中关于“生物脑与算法相适应”的部分——这部分内容只有存在于生物脑内才有意义。上传到硬盘之内，对于一个武者来说没有任何作用。</p><p>（综合了莫里的版本，有人觉得太多的话再改）</p><p><strong>记忆的读取与存储</strong></p><p><strong>这个时代已经有了外置的记忆存储设备</strong>，可以拓展大脑的容量，对于大多数人来说，想要学习新的技术，用硬盘存储，然后用生物脑适应硬盘中的信息就可以了。但是，硬盘中的信息，面对真正的高手，却可以被随意删除与篡改。而生物脑和图灵机可能并不相同，不管是何等的内功高手，也不可能挖出人类生物脑之中的信息。</p><p><strong>这种技术本质上是</strong>将大脑当中的记忆转化为二进制结构并存储起来。由于人脑与计算机存在着巨大的差异，所以计算机并不能直接读取这种格式的文件，只能逆向输入到大脑之中，在大脑之中唤起感官。陈述性记忆可以无损转化成机械语言；难以无损转化的记忆包括非陈述性记忆，比如难以确认的情绪，对于某次事件的直观感受等等。</p><p>在最初的设计当中，人类就要通过‘交换记忆’来解决‘学习问题’——它最大限度压缩了学习的成本，甚至有人预想，人类可以依靠这种技术达成无障碍交流，最终相互理解。后来，侠客们用它来互换武道经验。这种技术极大地方便了经验与知识的学习与传递，但是尽管“情绪化的记忆”难以精确的数据化，“知识的记忆”却也与“感官的记忆”与“情感的记忆”相联系。如果短时间内连续阅读他人记忆，自身成型观念都会受到冲击，乃至性格变化。</p><p>所以这种技术也是绿林们制造用来增殖自身的“共同记忆”的技术前置。</p><p>（1.方便经验和知识的学习与传递2.绿林、武神更生、persona的技术前置3.）</p><p><strong>物理学</strong></p><p>核聚变（义体小型仿星器、核潜艇）</p><p><strong>量子计算机、量子芯片</strong></p><p>对于量子计算机来说，热噪声是一种天敌。温度稍高，辐射稍强，环境背景温度就会干扰到脆弱的量子位，芯片也很容易损坏。所以二十一世纪初，量子芯片的运行环境要求是4K，即-269.15℃。</p><p>目前让量子逻辑门在更高温度工作的方法主要有两种：</p><p>一种是在更高的温度下再现超导现象，继而再去寻找在这个温度下创造超导量子逻辑门的手段；另一种是创造新的算法，可以让程序在“每一个逻辑门都不绝对可靠、随时都会出错”的环境下跑起来。两种手段双管齐下，才能让量子逻辑门在接近液氮的环境温度下运行起来。</p><p>过去向山使用过的量子芯片运行环境普遍在20K以下。那时，向山使用过依靠激光冷却的量子芯片，也使用过依靠稀释制冷机维持的量子芯片。</p><p>但是到正传主时间线，侠客已经可以获得80K的量子芯片，氦工质的小型制冷机就可以达到这个温度。甚至，最耐高温的量子逻辑门可以通过超导实现在常压200K的环境下工作，液态二氧化碳就可以维持。缺陷是生产难度极大，单个芯片的成本极高，现有技术条件之下几乎不可能大规模运用。除开火星的两家科研骑士团之外，就连基因库武装武官与科研骑士都不允许制造、持有可以生产这种量子芯片的设备。据说侠客方现在只有土星的少量侠客社区会生产这种超导量子芯片，产量也低，并且经过好几道手续才能流入地球。</p><p><strong>航天</strong></p><p>（太空开发情况、太空航行情况、战舰？）</p><h2 id="势力分布"><a href="#势力分布" class="headerlink" title="势力分布"></a>势力分布</h2><h3 id="侠义势力"><a href="#侠义势力" class="headerlink" title="侠义势力"></a><strong>侠义势力</strong></h3><p>以武祖提出的“侠义精神”为旗帜，在世界各地反抗万机之父统治体系的个人或团体，互相称为“侠客”，主要依靠去中心化算法，在互联网上相互交流，传播精神。侠客遍布太阳系，主要力量集中在火星与木星的小行星带之外。地球作为庇护者监管最严密的地区之一，侠义势力的力量处于低谷。侠义力量目前拥有几支主要舰队：始建于第六武神时期的白舰义从，第七武神的黑舰义从，随第九武神一同起义的赤星义从。</p><h3 id="文明庇护者"><a href="#文明庇护者" class="headerlink" title="文明庇护者"></a><strong>文明庇护者</strong></h3><p>俗称“官府”，是忠诚于万机之父的统治机器，自诩为“人类文明的庇护者”，为遵守戴森原则的人提供基本的人身权保护，但在“是否提供庇护”上有很大自主裁量权。然而，其最重要的任务并非为民众提供庇护，而是保卫人类基因库与科研骑士团。官府可以调动庞大的资源，但由于戴森原则的限制，庇护者们没有足够的人力控制民众的方方面面。</p><h3 id="科研骑士团"><a href="#科研骑士团" class="headerlink" title="科研骑士团"></a><strong>科研骑士团</strong></h3><p>又称“万机之父教团”，在序列上和文明庇护者平行，直属于万机之父，各级文明庇护者机构、任何世俗团体或个人，都无法管辖和干预他们。每一位科研骑士依照戴森原则直接向万机之父效忠，承担“对自然与未知发起冲锋”的科研任务。但科研骑士团也并非纯粹的科研机构，而同样拥有庞大的后勤与武官序列。</p><h3 id="六龙教"><a href="#六龙教" class="headerlink" title="六龙教"></a><strong>六龙教</strong></h3><p>隐匿于庇护者内部的神秘组织，行动似乎没有明确的纲领，渗透范围极广，存在时间很长。江湖人多称其为“魔教”。</p><h3 id="绿林"><a href="#绿林" class="headerlink" title="绿林"></a><strong>绿林</strong></h3><p>拒绝文明庇护外的黑帮组织，会用集体记忆洗脑成员、使成员无法脱离。以劫掠为生。</p><h1 id="二、赛博武学"><a href="#二、赛博武学" class="headerlink" title="二、赛博武学"></a>二、赛博武学</h1><p>是从战争之中升华的特种战术，相当于用技术手段，在原本的军事指挥体系上另开了一条“科技树”。在很长一段时间里，个体对战争走向的影响力不断缩减，所有的军事理念，都建立在“绝大多数情况下单兵素质相差不大”这一基础上。但武祖设计的赛博武术彻底摧毁了这一基础，建立在“以个体之身对抗暴政”的设计宗旨上，是历代所有“游击”、“狙击”、“暗杀”等特种作战理论的集大成者，更类似传统武侠世界观设定下的武功。基准人义体化后，零件、算法、经验等的优劣在很大程度上会决定武者能够使用的技巧，强大的义体可以发挥出精妙的技术，但垃圾义体同样可以通过千锤百炼的策略组，拉开与单兵之间的技巧差距，从而以弱胜强，用个体力量对战争造成最大影响。</p><p>虽然武功只是可以被任何人使用的“技术”，但它是针对暴政而设计的，它对暴政者的伤害，注定强于对民众的伤害。对侠客来说，由于绝大多数资源都被官府掌握，但武功的本体，是最难被强者所垄断、消灭的“算法”。只要信息技术与网络的去中心化存储还在，“武功”的情报就无法被抹除，弱者就永远会有接触它的机会，从而成为侠客，不断使用从敌人手中夺取的义体并战斗下去，反抗这个世道。</p><p>某种程度上说，赛博武学这条科技树的发展是“畸形”的——世界上存在那么多比“义体人打拳”更简单的军事技术，这个世界反而成为了武道的世界；极客文化明明与强调共享的开源精神相伴而生，但是提升到内功境界的黑客技术，反而将开源的精神消灭殆尽。但是，这种“畸形”正是义体化条件下反抗者与暴政者博弈的结果，是特殊时代下的特殊产物。</p><p><strong>铁华</strong></p><p>武学之中，存在许多造价非常低廉，但在战斗中异常好用的玩意。铁华就属于其中一种。</p><p>金属颗粒气溶胶一般是纳米级的金属颗粒与高压气体混合，并用特质的方式扩散。诨名“铁华”，也有叫“闪光尘”的，甚至还有人带着调侃的称呼它为“贤妻”。之所以称它“贤妻”，是因为这玩意妙用实在不少，实在是居家旅行、行侠仗义的必备物资。</p><p>首先，金属颗粒是良好导体。若是进入电路之中，极容易造成短路。把这东西往建筑的电力系统上扔，就可以瘫痪一片。其次，金属颗粒作为良好导体，可以在空气中形成类似于法拉第电笼的结构，可以用来抵御电磁脉冲武器。再者，金属颗粒的折射能力，也能有效的抵御激光武器。另外，与强助燃剂均匀混合后，它也可以在密闭空间里当做爆炸物使用。若是手上有适合的加热道具，也可以用它来修复外装甲上的小损伤。最重要的是，它很便宜。有些时候，它甚至被早期的侠客们当做烟幕弹来用。</p><p><strong>炸弹</strong></p><p>主要分为EMP炸弹和传统爆炸物。</p><p>“触发式地雷、定时炸弹、AI判定炸弹……总之，一切不需要额外指令就能在远处自动引爆的爆炸物，都是侠客的朋友。”这具名人名言，出自二百年前某位不愿透露性命的侠客。爆炸物是侠客的好伙伴，而能够在远处自己爆炸的爆炸物更是如此。</p><p>虽然传统爆炸物地雷爆炸的高温气体与冲击波，被赛博人的伤害被外装甲以及缓冲层极大的削减了，武林高手也可以靠超音速的身手闪过炸弹最强大的一波伤害，但是爆炸物在用来攻击一大群“武功稀松平常”的人时，可以造成很不错的效果。在远处爆炸的炸弹还可以吸引敌人的注意力，让敌人将兵力投放在没有目标的区域。另外，它也可以在必要时扭转“地利”。</p><p><strong>EMP</strong>炸弹对自然人几乎没有伤害，但是对没有好好做电磁防护的义体人一炸一个准。义体化较低的要防备心脏与肺腑被破坏至宕机，义体化高的，则要小心脆弱的芯片。尽管铁华之流可以在一定程度上抵御EMP，但是自脚下爆发的EMP地雷，根本不会给人释放铁华的时间，只能靠义体自身的电磁抗性硬抗过去。</p><p>这个时代的炸弹有可以用内功骇入的智能炸弹，也有很多拒绝外界操作的AI判定炸弹、定时爆炸的炸弹与压感地雷。对侠客来说，地雷不能布置在距离居民区三十公里以内的地方，哪怕是为了阻击官兵，也不能威胁到群众的安全。</p><p><strong>雷达</strong></p><p>雷达是赛博武者有别于自然人的多种感官之一。</p><p>针对雷达告警装置，有些武者会专门把自己雷达的信号进行伪装，从而让对方误判自己的距离和扫描模式。还有的武者在多人合作时，会分别携带雷达的发射器与接收器。又或者干脆把雷达装在无人机上，再通过数据链来进行不暴露自身位置的打击。</p><p>但是，既然反侦察的技术已经成体系了，自然有反其道而行之的体系，也就是故意向一名武者发射雷达波，让他产生“我被锁定了”的紧张感。</p><p>与赛博武术还没有成熟的时代不同，只是一瞬间的雷达扫描，就有可能回传有效信息，辅助武者进行判断。所以一束看似微弱的雷达波，都能让战斗中精神高度紧张、或者一些一直疑心病就很重的武者产生“这是高手故意伪装之后在试图锁定我”的下意识判断。据说老一辈的侠客里，有人提议管这个叫“杀气”。但是更多的人认为这个称呼意义不明，而且容易混淆‘雷达波’这个概念，所以没有流传下来。</p><p><strong>音响</strong></p><p>（写不动了）</p><h2 id="外门武学"><a href="#外门武学" class="headerlink" title="外门武学"></a>外门武学</h2><p>“外功”最重要的部分设计思路，便是“要求低”。就算是垃圾义体，也能打出一套外功来。有更好的高科技、强材料义体自然是更好，但没有的话也无所谓。只要外功武者可以保证“在局部战场上比来袭的敌人强”，就可以不断获取更好的零部件。</p><p>外功自然包含了一整套“从弱杀到强”的理论与方案。只要有人有进行游击战与持久战的决心、毅力，就可以直接拔剑而起，成为侠客。</p><p>用来优化武道算法的经验卷积替代了自然人的“肌肉记忆”，比“肌肉记忆”更加精准也更容易掌控。这东西是不需要经过生物脑的。所以侠客在赛博外门武学上的进境分为三个层面。一个，就是算法本身的演化——根据经验卷积，不断针对个人风格与偏好，修正算法的倾向。另外，是生物脑对“战术”的想象，是在“战术”层面上运用算法的能力。再一个，就是生物脑与算法相适应的程度。</p><p>外功的核心是将身体交给武道、将动作托付给算法。这些事情说起来简单，但很难做到。机器不理解什么叫“目的”，必须由人赋予机器。将算法下载下来，武者必须经过训练与实战，才能以自己的意识来驾驭武道，不断调整策略，做出抉择。</p><p>“外功”主要包括“搏击”与“枪炮”两类。</p><h3 id="机甲钢拳"><a href="#机甲钢拳" class="headerlink" title="机甲钢拳"></a><strong>机甲钢拳</strong></h3><p>是武道初祖与万机之父创造赛博武术时发明的第一门拳术，也是天下间流传最广的武术，在江湖中又被人称作“武祖长拳”。几乎是个武者就有渠道得到这一门拳法的武道算法。</p><p>机甲钢拳之所以被称为“诸拳之母”，是因为它排弃了人类在自然人时代千百年积累的标准，同时升华了众多格斗术的经验，创造了“最大限度发挥义体优势”的战术策略组。其他所有的赛博武术，都是根据这个思想演变而来的。“机甲钢拳”的算法，也已经包括了所有基本的武道策略组。高手能够从这算法的底层之中，拆解出武道之间博弈的智慧。一百多年来，也曾有武者就用机甲钢拳，打入残奥会的决赛圈。它是最早的武学，也经历了最多的版本更迭。按理来说，古老的技术都不会太强，但是机甲钢拳却汇聚了几百年来众多名家的经验卷积，确实非比寻常。</p><p>机甲钢拳虽然与侠义之道一起成型，但是机甲钢拳的雏形是在表演性质的运动会当中成型的。正是因为当初的拓世者们需要让民众都注意到义体改造，击败“对血肉身体的非理性重视”，宣扬“义体化胜于肉体”的策略，所以举行了很多表演性质的竞技活动。</p><p><strong>仿生拳法</strong></p><h3 id="枪炮道"><a href="#枪炮道" class="headerlink" title="枪炮道"></a><strong>枪炮道</strong></h3><p>枪炮道是一种专门强调驾驭热兵器的外门武学。虽然是一门非常实用的武学，但最初的武道家甚至想要将枪炮道从武道的底层设计剔除。因为子弹出膛的刹那便不受控制，武者对抗发展成“闪避”与“试探”的循环后，容易波及无关群众。</p><p>战术上，枪炮道以火力压制与狙击为主。“枪炮三才式”中的“迫”是所有枪炮道武功策略的基本模板，是以“落空”为前提，引导对手朝着“无法躲避的区间”前进的策略组。在开枪之前，枪炮道的武者就会经历许多轮复杂的侦查博弈。</p><p>值得一提的是，完全自动化的战斗机器人，基本以远程热武器为主流。只要一个大型机器人，搭载了足够猛的火力，形成密集的火力压制，那么仅仅是单纯的AI，就足以压制一大批外门武者。虽然AI的无法抵御内功。但是做好硬件层面的防护，就可以在一定程度上预防这种状况。</p><p>对于枪炮道来说，“距离”就是“优势”，但是距离与优势并总是呈正比。枪炮道武者应该歼敌于千丈之外，或者五步之外、百步之内。</p><p>在七公里到五公里的“极限距离”之下，枪炮道的优势无法估量；但四千米之后，枪炮道的武者会逐渐失去这个优势，因为此时高精度的义眼可以直接观察到他的枪口。子弹出膛到抵达目标，至少需要几秒钟的时间，足够赛博武者反应。</p><p>只有到了一百米之内，留给格斗武者的反应时间缩短到几近于无，枪炮道武者才会重新占有优势。之后，格斗技只能在一米的范围之内重新抢到“绝对优势”。</p><p>对于枪炮道来说，大气扰动会让子弹产生偏移，所以一般需要少量的无人机阵负责检测大气扰动，辅助射击。</p><p><strong>SSC三兵合一棍</strong></p><p><strong>四心刀术</strong></p><p><strong>卡拉什尼科夫流枪斗术</strong></p><p><strong>猛虎惊天枪术</strong></p><p><strong>磁力陷阱兵器</strong></p><p>最初的时候，“磁力陷阱”类奇门兵器来自于木星引力圈侠客的集体创造。但很快，就有侠客以这类奇门兵器为核心，开宗立派，以探讨“子午鸳鸯钺”“子母龙凤环”两种兵器的打法、战术。在与官府一代代的战斗中，侠客们开发出了“子午鸳鸯钺”“子母龙凤环”等带有“磁力陷阱”性质的奇门兵器，专打声子刀。</p><p>声子刀造价高昂，生产条件严苛，只有远日行星的侠客大后方有能力少量生产，官府使用的情况更多。在高品阶的冷血游骑之中，这东西甚至是可选制式装备之一。但侠客就算缴获了声子刀，也没法稳定的获取最重要的刀片。相比之下，“子午鸳鸯钺”“子母龙凤环”这类磁力陷阱奇门兵刃的造价就低廉很多。</p><p>所以这一门武学，就算官府学去了也无济于事。这是对侠客单方面有利的武功，某种意义上非常贴近武祖的思想。</p><p>值得一提的是，这类奇门兵器的基础是磁场，所以加入罡炁武学之后，可以生出种种不同的变化。志护法把子午鸳鸯钺开发出配合玄武真罡的用法，命名为玄武真罡·龙式。</p><p><strong>子午鸳鸯钺</strong></p><p>只要两把鸳鸯钺的连接绳撞在一起，那么它们就注定会缠上。赛博子午鸳鸯钺的克星，就是子午鸳鸯钺自身。</p><h3 id="玄武真罡"><a href="#玄武真罡" class="headerlink" title="玄武真罡"></a><strong>玄武真罡</strong></h3><p>玄武真罡是操控金属气溶胶的罡炁武学，是以寡击众的武功，为武祖向山发明，并与英格丽德·格拉纳特一起命名相关招式。它诞生的背景，是为了防御旧军队列装的，最适合对抗义体的电磁脉冲武器，与最强大的激光武器。“金属气溶胶排列组成镜面”的状态，保证了它可以有效的折射激光武器，被激光蒸发后，要补充的金属粉末也比补充外装甲反射涂层廉价很多。而“金属气溶胶组成法拉第笼”，也可以防御电磁脉冲(EMP)的攻击。最初玄武真罡存在的另一个意义，就是朝大型武器、一般军用义体的散热模块进气口里灌金属气溶胶，而不是像这个时代一样，先损坏敌人的外装甲，再用激波包裹湍流、湍流裹挟气溶胶送进那伤口。</p><p>在防御层面，四散的金属气溶胶可以吸引大多数地方的注意力，隐藏自己真正的位置；也能让敌人投鼠忌器，得避免误伤气溶胶中可能存在的友军，这就让侠客单人面对军队的时候，有了“不用担心狙击”的底气。在攻击层面，玄武真罡也可以做到“以最小成本解除敌人的战斗力”。玄武真罡还可以通过阻隔大部分侦查与通讯手段的金属气溶胶来切割战场，阻碍敌人的配合。这会进一步强化“精兵”的优势。没有被立即消耗掉的磁化金属颗粒，也可以被磁场回收，反复使用。“罡炁武学”可以在不提升义体载重量的前提下，提升侠客的续航能力，相当节约资源。</p><p>玄武真罡的缺点之一是，对“本地”计算力有很大的需求。玄武真罡完全发动之后，武者裹挟在一个金属气溶胶构成的法拉第笼中，电磁脉冲打不进来，但无线信号也一样。这个状态下的武者没法借助远程的计算资源。而且这个时代，气流的计算比侠义刚刚诞生的时代复杂很多，因为高手一动就超越音速。人形义体搅动大气，会形成些许超音速湍流，玄武真罡已经演化到连这些湍流都要利用的地步了。而湍流又是个混沌系统，求出它的“特殊解”，需要相当高的计算力。但武者却疯狂到用“指风”射出这种东西，然后还期望这样一股超音速湍流，可以射进狭小的缝隙之中，在敌人体内引发连锁反应。</p><p>如果没有太高的计算力，也可以用身周不断变化的磁场，快速磁化、偏折乃至俘获部分子弹。跟随本体移动的罡气团，也可以掩盖自己的身形，有效避免躲在暗中的狙击手。这会进一步强化“精兵”的优势。</p><p>玄武真罡的缺点之二是，不适合群体作战。金属气溶胶阻隔了绝大部分的指挥系统，甚至还会阻挡队友的视线。除非经过专门训练、使用特殊战术，否则玄武真罡的武者几乎无法与任何队友打配合。这一套功夫只适合独行的刺杀者。</p><p>玄武真罡对敌我的封锁都是相当的。它固然可以阻碍敌方视线，让敌方枪术难以发挥，但也会阻碍我方人员观察敌方枪手的动作，甚至会妨碍使用者躲子弹。</p><p>玄武真罡的第三个缺点是，在卫星看来非常醒目。在荒野中使用，容易被卫星锁定。</p><p><strong>玄武真罡·蛇式</strong></p><p>蛇式·现毒龙王（Taksaka）</p><p>人类对蛇类、甚至所有爬行类都有一种本能的恐惧。“现毒龙王”一定程度上就是利用了这一点。</p><p>义体加速之后，那些纳米金属颗粒就会因为阻力而落后与义体。但磁场赋予那些颗粒的动能，以及义体前进带出的涡流，都会让金属气溶胶被动的前进，跟随武者的步伐。在这个过程当中，金属气溶胶就会被拉长，形状如同蛇一般。甚至有一些小技巧，可以通过摆动手臂，微调身上的磁场，来改变磁场的分部，让蛇形的罡气团尖端形状改变，更接近毒蛇的三角形头部。武功越高的武者，越是能够克服对毒蛇</p><p>的恐惧本能，但对于高速交战的赛博武者来说，这一瞬的失神就足以让人失去性命，就好像直面了神话之中，以目视杀死牲畜的龙王德叉伽一样。</p><p>这类用法被某人戏称为“磁场三维拉花”。</p><p>蛇式·青莲华龙王（Utpalaka）</p><p>绵密的金属气溶胶朝着四面八方扑去，如同张牙舞爪的莲花怒放。</p><p>蛇式·大身龙王（Manasvati）</p><p>利用大块金属气溶胶团块移动。</p><p>蛇式·难陀龙王</p><p>蛇式·无热恼龙王</p><p>蛇式·宝称龙王(Vasuki)</p><p>这一招式用于偷袭。玄武真罡的武者会分出几道小的气溶胶湍流，去攻击敌人的散热口或装甲缺口，以期造成短路伤害。</p><p>只不过，湍流的计算依旧是一个难题，这种招式的命中一定程度上得靠玄学。为了提高命中率，一轮攻击得打好几次。所以当初就给了个“脑袋很多的龙王”的名字。（宝称龙王又名多头龙王、九头龙王，也称婆修竖龙王、筏苏枳龙王）</p><p><strong>玄武真罡·龙式</strong></p><p>六龙教护法志李激流开发出的武学，配合子午鸳鸯钺使出。在“睚眦”和“嘲风”上下过一番功夫，对“落入下风时如何变招”，亦有很深的理解。</p><p>龙式·睚眦</p><p>如双龙抢珠的凌厉攻击。这一招真正的奥义是“连消带打”，可以用两把磁力陷阱武器去锁一把声子刀的刀片。</p><p>龙式·蒲牢</p><p>龙式中，绝地反击的一招。两把鸳鸯钺在半空之中对撞，两团气溶胶化为一个扩散的“平面”，继而崩解成无数涡流，卷向敌人。</p><p>龙式·椒图</p><p>用两把鸳鸯钺“咬”向敌人。可以通过牵动鸳鸯钺的线，连消带打，化解攻势。</p><p>龙式·蚣蝮</p><p>神话之中，蚣蝮是龙而似龟，又有“脱去龟壳化为龙形”的说法。而玄武真罡·龙式中的“蚣蝮”，可以从“龟式”的大部分招数衔接而来，亦可以用来衔接龙式里攻中带守的招式。</p><p>龙式·饕餮</p><p>（收拢金属气溶胶。）</p><p>龙式·狻猊</p><p>狻猊在神话之中“喜烟好坐”的设定，在中原古代也多出现与香炉之上。</p><p>而玄武真罡·龙式之中的狻猊，也是通过绵密的攻击，来让金属气溶胶团块快速扩张。</p><p>龙式·嘲风</p><p>嘲风好险，形殿角上。在神话之中，嘲风是一种爱好冒险的龙子，因此中原大地的古人将之装饰在宫殿的殿角之上。</p><p>而玄武真罡·龙式中的“嘲风”也是一种冒险的招数。志护法开发出龙式·嘲风，本意是快速转移金属气溶胶团块的位置，以把控战场。同时，这一招还可以用金属气溶胶团块来掩盖鸳鸯钺的具体位置，让它更加难以躲闪。这一招会使得武者上半身维持一个“抛投”的姿势，并让鸳鸯钺带走相当一部分的金属气溶胶。这会让武者自身空门大开。</p><p><strong>玄武真罡·龟式</strong></p><p>龟式·玄龟吐真气</p><p>让金属气溶胶如水波一般扩散出去。</p><p>龟式·灵龟吸尽金乌血</p><p>用于重新收拢金属气溶胶。</p><p>龟式·养志法灵龟</p><p>在全身各处用金属气溶胶构建磁悬浮镜面，可以掩盖自身的架势。在龟式的诸多技巧之中，“养志法灵龟”甚至都不一定需要搭配金属气溶胶，几个变体可以直接当做格斗技巧来用，也很适合作为几种招式之间的衔接。</p><p>龟式·神龟虽寿</p><p>这是玄武真罡中，快速布置激光散射层的妙招。可以防御激光武器，甚至在防御的同时通过反射光破坏敌人的义眼。</p><p><strong>星屑旋转功</strong></p><p>与玄武真罡同为操控金属气溶胶的罡炁武学，由大卫·克莱恩所创。“星屑旋转功”更加偏重于超大范围的粗略控制，更适合对大规模敌人的应用，多用于正面战场的大规模交火，而玄武真罡则更加偏重与小股精锐敌人交手。这种策略组差异，源自于大卫与向山个人经历的不同。在早期刺杀当中，大卫时常担任正面的火力手，而向山则负责深入斩首。</p><p>据向山本人特地强调，星屑旋转功这一手掌握起来并不复杂。它所需要的计算资源也只有玄武真罡的十分之一左右，是一种更适合新手的罡炁武学。但是，想要在罡炁武学的道路上走得更远，从大卫的星屑旋转功转向他的玄武真罡是必然的。</p><p><strong>破械术</strong></p><p>一种需要巨量的工程学知识与维修经验才能施展的苛刻武学，可以通过定点的寸劲击打，让精密仪器失灵。可以精准的击破对方武器或义体的弱点，甚至通过劲力的传递，精确破坏某一个单独的零件，来达成连锁效果。</p><p>它的原理是，利用不同质量零件具有不同的惯性大小，通过瞬间加速让零件错位，人为制造错位或接触不良。它苛刻到要求一个武者必须依靠听觉与听劲就察觉机械运转、继而反推机械结构的地步，是一种性价比低到令人发指的武功。</p><p>二百年前也有谐音梗爱好者戏称为“破邪斩”。也有人将之戏称为“赛博分筋错骨手”。</p><p><strong>RX-天马</strong></p><p>“RX-天马”与神速王的‘变体月光蝶’是同源的武功，都可以追溯到武祖所创造的超高速斗法。</p><p>“RX-天马”体系包括了“彗星跑法”、“流星拳”、“回旋捶法”等，是速度致胜的武学。但是相对的，移动义体的能量，以及热力学第二定律所注定的额外发热，都是不可避免的。对“天马”的武者来说，能源与散热的压力会比同级的武者更大。所以，修习RX-天马的武者，就必须学会藏锋，不是时刻发挥速度优势，而是在平日利用速度锻炼出的神经反射，后发先至，始终保持能源在80%以上，始终留有余地。所以，如果在过高的速度下，神经反射没法完美掌控自己的架势，RX-天马流派的武者就不会轻易加速到这个程度。</p><h2 id="内家功法"><a href="#内家功法" class="headerlink" title="内家功法"></a>内家功法</h2><p>内家功法，是智能与人工智能相互提升之后的产物，在古老的时代被称作骇客技术。</p><p>侠客的“内功”，是基准人用生物脑直观地操纵代码与计算资源，不需要像旧时代原始的骇客一样，通过叫做“屏幕”的输出设备，使用叫做“键盘“的输入设备干涉代码的世界。从根源上看，内功是骇客技术的演化产物；但骇客技术和侠客内功之间的关系，就好像原始海洋之中的第一个单细胞生物，与后来的高等生物一样。内家功法的练习需要大量在计算机上模拟骇入和防守的训练，不断熟悉数学、编织算法。</p><p>赛博内功分为指令境、语言境、编译境、汇编境、机械境，以及传说之中的数学境和传说之上的图灵境。目前明确达到了图灵境的只有“图灵”祝心雨一人。</p><h3 id="叛客异色观"><a href="#叛客异色观" class="headerlink" title="叛客异色观"></a><strong>叛客异色观</strong></h3><h3 id="五停心观"><a href="#五停心观" class="headerlink" title="五停心观"></a><strong>五停心观</strong></h3><p>是一种基于认知科学的自检程序，题库大致可以分作测试本能好恶的“不净观”、测试社会人格的“慈悲观”、测试思考逻辑的“缘起观”、测试自我认知的“界分别观”和测试自我控制能力以及主观感知的“数息观”五类。预先将一些心理测试题目以特殊格式封装在一个程序里，程序会通过人脑与电子设备硬件层面的交互，绕过表层意识，直接对大脑提问。</p><p>从感觉上来看，这就好像有很多人同时问你无数个问题一样。很接近现代内功高手用以自娱的“垃圾信息”。而且与“垃圾信息”类似，这种信息也需要受试者压制自身的记忆机能，避免受试者记忆下题库，然后每次都回答一样的问题。</p><p>“五停心观”可以作为测试，而换一种存储格式之后，也可以作为引导阅读者发现自身心理问题的手段。</p><p>而这个时代的内功高手，在使用大剂量还丹酶修炼内功之后，都会辅以“五停心观”或类似的心理学程序进行自检。有些人还会设置“若是检查结果差距过大，则锁死义体乃至自毁”的程序。</p><h2 id="军武道"><a href="#军武道" class="headerlink" title="军武道"></a>军武道</h2><p>军武道专注于用高度特化的大型义体或机械进行攻击，以及多机体操控。军武道是高度专业化的功法，强调使用普通人接触不到的巨型武器（如大型机械、坦克、航母、宇宙战舰等），对应不同的载具类型与规格衍生出不同的军武道技术。</p><p>与普通语境下的“内功”“外门”相比，军武强调“特化的义体”而非“算法”。比如说“大舰巨炮”，便是针对各种战车，各种战机，各种军舰。而“军阵”基础就是海量的机械。对于微末之人而言，军武道毫无意义。从这个设计上来说，军武道比起用来“起义”，更适合用来“镇压起义”，而它也确实曾是世界的统治者为了应对侠客起义而创造的武学。</p><p><strong>大舰巨炮流</strong></p><p><strong>战车道</strong></p><p><strong>坦克道</strong></p><p><strong>军道战阵流</strong></p><p><strong>无人机</strong></p><p>在如今的“武术形式分类学”当中，“无人机驾驭”被认为是“战阵流派”军武道的基本功，基本相当于核心力量训练之于智人武术家。枪炮道的极限狙击非常依赖无人机；内功高手也可以依靠无人机延伸自己内功的作用范围，互相争夺无人机的控制权也是内功战的重要部分。即使是更加偏向外门的武者，无人机也可以开拓视野、消除死角，降低被袭杀的风险。它还被广泛用于收集情报与侦察，比如记录监控设备的位置等。</p><p>无人机相关的武功，虽然被分类为“军武”，但也是武祖创造的。从武祖的设计思路来看，无人机压根就不是军武。鉴于武祖特殊的历史地位，所以这一套不一定有助于新人理解武术的分类法，依旧被一些老派的江湖人秉持了下来。</p><p>但是归根到底，无人机对军武道战阵来说也是极其重要的组成部分。无人机可以作为超声波发射源与弹药运载工具，甚至作为“悬空地雷”游走，封锁敌人三维运动的空间。还可以在无人机上挂载绳索，思路近似于二战中的防空气球。</p><p><strong>云岚覆日·无人机阵</strong></p><p>“云岚覆日阵”是一整套无人机群的动态控制算法，它通过去中心化的算法，利用无人机自身的计算资源执行分布式计算，让无人机集群自动调整彼此之间的相对位置，以应对各种不同的任务，如侦测大气流动，辅助极限狙击等。这一战阵除了用无人机，还可以用坦克、战机乃至于人摆出来。</p><h1 id="三、角色"><a href="#三、角色" class="headerlink" title="三、角色"></a>三、角色</h1><h2 id="向山"><a href="#向山" class="headerlink" title="向山"></a>向山</h2><p><strong>1.</strong> <strong>角色类型</strong></p><p>主角</p><p><strong>2.</strong> <strong>称号</strong></p><p>武道初祖，向山难越</p><p><strong>3.</strong> <strong>首次登场事件</strong></p><p>第一章</p><p><strong>4.</strong> <strong>简介</strong></p><p>在未知年代以仅剩一个头颅的形态苏醒于回收站镇并被尤基捡到，有一个名为”约格”的大敌。失去了昔日所有的记忆，但仍能记得自己奉为准则的侠义之道。</p><p><strong>5.</strong> <strong>生平轶事</strong></p><p>在回收站镇将尤基收为徒弟，剿灭荒野中作恶多端的绿林寨子，刺杀松鹰城的诸多高层，营救老侠客陶恩海，找回第八武神的遗产，攻破悖论城营救第九武神，摧毁地球庇护者的卫星系统。</p><p><strong>6.</strong> <strong>人格覆面</strong></p><p>【ω Chorme】“最终的基础”生物脑自带的人格。</p><p>【β Crime】“贝塔之罪”第八武神的遗产，内功特化。</p><p>【φ Fever】“斐之狂热”第九武神AI转化而来，口才特化，军武道特化。</p><p><strong>7.</strong> <strong>找回的记忆</strong></p><p>2005年出生于北平，在2028年参与“奥贡”项目之前于清华大学攻读博士学位。在“奥贡”项目结识了约格莫夫，祝心雨，英格丽德，大卫·克莱恩，阿纳托利等一批年轻学者。在2035年为了击破笼罩在人类文明之上的亡灵而决定成为“盗火者”，本着“进入已经成熟的体系，从内部改变它”的思路，沿着资本主义世界的道路向上攀登，和“奥贡”项目内的好友们共同缔造“超人类主义国际企业”，并与伙伴掀起了技术革命，改变了整个世界的面貌。六十年代末，技术革命的果实被窃国之人所篡夺。向山转而抛弃了自己过去的理念，化身为游击队员，发动“秘密侠义战争”，以“侠客”的外壳汇聚全球反抗力量。22世纪初，向山与同伴斩杀窃国者，缴获了技术构成的“权力”。但旋即，向山遭到了背叛。紧接着，他在“升华战争”中败给了约格莫夫。叛徒以“庇护者”自居，统治者现在的世界。</p><p><strong>8.</strong> <strong>角色语录</strong></p><p>1）</p><p>这就存在大大的问题呀。贵族、封建主到资本家、官僚，大家脑袋上的猴王一直没有变过嘛。只不过资本家与官僚总归比地主强，所以我们都觉得，这是一种进步，而且这种进步会一直持续下去。路线错了而已。</p><p>2）</p><p>——我们来创造一种新的技术吧。把开放获取、去中心化生产结合起来，做出任何人拿到就可以使用的东西……</p><p>——我要称之为“武功”……</p><p>3）</p><p>那群裸猿也是“智人”。裸猿之中，固然有数不尽的痴愚昏聩。但智人一万年的路上，也不尽是痴愚，更有智慧火花，有真侠真义。</p><p>4）</p><p>——我们来清理祖先给我们的负面遗产！</p><p>——我们来断绝猴王降世的生理基础！</p><p>——让人类摆脱自身基因的奴役！让每一个人都有机会成为自己想要成为的“那个自己”！</p><p>——我们是盗取天火之人！</p><p>5）</p><p>过去的我早就做好准备了。那个我什么都知道。他就是我，我只比他少一点点记忆而已。那个我知道很多东西……他懂的比现在的我更多。而我们的情绪是一致的。所以，我相信过去的我做出的决定——我怎么能背叛过去那个什么都知道的我呢？</p><p>6）</p><p>用人类的心灵为机器标定目标，用机器的力量将人类送达目标，才是技术发展的正道。</p><p>7）</p><p>侠义不是‘正义’，侠义是一种被包装的暴力。侠义或许在大方向上，与人类直观所描述的‘正义’接近，但是却绝非形而上的正义。</p><p>8）</p><p>自己的命也是命，惜命，就是尊重生命的一种体现。也只有足够尊重生命的人，才能表现出‘比生命更可贵之物’的可贵。另外，暴政者的力量也是万倍于侠客的。若是不珍惜性命，必定是看不到胜利的。</p><p>9）</p><p>确实，民众有时会表现出狂热而愚昧的一面——他们又不是佛陀或者菩萨。但与此同时，他们在绝大多数时候都平稳地支撑着历史的进程。与其责怪他们狂热，倒不如先思考一下他们为什么会变得愚昧变得疯狂。</p><p>很早的时候，有人跟我讲解过这个道理。所以我很早就决定此生的事业了。我绝不会轻易的改变自己的理想。退一万步来讲，为了一小撮人渣就否定自己十多年的信仰，那才是愚蠢。</p><h2 id="祝心雨"><a href="#祝心雨" class="headerlink" title="祝心雨"></a>祝心雨</h2><p><strong>1.</strong>  <strong>称号</strong></p><p>祝融，图灵</p><p><strong>2.</strong>  <strong>身份背景</strong></p><p>在2013年出生于淮夷，父母幼年离婚，在青少年期就表现出了极高的数学与编程天赋，跟随黑客“火德星君”行动多年后分道扬镳。此后使用“祝融”这一黑客代号活动，盗窃机密信息，行使她所认定的正义。在2030年前后因盗窃“奥贡”项目的数据而被逮捕，因向山的担保而获得一定程度的自由，后和向山相爱并同居。</p><p><strong>3.</strong>  <strong>简介</strong></p><p>祝心雨是超人类主义公司的重要一员，“赛博内功”的发明者，是侠义之道的创始人之一。在黑客时期与哈特曼互有胜负，义体化后的内功天下第一，被尊称为凌驾于所有境界以上的“图灵”。</p><p><strong>4.</strong>  <strong>生平轶事</strong></p><p>在武祖败亡后，一手参与了第二武神的诞生，但最后因无法面对第二武神而出走。目前行踪不知，与弟子们被一支庇护者舰队锁定，困在木星某个卫星之中但尚且安全。与第八武神相识时并不承认“武神”，后因盗窃科研骑士团的数据失手而被哈特曼锁定，第八武神为掩护图灵而牺牲自己，此后祝心雨公开承认第八武神的武神身份。第八武神的所作所为使她对武神的看法有所改观。</p><h2 id="陶恩海"><a href="#陶恩海" class="headerlink" title="陶恩海"></a>陶恩海</h2><p><strong>1.</strong> <strong>称号</strong></p><p>杏林公</p><p><strong>2.</strong> <strong>身份背景</strong></p><p>21世纪中叶是地坛医院的一名神经外科医生，后因伤医事件伤到手部而无法再做手术。后加入超人类主义公司并治好了自己的双手。</p><p><strong>3.</strong> <strong>简介</strong></p><p>几百年来一直是侠义之道的忠实践行者。七十年前襄助第九武神杀上约格莫夫的太阳御座，得知了第九武神的真相。</p><p><strong>4.</strong> <strong>生平轶事</strong></p><p>为了将火星的先进技术带回地球而与“神速王”交手，感染了“伊沃路”细胞，造成了类似癌症的后果，功力全失。向山为其进行了脑部手术去除了感染伊沃路细胞的组织，陶恩海建议他前往悖论城。目前疑似于非洲大陆活动，谋夺一部宇宙电梯。</p><h2 id="贾德尔"><a href="#贾德尔" class="headerlink" title="贾德尔"></a>贾德尔</h2><p><strong>1.</strong> <strong>称号</strong></p><p>瞬间爆炸单杀王</p><p><strong>2.</strong> <strong>简介</strong></p><p>北地侠客门派“红石门”的一员，被庇护者暗算灭门后逃出，重伤后被师兄松岛宏所救。后遭遇主角，受其帮助功力恢复并有所精进。</p><p><strong>3.</strong> <strong>生平轶事</strong></p><p>目前组织了北地群侠协助主角的行动。</p><h2 id="松岛宏"><a href="#松岛宏" class="headerlink" title="松岛宏"></a>松岛宏</h2><p><strong>1.</strong> <strong>简介</strong></p><p>松鹰城铁块流道场的师范，德高望重。退役运动员,曾夺得残奥会冠军，外功高强。暗地里与图灵一脉弟子TX-0有密切合作。</p><p><strong>2.</strong> <strong>生平轶事</strong></p><p>曾与两个同门师弟一同观看了第九武神当年的直播，三人因此对侠义心生向往。后来两人投身江湖，松岛宏却为了守护师承兼“守望江湖”，选择继续做一位武馆师范。</p><p>松岛宏曾在松鹰城与合作伙伴TX-0合力盗窃过本地科研骑士团的一些机密资料。在向山的牵引下，加深了与江湖人士的往来。后被庇护者所逼迫，杀死庇护者后成为侠客，与向山一同行动。</p><h2 id="博尔术"><a href="#博尔术" class="headerlink" title="博尔术"></a>博尔术</h2><p><strong>1.</strong> <strong>称号</strong></p><p>条子侠，天速星</p><p><strong>2.</strong> <strong>简介</strong></p><p>“RX天马流”的传人，一身武功以速度为主，第四武神理念的追随者。误入黑店被绿林洗脑，但是一直在凭借自身的意志力对抗心中的杀欲。</p><p><strong>3.</strong> <strong>生平轶事</strong></p><p>一位女孩被他所救后一直称他为“大侠”，这个女孩也是他对抗绿林记忆的重要动力。为了救女孩的性命自愿被主角锁拿，最后做为“条子侠”而牺牲。博尔术的牺牲改变了主角对绿林的看法。</p><h2 id="尤基"><a href="#尤基" class="headerlink" title="尤基"></a>尤基</h2><p><strong>1.</strong> <strong>身份背景</strong></p><p>在回收站镇捡到了主角的生物脑的基准人少年，向山的入门弟子。</p><p><strong>2.</strong> <strong>简介</strong></p><p>跟随主角学习侠义之道与赛博武功，目前内功能力通过了主角的考核，有了能“睁眼看世界”而不被庇护者轻易黑入后门的力量。</p><h2 id="万机之父"><a href="#万机之父" class="headerlink" title="万机之父"></a>万机之父</h2><p><strong>1.</strong> <strong>真名</strong></p><p>约格莫夫·弗伊格特</p><p><strong>2.</strong> <strong>居住地</strong></p><p>目前作为人类最高领袖“万机之父”，居住于太阳附近的御座戴森云中。</p><p><strong>3.</strong> <strong>简介</strong></p><p>21世纪最伟大的生物学家，“开放获取运动”的支持者。和尼娅古蒂共同破解了外星微生物的秘密，破解了“酶改造系统”。完善了将智人改造为基准人的技术体系。</p><p><strong>4.</strong> <strong>生平轶事</strong></p><p>在升华战争之前一直是向山忠实的盟友，在“秘密战争”期间因为地球生物大灭绝，精神状态陷入极不稳定的状态，逐渐丧失了对人类文明的信任，在夺回了“技术”的大权后因此拒绝将其归还给人民，而与向山决裂，并在阿耆尼王哈特曼的帮助下击败了向山，夺去了其所有记忆并将一部分公开在网络上。</p><h2 id="阿耆尼王"><a href="#阿耆尼王" class="headerlink" title="阿耆尼王"></a>阿耆尼王</h2><p><strong>1.</strong> <strong>真名</strong></p><p>贾库布·哈特曼</p><p><strong>2.</strong> <strong>简介</strong></p><p>21世纪以“阿耆尼”为代号活动的超级黑客，有不正常的爱国热情，志愿为合众国效力。目前正作为人类诸王之首镇守月球，压制整个地月系的侠客力量。内功天下第二，是军武道·战舰阵的最强高手。</p><p><strong>3.</strong> <strong>生平轶事</strong></p><p>在“秘密战争”期间作为窃国者的走狗，而后反水脱离窃国者，“秘密战争”结束后又被约格莫夫拉拢成为手下，与其联手击败了向山。在“奥贡”项目期间协助抓获了祝心雨。率军歼灭了第四，第七，第八武神。阿耆尼王忽视太空城内平民直接炮击第四武神所在太空城这一事件，被认为是完全摧毁旧人类社会共同想象的决定性事件。</p><h2 id="神速王"><a href="#神速王" class="headerlink" title="神速王"></a>神速王</h2><p><strong>真名</strong></p><p>隼·弗伊格特</p><p><strong>身份背景</strong></p><p>“万机之父”约格莫夫的养子。从非洲的内乱小国被救出的娃娃兵，童年时在难民营遇到神原尊，神原尊为其取名为“隼”，来形容他的速度极快。</p><p><strong>简介</strong></p><p>庇护者诸王之一，武祖之后赛博外功天下第一，义体可加速到光速的16%。大部分时间坐镇于“神速王庭”，执行各类科研任务。也会作为一支超高速机动部队参与太阳系各处的镇压侠义活动。大脑经过深度改造后强度堪比皮球。</p><h2 id="第四武神"><a href="#第四武神" class="headerlink" title="第四武神"></a>第四武神</h2><p><strong>1.</strong> <strong>身份背景</strong></p><p>诞生于木星太空城，第一个真性人格覆面。</p><p><strong>2.</strong> <strong>生平轶事</strong></p><p>夺取了一座太空城，提出了“守法如法在”的理念，在网络上传播，按照战前的方式经营太空城，重塑了侠义精神在升华战争后的理念，被庇护者以超视距打击连同太空城一同毁灭。</p><h2 id="第八武神"><a href="#第八武神" class="headerlink" title="第八武神"></a>第八武神</h2><p><strong>1.</strong> <strong>身份背景</strong></p><p>德拉克鲁兹城某个科研骑士团收养的孤女。</p><p><strong>2.</strong> <strong>简介</strong></p><p>割舍了自我成为向山，深入研究了人格覆面技术，可以将生物脑通过手术改造而获得他人的意识。一直默默的在出生地活动，将城内所有黑帮都改造为了自己的分身，借此修炼出了一身顶级的内功。唯一被图灵承认的武神。</p><p><strong>3.</strong> <strong>生平轶事</strong></p><p>在网络上与祝心雨有一面之缘，互相交流内功思路，最后选择掩护祝心雨而暴露身份，被阿耆尼王锁定。死前将自己的意识备份在黑谷一脉的电脑中等待之后的向山来取得，将自己研究的内功托付给好友阿冬，这份功法之后辗转被向山得到。在城外被阿耆尼王的舰炮轰杀，死前留下了遗言“我会再回来的”。备份的人格覆面被主角获得，存在于主角脑中。</p><h2 id="第九武神"><a href="#第九武神" class="headerlink" title="第九武神"></a>第九武神</h2><p><strong>1.</strong> <strong>简介</strong></p><p>自我认知为火星一位摇滚歌手，在火星从事地下宣传活动多年，与陶恩海，佛洛伦斯汇合后开始大规模行动，在阵前令万军倒戈，被公认是感染力最强的武神。</p><p><strong>2.</strong> <strong>生平轶事</strong></p><p>召开了一场整个太阳系都能听到的演唱会，在侠义凋零的年代给众多人心里留下了一抹擦不去的光芒。组织了一支精锐侠客分队杀向太阳的戴森云，在约格莫夫的御座得知了一切的真相，此后一直被困在悖论城作为羞辱侠义精神的一个符号。被向山解救后击杀了悖论城几乎所有的高级武馆，并且突入阿耆尼王的天星舰队，击毁了众多舰艇，最后自爆而亡。人格覆面被转码后存在于主角脑中。</p><h2 id="第十武神"><a href="#第十武神" class="headerlink" title="第十武神"></a>第十武神</h2><p><strong>1.</strong> <strong>简介</strong></p><p>一位外功极强的武神，当前最高多段发力记录保持者，可做到“一千三百九十四叠浪”，诞生于外行星，曾经试图冲击过悖论城与地球，同时被阿耆尼王的内功压制与被神速王牵制，只能转道火星阻止火星军港的重建。被阿耆尼王击杀。</p><h2 id="征天王"><a href="#征天王" class="headerlink" title="征天王"></a>征天王</h2><p><strong>1.</strong> <strong>真名</strong></p><p>大卫·克莱恩</p><p><strong>2.</strong> <strong>简介</strong></p><p>NASA最顶尖的工程师，理想就是在宇宙中生活。</p><p><strong>3.</strong> <strong>生平轶事</strong></p><p>在主持建造并发射了人类第一座大型宇宙空间站“伽利略”后就遭遇了“窃国之实”，身份被夺取，转入地下进行秘密活动。作为侠客们的后勤整备力量，教会了向山很多的工程知识。</p><h2 id="陆轩宇"><a href="#陆轩宇" class="headerlink" title="陆轩宇"></a>陆轩宇</h2><p><strong>1.</strong> <strong>身份背景</strong></p><p>21世纪的一名中国习武之人，主要修习截拳道。</p><p><strong>2.</strong> <strong>简介</strong></p><p>因为见义勇为救下一名小女孩而被卡车碾过失去了下半身，从创伤中恢复后开始以自媒体的方式分享武道精神。</p><p><strong>3.</strong> <strong>生平轶事</strong></p><p>被向山选中进行基准人以及义体化改造，将在2047年左右参加超人类企业举办的“天下第一武道会”向全世界证明义体相较于肉体的优越性。在改造过程中与陈锋相识，与其相谈甚欢，对于现代社会中武道的存在形式有了更深的理解。</p><h1 id="四、编年史"><a href="#四、编年史" class="headerlink" title="四、编年史"></a>四、编年史</h1><h2 id="第一卷-独在异乡为异客"><a href="#第一卷-独在异乡为异客" class="headerlink" title="第一卷 独在异乡为异客"></a>第一卷 独在异乡为异客</h2><p>第一章-第四十章</p><p>回收站镇，撤销庇护</p><p>第四十一章-第七十九章</p><p>前往荒野，Z组织</p><h2 id="第二卷-真名实姓"><a href="#第二卷-真名实姓" class="headerlink" title="第二卷 真名实姓"></a>第二卷 真名实姓</h2><p>第一章-第四十三章</p><p>向奥贡进发，红石门</p><p>第四十四章-第七十九章</p><p>隐世门派，城市内乱</p><p>第八十章-第一百三十九章</p><p>美以美大楼，神秘的六龙教</p><h2 id="第三卷-谁悲失路之人"><a href="#第三卷-谁悲失路之人" class="headerlink" title="第三卷 谁悲失路之人"></a>第三卷 谁悲失路之人</h2><p>第一章-第五十章</p><p>老侠客的逃亡，超人类主义股份有限公司</p><p>第五十一章-第一百零九章</p><p>第八武神，钻地龙</p><p>第一百一十章-第一百三十六章</p><p>第八武神的遗产，回家</p><h2 id="第四卷-真·武神转生"><a href="#第四卷-真·武神转生" class="headerlink" title="第四卷 真·武神转生"></a>第四卷 真·武神转生</h2><p>第一章-第五十一章</p><p>泄密事件，武神们的故事</p><p>第五十二章-第八十八章</p><p>图灵一脉，考试</p><p>第八十九章-第一百二十七章</p><p>向山的策略，幽鹤骑士团</p><p>第一百二十八章-第一百五十九章</p><p>得到制冷设备，天机的故事</p><p>第一百六十章-第二百十二章</p><p>对付六龙教，幽鹤城</p><p>第二百二十三章-第二百八十五章</p><p>物种更改，基因改造手术</p><p>第二百八十六章-第三百二十四章</p><p>目标松鹰城，回收站镇的屠杀</p><p>第三百二十五章-第三百八十九章</p><p>发生暴乱，攻打悖论城</p>]]></content>
    
    
    <categories>
      
      <category>小说</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>树和森林</title>
    <link href="/2024/03/29/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/"/>
    <url>/2024/03/29/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/</url>
    
    <content type="html"><![CDATA[<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树是有序树，注意，度为二的有序树和二叉树是有区别的，度为二的有序树是家里真的有两个孩子，二叉树是开放二孩政策但是你生不生看你自己，度为二的有序树未必就是二叉树，万一人家是三叉树让生三个但就生了俩呢？</p><h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p>高度为h且含有2^h-1个结点的二叉树，理想条件了属于是</p><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>当且仅当每个结点都与高度为h的满二叉树中编号1~n的结点一一对应时，称为完全二叉树</p><p>编制是满的，但是人还没满也可以，但是完全二叉树只能去掉较大的结点，否则中间抽一个去掉的话会造成编号无法对应</p><h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><ol><li>只有最后两层可能有叶子结点</li><li>最多只有一个度为1的结点</li><li>i&lt;&#x3D;[n&#x2F;2]为分支结点，i&gt;[n&#x2F;2]是叶子结点</li><li>如果某一个结点有一个孩子的话，那这一定是左孩子，否则不构成完全二叉树了</li></ol><h4 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h4><p>一棵二叉树或者是空二叉树，或是具有如下性质的二叉树：</p><ul><li><strong>左子树</strong>上的所有结点的关键字都<strong>小于</strong>根结点的关键字</li><li><strong>右子树</strong>上所有结点的关键字都<strong>大于</strong>根结点的关键字</li><li>左子树和右子树单独拿出来又是一棵二叉排序树</li></ul><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>树上任一左子树和右子树的深度之差不超过1</p><ul><li>平衡二叉树有更高的搜索效率</li></ul><h4 id="常见考点"><a href="#常见考点" class="headerlink" title="常见考点"></a>常见考点</h4><h5 id="二叉树的常考性质"><a href="#二叉树的常考性质" class="headerlink" title="二叉树的常考性质"></a>二叉树的常考性质</h5><ul><li><strong>叶子结点比二分支结点多一个</strong></li></ul><p>​设非空二叉树中度为0，1，和2的结点分别为n0,n1,n2,则&#x3D;&#x3D;$n_0&#x3D;n_2+1$&#x3D;&#x3D;,树中总结点为n，则</p><p>​$n&#x3D;n_0+n_1+n_2$</p><p>​$n&#x3D;n_1+2n_2+1$</p><ul><li><p>**二叉树第$i$层至多有$2^{i-1}$个结点$(i\ge1)$ **</p><p>m叉树第$i$层至多有$m^{i-1}$个结点$$(i\ge1)$$ </p></li><li><p><strong>高度为h的二叉树至多有$2^h-1$个结点（满二叉树）</strong></p><p>高度为$h$的$m$叉树至多有$\frac{m^h-1}{m-1}$个结点</p></li></ul><h5 id="完全二叉树的常考性质"><a href="#完全二叉树的常考性质" class="headerlink" title="完全二叉树的常考性质"></a>完全二叉树的常考性质</h5><ul><li>具有$n$个结点的完全二叉树的高度$h$为$log_2n+1$ $(n&gt;0)$ 或</li><li>对于完全二叉树，可以由结点总数n推出度为0、1和2的结点个数为n0、n1和n2<ul><li>完全二叉树最多只可能有一个度为1的结点，则&#x3D;&#x3D;n1&#x3D;0或1&#x3D;&#x3D;<ul><li>若完全二叉树有2k个结点，则n1&#x3D;1,n0&#x3D;k,n2&#x3D;k-1</li><li>若完全二叉树有2k-1个结点，则n1&#x3D;0,n0&#x3D;k,n2&#x3D;k-1</li></ul></li></ul></li></ul><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><h5 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 100</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span>&#123;<br>    ElemType value; <span class="hljs-comment">//结点中的数据元素</span><br>    <span class="hljs-type">bool</span> isEmpty; <span class="hljs-comment">//结点是否为空</span><br>&#125;;<br><span class="hljs-comment">// 可以从数组的t[1]开始存储而把0位空下来，正好可以和树结点的编号一一对应</span><br></code></pre></td></tr></table></figure><p><strong>几个常考的基本操作</strong></p><ul><li>i的左孩子 ——2i</li><li>i的右孩子 ——2i+1</li><li>i的父结点 ——2&#x2F;i</li><li>i所在的层次$log_2n+1$</li></ul><p><strong>完全二叉树中共有n个结点，则</strong></p><ul><li>判断i是否有左孩子 ——2i&lt;&#x3D;n</li><li>判断i是否有右孩子 ——2i+1&lt;&#x3D;n</li><li>判断i是否是叶子&#x2F;分支结点 ——i&gt;n&#x2F;2</li></ul><p>但是普通二叉树是不能用这种方式来判断关系的，因此在普通二叉树的存储中，一定要将二叉树的结点编号和完全二叉树一一对应起来</p><p>但是无法通过完全二叉树的数学关系来判断它是否有左孩子，还需要用isEmpty来判断</p><p>最坏情况: 高度为h且只有h个结点的单支树也至少需要2^h-1个存储单元</p><p>因此可见，二叉树的顺序存储结构只适合存储完全二叉树</p><h5 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span>&#123;<br>    ElemType data; <span class="hljs-comment">//数据域</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span> *lchild,*rchild; <span class="hljs-comment">//左孩子，右孩子指针,如果一边没有就将其设为NULL</span><br>&#125;BiTNode,*BiTree;<br></code></pre></td></tr></table></figure><p>n个结点的二叉链表有n+1个空链域</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 定义一棵空树</span><br>BiTree root=<span class="hljs-literal">NULL</span><br><span class="hljs-comment">// 插入根结点</span><br>root=(BiTree) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BiTNode));<br>root-&gt;data=&#123;<span class="hljs-number">1</span>&#125;;<br>root-&gt;lchild=<span class="hljs-literal">NULL</span>;<br>root-&gt;rchild=<span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>使用此数据结构的话找一个结点的左孩子和右孩子比较简单，但是找父结点就只能从根结点开始遍历，因此可以根据实际使用需要，在创建的时候定义一个*parent指针指向父结点</p><h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h4><p>哈夫曼树一定是完全二叉树</p><h4 id="WPL"><a href="#WPL" class="headerlink" title="WPL"></a>WPL</h4><p>所有非叶结点的和</p><h3 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h3><h4 id="二叉树的前中后序遍历"><a href="#二叉树的前中后序遍历" class="headerlink" title="二叉树的前中后序遍历"></a>二叉树的前中后序遍历</h4><p>前序遍历：根左右</p><p>中序遍历：左根右</p><p>后序遍历：左右根</p><h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Level0rder</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    LinkQueue Q;<br>    <span class="hljs-built_in">InitQueue</span>(Q);<span class="hljs-comment">//初始化辅助队列</span><br>    BiTree p;<br>    <span class="hljs-built_in">EnQueue</span>(Q,T);<span class="hljs-comment">//将根结点入队</span><br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">IsEmpty</span>(Q))&#123;<span class="hljs-comment">//队列不空则循环</span><br>        <span class="hljs-built_in">DeQueue</span>(Q,p);<span class="hljs-comment">//队头结点出队</span><br>        <span class="hljs-built_in">Visit</span>(p);<span class="hljs-comment">//访问出队结点</span><br>        <span class="hljs-keyword">if</span>(p-&gt;lchild!=<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-built_in">EnQueue</span>(Q,p-&gt;lchild);<span class="hljs-comment">//左孩子入队</span><br>        <span class="hljs-keyword">if</span>(p-&gt;rchild!=<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-built_in">EnQueue</span>(Q,p-&gt;rchild);<span class="hljs-comment">//右孩子入队</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="由遍历序列构造二叉树"><a href="#由遍历序列构造二叉树" class="headerlink" title="由遍历序列构造二叉树"></a>由遍历序列构造二叉树</h4><h5 id="不同二叉树的序遍历序列"><a href="#不同二叉树的序遍历序列" class="headerlink" title="不同二叉树的序遍历序列"></a>不同二叉树的序遍历序列</h5><p>一个二叉树对应一个中序遍历序列，但是一个中序遍历序列并不对应一个特定的二叉树，只有</p><ul><li>前序+中序 </li><li>后序+中序</li><li>层序+中序</li></ul><p>才可以构建一个确定的二叉序列</p><h4 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h4><p>注意，树的前驱和后继与遍历序列的前驱和后继不是一个东西，无法从一个指定结点开始中序遍历，要找到指定结点在遍历序列中的前驱，只能从根结点开始遍历</p><p>对n个结点的二叉树来说有n+1个空链域，空链域指向他们的前驱和后继，没有前驱可以指向NULL。</p><p>如果一个结点的指针指向它们的前驱和后继而不是左孩子和右孩子的化，我们将这种指针称之为线索，前驱线索和后续线索。</p><p>二叉树线索化之后找结点的前驱和后继变得更方便，遍历也变得更方便</p><h5 id="线索二叉树的存储结构"><a href="#线索二叉树的存储结构" class="headerlink" title="线索二叉树的存储结构"></a>线索二叉树的存储结构</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span>&#123;<br>    ElemType data; <span class="hljs-comment">//数据域</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span> *lchild,*rchild; <br>    <span class="hljs-type">int</span> ltag,rtag;<span class="hljs-comment">//左右线索标志</span><br>    <span class="hljs-comment">// tag==0时，表示指针指向孩子</span><br>    <span class="hljs-comment">// tag==1时，表示指针是线索</span><br>&#125;ThreadNode,*ThreadTree;<br></code></pre></td></tr></table></figure><p>二叉树也可以称之为二叉链表，线索二叉树可以称为线索链表</p><p>中序前驱，中序后继，即按照中序遍历后的前驱</p><h4 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h4><h5 id="树的逻辑结构"><a href="#树的逻辑结构" class="headerlink" title="树的逻辑结构"></a>树的逻辑结构</h5><p>树是一种递归定义的数据结构</p><h5 id="双亲表示法（顺序存储）"><a href="#双亲表示法（顺序存储）" class="headerlink" title="双亲表示法（顺序存储）"></a>双亲表示法（顺序存储）</h5><p>既可以用来存储树，又可以用来存储森林</p><p>找一个结点的父结点很简单</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    ElemType data;<span class="hljs-comment">//数据元素</span><br>    <span class="hljs-type">int</span> parent;<span class="hljs-comment">//双亲位置域</span><br>&#125;PTNode;<br></code></pre></td></tr></table></figure><p>找孩子不方便，只能从头到尾遍历整个数组</p><p><strong>适用于“找父亲”多，“找孩子”少的应用场景，比如：并查集</strong></p><h5 id="孩子表示法（顺序-链式存储）"><a href="#孩子表示法（顺序-链式存储）" class="headerlink" title="孩子表示法（顺序+链式存储）"></a>孩子表示法（顺序+链式存储）</h5><p>把一个结点的孩子指针都存储在根结点中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CTNode</span>&#123;<br>    <span class="hljs-type">int</span> child;<span class="hljs-comment">//孩子结点在数组中的位置</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CTNode</span> *next;<span class="hljs-comment">//下一个孩子</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    ElemType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CTNode</span> *firstChild;<span class="hljs-comment">//第一个孩子</span><br>&#125; CTBox;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    CTBox nodes[MAX_TREE_SIZE];<br>    <span class="hljs-type">int</span> n,r;<span class="hljs-comment">//结点数和根的位置</span><br>&#125; CTree;<br></code></pre></td></tr></table></figure><p>找孩子很方便，找双亲结点不方便，只能遍历每个链表</p><p>适用于找孩子多，找父亲少的应用场景，如：服务流程树</p><p>比如客服系统，从拨通电话到数字选择服务，一切都是在找孩子</p><h5 id="孩子兄弟表示法（链式存储）"><a href="#孩子兄弟表示法（链式存储）" class="headerlink" title="孩子兄弟表示法（链式存储）"></a>孩子兄弟表示法（链式存储）</h5><p>使用孩子兄弟表示法存储的树与二叉树类似，采用二叉链表实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CSNode</span>&#123;<br>    ElemType data;<span class="hljs-comment">//数据域</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CSNode</span> *firstchild,*nextsibling;<span class="hljs-comment">//第一个孩子和右兄弟指针</span><br>&#125;CSNode,*CSTree;<br></code></pre></td></tr></table></figure><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><ul><li>左子树大小小于根结点的大小，右子树的大小大于根结点的大小</li><li>二叉搜索树中不存在重复的结点值</li></ul><p>二叉搜索树的性能在某些特定情况下可能会退化为链表，导致其操作的时间复杂度变为O(n)，而不再是理想情况下的O(log n)。为了解决这个问题，还产生了平衡二叉树（AVL树、红黑树）等数据结构，通过限制树的高度差或引入平衡因子等机制来保持树的平衡性，进而提升了操作的平衡性。</p><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>常考考点为B树的性质和B树的增删改查</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>梗整理</title>
    <link href="/2024/03/29/%E6%A2%97/"/>
    <url>/2024/03/29/%E6%A2%97/</url>
    
    <content type="html"><![CDATA[<h3 id="猿迟我悔"><a href="#猿迟我悔" class="headerlink" title="猿迟我悔"></a>猿迟我悔</h3><blockquote><p>团藏：“日斩你会后悔的！”</p><p>猿飞：“够了，团藏，我才是火影！”</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>梗</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>查找</title>
    <link href="/2024/03/29/%E6%9F%A5%E6%89%BE/"/>
    <url>/2024/03/29/%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>在数据集合中寻找满足某种条件的数据元素的过程</p><h4 id="查找表（查找结构）"><a href="#查找表（查找结构）" class="headerlink" title="查找表（查找结构）"></a>查找表（查找结构）</h4><p>用于查找的数据集合称为查找表，由同一类型的数据元素（或记录）组成</p><p>可以是线性结构，树形结构或图状结构</p><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p>数据元素中<strong>唯一</strong>标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的</p><p>如每个人的学号</p><h5 id="静态查找表"><a href="#静态查找表" class="headerlink" title="静态查找表"></a>静态查找表</h5><p>仅关注查找速度</p><h5 id="动态查找表"><a href="#动态查找表" class="headerlink" title="动态查找表"></a>动态查找表</h5><p>除了查找速度，也要关注插&#x2F;删操作是否方便实现</p><h4 id="ASL"><a href="#ASL" class="headerlink" title="ASL"></a>ASL</h4><p>平均查找长度——所有查找过程中进行关键字的比较次数的平均值<br>$$<br>ASL&#x3D;\sum_{i&#x3D;1}^{n}P_iC_i<br>$$</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谜语</title>
    <link href="/2024/03/29/%E8%B0%9C%E8%AF%AD/"/>
    <url>/2024/03/29/%E8%B0%9C%E8%AF%AD/</url>
    
    <content type="html"><![CDATA[<p>2021&#x2F;3&#x2F;5</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>html基础</title>
    <link href="/2024/03/29/html%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/03/29/html%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="前端三剑客："><a href="#前端三剑客：" class="headerlink" title="前端三剑客："></a>前端三剑客：</h3><ul><li>HTML：负责网页的架构</li><li>CSS：负责网页的样式，美化</li><li>JavaScript：负责网页的行为</li></ul><h3 id="什么是HTML"><a href="#什么是HTML" class="headerlink" title="什么是HTML"></a>什么是HTML</h3><p>HTML是超文本标记语言（Hyper Text Markup Language），是用来描述网页的一种语言。</p><p>简单来说，HTML文件也可以直接称为网页，浏览器的作用就是读取HTML文件，并且以网页的形式去展示它们</p><h3 id="标签介绍"><a href="#标签介绍" class="headerlink" title="标签介绍"></a>标签介绍</h3><p>HTML标签是由尖括号包围起来的关键词，如<code>&lt;html&gt;&lt;/html&gt;</code>。</p><h4 id="单标签与双标签"><a href="#单标签与双标签" class="headerlink" title="单标签与双标签"></a>单标签与双标签</h4><ul><li>双标签书写规则：&lt;双标签名称&gt;内容&lt;&#x2F;双标签名称&gt;，例如<code>&lt;html&gt;</code>内容<code>&lt;/html&gt;</code>;</li><li>单标签书写规则：&lt;单标签名称&#x2F;&gt;，例如<code>&lt;br/&gt;</code>。</li></ul><h3 id="HTML属性"><a href="#HTML属性" class="headerlink" title="HTML属性"></a>HTML属性</h3><p>HTML属性是指标签属性，HTML标签可以拥有属性，给相关的HTML元素提供更多的信息。</p><ul><li>一个HTML标签可以有多个属性</li><li>属性写在HTML元素的开始标签</li><li>属性总是以名称&#x2F;键值对的形式出现，如<code>class=&quot;method&quot;</code></li></ul><h3 id="HTML标签骨架"><a href="#HTML标签骨架" class="headerlink" title="HTML标签骨架"></a>HTML标签骨架</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initialscale=1.0&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>&lt;!DOCTYPE hmtl&gt;</code>: 向浏览器声明当前的文档是html</p><p><code>&lt;html&gt;&lt;/html&gt;</code>: 是网页当中最大的标签，称为根标签</p><p><code>&lt;head&gt;&lt;/head&gt;</code>: 为网页的头部，它里面的内容主要用来定义网页标签及给浏览器看的信息</p><p><code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>: 定义网页的编码为UTF-8</p><p><code>&lt;title&gt;&lt;/title&gt;</code>：为网页标题标签，它的内容会出现在浏览器的标签页上</p><p><code>&lt;body&gt;&lt;/body&gt;</code>: 为网页主体标签，它里面的内容会显示在浏览器的白色窗口区域</p><h3 id="基本的HTML标签"><a href="#基本的HTML标签" class="headerlink" title="基本的HTML标签"></a>基本的HTML标签</h3><h4 id="HTML标题标签"><a href="#HTML标题标签" class="headerlink" title="HTML标题标签"></a>HTML标题标签</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;h1&gt;一号标题&lt;/h1&gt;<br>&lt;h2&gt;二号标题&lt;/h2&gt;<br>&lt;h3&gt;三号标题&lt;/h3&gt;<br>&lt;h4&gt;四号标题&lt;/h4&gt;<br>&lt;h5&gt;五号标题&lt;/h5&gt;<br>&lt;h6&gt;六号标题&lt;/h6&gt;<br>没有&lt;h7&gt;&lt;/h7&gt;标签<br></code></pre></td></tr></table></figure><h4 id="换行与空格"><a href="#换行与空格" class="headerlink" title="换行与空格"></a>换行与空格</h4><h5 id="nbsp表示一个空格"><a href="#nbsp表示一个空格" class="headerlink" title="&amp;nbsp表示一个空格"></a>&amp;nbsp表示一个空格</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">hello<span class="hljs-symbol">&amp;nbsp;</span>world<br></code></pre></td></tr></table></figure><h5 id="表示换行"><a href="#表示换行" class="headerlink" title="&lt;/br&gt;表示换行"></a><code>&lt;/br&gt;</code>表示换行</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">hello<br><span class="hljs-tag">&lt;/<span class="hljs-name">br</span>&gt;</span><br>world<br></code></pre></td></tr></table></figure><p>另外<code>&lt;br&gt;,&lt;br/&gt;,&lt;br &gt;</code>浏览器都能识别出来</p><h4 id="HTML段落"><a href="#HTML段落" class="headerlink" title="HTML段落"></a>HTML段落</h4><h5 id="段落标签介绍"><a href="#段落标签介绍" class="headerlink" title="段落标签介绍"></a>段落标签介绍</h5><p>通过<code>&lt;p&gt;&lt;/p&gt;</code>标签进行定义</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>今日学习内容<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>学了标题标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>p标签的文字显示外观和普通文字没有区别，但是它独占一行</li><li>标签语义化，便于定位</li></ul><h5 id="标签语义化"><a href="#标签语义化" class="headerlink" title="标签语义化"></a>标签语义化</h5><p>浏览器解析到<code>&lt;h1&gt;</code>的时候，会认为是网页最重要的标题而不是一个普通文本，这种就是标签语义化</p><h4 id="字体加粗，倾斜，删除效果"><a href="#字体加粗，倾斜，删除效果" class="headerlink" title="字体加粗，倾斜，删除效果"></a>字体加粗，倾斜，删除效果</h4><h5 id="字体加粗"><a href="#字体加粗" class="headerlink" title="字体加粗"></a>字体加粗</h5><ul><li><code>&lt;b&gt;&lt;/b&gt;</code> 是简单加粗标签</li><li><code>&lt;strong&gt;&lt;/strong&gt;</code> 加粗效果+特别强调效果</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">普通文字<br><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>我是加粗文字1<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>我是加粗文字2<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="倾斜"><a href="#倾斜" class="headerlink" title="倾斜"></a>倾斜</h5><ul><li><code>&lt;i&gt;&lt;/i&gt;</code> 为倾斜标签</li><li><code>&lt;em&gt;&lt;/em&gt;</code> 为倾斜效果+特别强调效果</li></ul><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><ul><li><code>&lt;s&gt;&lt;/s&gt;</code> 删除效果</li><li><code>&lt;del&gt;&lt;/del&gt;</code> 删除效果（这两个标签没有任何语义区别）</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">原价:<span class="hljs-tag">&lt;<span class="hljs-name">s</span>&gt;</span>998<span class="hljs-tag">&lt;/<span class="hljs-name">s</span>&gt;</span><br>现价:9.98<br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>原价:<span class="hljs-tag">&lt;<span class="hljs-name">del</span>&gt;</span>999<span class="hljs-tag">&lt;/<span class="hljs-name">del</span>&gt;</span><br>现价:9.98<br></code></pre></td></tr></table></figure><h4 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">scr</span>=<span class="hljs-string">&quot;资源.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;图片没有正常加载时显示此内容&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;500&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;500&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;鼠标悬停在图片上的提示文字&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h4><h5 id="超链接使用"><a href="#超链接使用" class="headerlink" title="超链接使用"></a>超链接使用</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;跳转的网址&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>target=&quot;_blank&quot; 在其它窗口中打开链接<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://homovexillues.github.io&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span>点击我可以打开红石门的网站<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="空链接"><a href="#空链接" class="headerlink" title="空链接"></a>空链接</h5><p>在href中指定为#即可</p><ul><li>暂时不知道点击之后跳转到哪里，使用空链接占位</li><li>刷新界面</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>有序列表和无序列表</p><h5 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>python<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Java<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>go<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>ul标签可以嵌套若干个li标签</li><li>每一个li标签可以代表每一条数据</li><li>每个li标签之间没有顺序</li><li>（这就是一个无序列表）</li></ul><h5 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>第一条<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>第二条<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>第三条<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li>有序</li><li>而且是用ol开始的</li></ol><h4 id="布局标签"><a href="#布局标签" class="headerlink" title="布局标签"></a>布局标签</h4><h5 id="布局标签的介绍"><a href="#布局标签的介绍" class="headerlink" title="布局标签的介绍"></a>布局标签的介绍</h5><p>布局标签没有任何语义，也没有所谓的应用场景，作用是划分页面区域，辅助页面布局</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    大盒子，独占一行<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>小盒子，一行可以放多个<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h4><h5 id="表格标签的介绍"><a href="#表格标签的介绍" class="headerlink" title="表格标签的介绍"></a>表格标签的介绍</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>列表1<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>列表2<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>行1，列1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>行1，列2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>行2，列1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>行2，列2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>tr: table row的缩写，表示表格的一行</li><li>td: table data的缩写，表示表格的数据单元格</li><li>th: th是table header的缩写，表示表格的表头单元格</li></ul><h5 id="表格标签的其他属性"><a href="#表格标签的其他属性" class="headerlink" title="表格标签的其他属性"></a>表格标签的其他属性</h5><ol><li>align: 表格对其的方式，如<code>left center right</code></li><li>border: 表格边框，如1</li><li>cellpadding: 单元边沿与其内容之间的空白，默认1像素</li><li>cellspacing: 单元格与单元格之间的空白，默认2像素</li><li>width: 设置表格宽度</li><li>上述内容要写在table标签里</li></ol><h5 id="表格结构标签"><a href="#表格结构标签" class="headerlink" title="表格结构标签"></a>表格结构标签</h5><ol><li>表头部分区域<code>&lt;thead&gt;</code></li><li>表格主体区域<code>&lt;tbody&gt;</code></li></ol><table>    <thead>        <tr>            <th>列表1</th>            <th>列表2</th>        </tr>    </thead>    <tbody>        <tr>            <td>数据1</td>            <td>数据2</td>        </tr>    </tbody></table><h5 id="合并单元格"><a href="#合并单元格" class="headerlink" title="合并单元格"></a>合并单元格</h5><p>跨行合并：rowspan&#x3D;”合并单元格个数”</p><p>跨列合并：colspan&#x3D;”合并单元格的个数”</p><h4 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h4><h5 id="表单标签的介绍"><a href="#表单标签的介绍" class="headerlink" title="表单标签的介绍"></a>表单标签的介绍</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;把表单数据交给指定后台程序去处理&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;传递数据时方式方法，默认为POST&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p>例:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;xx.py&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="输入框与单选多选框"><a href="#输入框与单选多选框" class="headerlink" title="输入框与单选多选框"></a>输入框与单选多选框</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 选择信息: 选择 性别 爱好 --&gt;</span><br><span class="hljs-comment">&lt;!-- 单选按钮--&gt;</span><br><span class="hljs-comment">&lt;!-- 一组按钮: 他们俩都是来控制性别的，添加name属性--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>性别: <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 多选按钮 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>兴趣爱好: <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-comment">&lt;!-- &lt;input type=&quot;checkbox&quot;&gt;睡觉</span><br><span class="hljs-comment">&lt;input type=&quot;checkbox&quot;&gt;打游戏</span><br><span class="hljs-comment">&lt;input type=&quot;checkbox&quot;&gt;羽毛球 --&gt;</span><br><span class="hljs-comment">&lt;!-- 优化:点击文字也可以选中多选框--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sleep&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;sleep&quot;</span>&gt;</span>睡觉<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;playgame&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;playgame&quot;</span>&gt;</span>打游戏<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;yumaoqiu&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;yumaoqiu&quot;</span>&gt;</span>羽毛球<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="下拉框"><a href="#下拉框" class="headerlink" title="下拉框"></a>下拉框</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>北京<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>上海<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>广州<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">selected</span>=<span class="hljs-string">&quot;selected&quot;</span>&gt;</span>深圳<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="文本域"><a href="#文本域" class="headerlink" title="文本域"></a>文本域</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;30&quot;</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;10&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>cols：列</li><li>rows：行</li></ul><h5 id="按钮标签"><a href="#按钮标签" class="headerlink" title="按钮标签"></a>按钮标签</h5><ul><li>普通按钮</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;按钮&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>重置按钮</li></ul><p>点击会将数据恢复到默认状态</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;reset&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;重置按钮&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>提交按钮</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;我是提交&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="代码模块"><a href="#代码模块" class="headerlink" title="代码模块"></a>代码模块</h4><h3 id="CSS基础选择器"><a href="#CSS基础选择器" class="headerlink" title="CSS基础选择器"></a>CSS基础选择器</h3><p>CSS（Cascading Style Sheets）层叠样式表（级联样式表、样式表），CSS也是一种标记语言</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li>设置HTML页面中文本内容</li><li>图片的外形</li><li>版面的布局和外观显示样式</li></ul><h4 id="CSS基础语法"><a href="#CSS基础语法" class="headerlink" title="CSS基础语法"></a>CSS基础语法</h4><p>CSS规则由两个主要部分组成：选择器以及一条或多条声明，如：选择器{属性名 1：属性值1 ；2：属性值2 }</p><p>需求:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是红色的<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是红色的<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是红色的<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>我是四级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>我是四级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>我是四级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>我是四级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br></code></pre></td></tr></table></figure><p>实现:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-tag">p</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>:red;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h4><p>就是选择标签用的</p><h5 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h5><ul><li>标签选择器</li><li>类选择器</li><li>id选择器</li><li>通配符选择器</li></ul><h5 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h5><p>用HTML标签名称作为选择器，按标签名称分类为页面中某一类标签指定同一的CSS样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">语法：<br>标签名&#123;<br>    属性<span class="hljs-number">1</span>: 属性值<span class="hljs-number">1</span>;<br>    属性<span class="hljs-number">2</span>: 属性值<span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="问题和解答"><a href="#问题和解答" class="headerlink" title="问题和解答"></a>问题和解答</h3><ul><li><p>.js文件和.json文件有什么关系和区别？</p><p>这两者都是JavaScript相关的文件格式，都可以用于存储和传输数据；</p><p>.js是脚本文件，用于编写动态的网页和应用程序。.js文件中的代码可以在浏览器或服务器端执行，.js文件中的数据是以Javascript对象或变量的形式存储的，可以直接被Javascript读取和操作。</p><p>.json表示一个JSON数据文件，可以用于在服务器和客户端间传输，是一种轻量级的数据交换格式，基于Javascript对象表示法，但是独立于任何编程语言。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>Html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python发送邮件</title>
    <link href="/2024/03/29/Python%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"/>
    <url>/2024/03/29/Python%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="使用yagmail库来发送邮件"><a href="#使用yagmail库来发送邮件" class="headerlink" title="使用yagmail库来发送邮件"></a>使用yagmail库来发送邮件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> yagmail<br>mail=yagmail.SMTP(<span class="hljs-string">&#x27;发送邮箱的账号&#x27;</span>,<span class="hljs-string">&#x27;发送邮箱的授权码&#x27;</span>,<span class="hljs-string">&#x27;smtp163.com&#x27;</span>)<br>mail.send(<span class="hljs-string">&#x27;接受邮件的账号&#x27;</span>，<span class="hljs-string">&quot;（标题）测试邮件&quot;</span>，<span class="hljs-string">&quot;邮件文本&quot;</span>)<br>mail.close()<br><br><span class="hljs-comment"># 多个收件人</span><br>receiver=[<span class="hljs-string">&quot;xxx@qq.com&quot;</span>,<span class="hljs-string">&quot;xxx@163.com&quot;</span>]<br><span class="hljs-comment"># 文本内容</span><br>text=<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Dear Toph,\n\n</span><br><span class="hljs-string">这是一段文本内容</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h3 id="定时发送邮件"><a href="#定时发送邮件" class="headerlink" title="定时发送邮件"></a>定时发送邮件</h3><p>使用Linux的crontab工具来定时运行python脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">* * * * * 要执行的命令<br>第一个*代表分钟(0-59)<br>第二个*代表小时(0-23)<br>第三个*代表一个月中的第几天(1-31)<br>第四个*代表月份(1-12)<br>第五个*代表一个星期中的第几天(0-7,其中0和7都代表星期日)<br><br>如果想让python每天早上8点的第0分钟运行脚本<br>0 8 * * * /usr/bin/python3 /path/script.py<br>注意/usr/bin/python是python3解释器的正确路径，可以在终端输入which python来查找python解释器的路径<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>e-mail</tag>
      
      <tag>脚本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python刷题笔记</title>
    <link href="/2024/03/29/Python%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/03/29/Python%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a><strong>进制转换</strong></h1><blockquote><p><strong>进制转换</strong></p><p><strong>描述</strong></p><p>写出一个程序，接受一个十六进制的数，输出该数值的十进制表示。</p><p>数据范围：保证结果在 1≤n≤2^31−1</p><p><strong>输入描述：</strong></p><p>输入一个十六进制的数值字符串。</p><p><strong>输出描述：</strong></p><p>输出该数值的十进制字符串。不同组的测试用例用\n隔开。</p><p><strong>示例1</strong></p><p><strong>输入：</strong></p><p>0xAA</p><p><strong>输出：</strong></p><p>170</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> sys.stdin:<span class="hljs-comment"># sys.stdin用于获取用户或其它输入源的一个接口，通常用来从键盘或者文件或其它程序中读取数据</span><br>      <span class="hljs-comment"># 这种写法会让脚本读取命令行中的每一行数据，直到输入EOF</span><br>    a = line.strip()  <span class="hljs-comment"># python字符串的一个方法，会返回一个新的字符串，清理开头和结尾的空白字符（空格，制表符，换行符）</span><br>      <span class="hljs-comment"># 如果输入的line是&quot;  hello  \n&quot;,则line.strip()=&quot;hello&quot;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">int</span>(a,<span class="hljs-number">16</span>))<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(),<span class="hljs-number">16</span>))<br></code></pre></td></tr></table></figure><h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><blockquote><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">&gt;输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>&gt;输出：<span class="hljs-comment">[0,1]</span><br>&gt;解释：因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> == 9 ，返回 <span class="hljs-comment">[0, 1]</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">&gt;输入：nums = <span class="hljs-comment">[3,2,4]</span>, target = 6<br>&gt;输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">&gt;输入：nums = <span class="hljs-comment">[3,3]</span>, target = 6<br>&gt;输出：<span class="hljs-comment">[0,1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li><strong>只会存在一个有效答案</strong></li></ul><p><strong>进阶：</strong>你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self,nums,target</span>):<br>        lens = <span class="hljs-built_in">len</span>(nums)<span class="hljs-comment">#数组长度</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,lens):<span class="hljs-comment">#i在数组内遍历，从第二个数开始</span><br>            <span class="hljs-keyword">if</span>(target-nums[i]) <span class="hljs-keyword">in</span> nums:<span class="hljs-comment">#如果另一个数在数组里</span><br>                j = nums.index(target-nums[i])<span class="hljs-comment">#定位这个数的下角标</span><br>                <span class="hljs-keyword">if</span>(j!=i):<span class="hljs-comment">#这个数不能是i</span><br>                    <span class="hljs-keyword">break</span><br><br>        <span class="hljs-keyword">return</span> [j,i]<br></code></pre></td></tr></table></figure><h1 id="明明的随机数"><a href="#明明的随机数" class="headerlink" title="明明的随机数"></a>明明的随机数</h1><blockquote><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>明明生成了<em>N</em>个1到500之间的随机整数。请你删去其中重复的数字，即相同的数字只保留一个，把其余相同的数去掉，然后再把这些数从小到大排序，按照排好的顺序输出。</p><p>数据范围： 1≤n≤1000 1≤<em>n</em>≤1000 ，输入的数字大小满足 1≤val≤500 </p><h5 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h5><p>第一行先输入随机整数的个数 N 。 接下来的 N 行每行输入一个整数，代表明明生成的随机数。 具体格式可以参考下面的”示例”。</p><h5 id="输出描述："><a href="#输出描述：" class="headerlink" title="输出描述："></a>输出描述：</h5><p>输出多行，表示输入数据处理后的结果</p><h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><p>输入：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">3<br>2<br>2<br>1<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>2<br></code></pre></td></tr></table></figure><p>说明：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros">输入解释：<br>第一个数字是3，也即这个小样例的<span class="hljs-attribute">N</span>=3，说明用计算机生成了3个1到500之间的随机整数，接下来每行一个随机数字，共3行，也即这3个随机数字为：<br>2<br>2<br>1<br>所以样例的输出为：<br>1<br>2  <br></code></pre></td></tr></table></figure></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">try</span>:<br>        n = <span class="hljs-built_in">input</span>() <span class="hljs-comment"># 输入n个数</span><br>        i=<span class="hljs-number">0</span><br>        lst = [] <span class="hljs-comment">#放数据的空列表</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">int</span>(n)): <span class="hljs-comment">#循环n次</span><br>            lst.append(<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())) <span class="hljs-comment">#将输入进来的数字填进</span><br>        uniq=<span class="hljs-built_in">set</span>(lst) <span class="hljs-comment">#列表转集合</span><br>        lst =<span class="hljs-built_in">list</span>(uniq) <span class="hljs-comment">#集合转列表</span><br>        lst.sort() <span class="hljs-comment">#列表排序</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> lst:<br>            <span class="hljs-built_in">print</span>(i) <span class="hljs-comment">#打印列表</span><br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h1 id="字符个数统计"><a href="#字符个数统计" class="headerlink" title="字符个数统计"></a>字符个数统计</h1><blockquote><h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><p>编写一个函数，计算字符串中含有的不同字符的个数。字符在 ASCII 码范围内( 0~127 ，包括 0 和 127 )，换行表示结束符，不算在字符里。不在范围内的不作统计。多个相同的字符只计算一次</p><p>例如，对于字符串 abaca 而言，有 a、b、c 三种不同的字符，因此输出 3 。</p><p>数据范围：1≤<em>n</em>≤500 </p><h3 id="输入描述：-1"><a href="#输入描述：-1" class="headerlink" title="输入描述："></a>输入描述：</h3><p>输入一行没有空格的字符串。</p><h3 id="输出描述：-1"><a href="#输出描述：-1" class="headerlink" title="输出描述："></a>输出描述：</h3><p>输出 输入字符串 中范围在(0~127，包括0和127)字符的种数。</p><h2 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">abc</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">3<br></code></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>输入：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">aaa</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> sys.stdin:<br>    a = line.strip()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(<span class="hljs-built_in">set</span>(a)))<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(<span class="hljs-built_in">set</span>(<span class="hljs-built_in">input</span>().replace(<span class="hljs-string">&#x27;\n&#x27;</span>,<span class="hljs-string">&#x27; &#x27;</span>))))<br></code></pre></td></tr></table></figure><h1 id="跳台阶"><a href="#跳台阶" class="headerlink" title="跳台阶"></a>跳台阶</h1><blockquote><h2 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><p>数据范围：1≤<em>n</em>≤40</p><p>要求：时间复杂度：<em>O</em>(<em>n</em>) ，空间复杂度： <em>O</em>(1)</p><h2 id="示例1-2"><a href="#示例1-2" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">2<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">2<br></code></pre></td></tr></table></figure><p>说明：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">青蛙要跳上两级台阶有两种跳法，分别是：先跳一级，再跳一级或者直接跳两级。因此答案为2       <br></code></pre></td></tr></table></figure><h2 id="示例2-1"><a href="#示例2-1" class="headerlink" title="示例2"></a>示例2</h2><p>输入：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">7<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">21<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">jumpFloor</span>(<span class="hljs-params">self , number: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># write code here</span><br>        <span class="hljs-keyword">if</span> number &lt;= <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> self.jumpFloor(number-<span class="hljs-number">1</span>)+self.jumpFloor(number-<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h1 id="整数与IP地址间的转换"><a href="#整数与IP地址间的转换" class="headerlink" title="整数与IP地址间的转换"></a><strong>整数与IP地址间的转换</strong></h1><blockquote><h2 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h2><p>原理：ip地址的每段可以看成是一个0-255的整数，把每段拆分成一个二进制形式组合起来，然后把这个二进制数转变成<br>一个长整数。<br>举例：一个ip地址为10.0.3.193<br>每段数字       相对应的二进制数<br>10          00001010<br>0          00000000<br>3          00000011<br>193         11000001</p><p>组合起来即为：00001010 00000000 00000011 11000001,转换为10进制数就是：167773121，即该IP地址转换后的数字就是它了。</p><p>数据范围：保证输入的是合法的 IP 序列</p><h3 id="输入描述：-2"><a href="#输入描述：-2" class="headerlink" title="输入描述："></a>输入描述：</h3><p>输入<br>1 输入IP地址<br>2 输入10进制型的IP地址</p><h3 id="输出描述：-2"><a href="#输出描述：-2" class="headerlink" title="输出描述："></a>输出描述：</h3><p>输出<br>1 输出转换成10进制的IP地址<br>2 输出转换后的IP地址</p><h2 id="示例1-3"><a href="#示例1-3" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">10.0.3.193</span><br><span class="hljs-number">167969729</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">167773121</span><br><span class="hljs-number">10.3.3.193</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">try</span>:<span class="hljs-comment"># 用于尝试执行可能会引发异常的代码块</span><br>        ip = <span class="hljs-built_in">input</span>()<span class="hljs-comment">#从用户这里获取一个字符串输入，ip地址</span><br>        num = <span class="hljs-built_in">input</span>()<span class="hljs-comment">#从用户这里获取字符串输入，二进制数</span><br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-keyword">break</span><br><br>    <span class="hljs-keyword">else</span>:<span class="hljs-comment">#如果try代码块中代码执行成功，那么将执行else代码块中的代码</span><br>        ip_list = ip.split(<span class="hljs-string">&#x27;.&#x27;</span>)<span class="hljs-comment">#将输入的IP地址字符串按&#x27;.&#x27;分割，得到一个包含四个字符串的列表</span><br>        ip2num = <span class="hljs-built_in">str</span>()<span class="hljs-comment">#初始化一个空字符串，用于存储转换后的二进制数</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ip_list:<span class="hljs-comment">#遍历其中的每个元素</span><br>            a = <span class="hljs-built_in">bin</span>(<span class="hljs-built_in">int</span>(i,<span class="hljs-number">10</span>))[<span class="hljs-number">2</span>:]<span class="hljs-comment">#将ip地址的一部分从十进制转换为二进制</span><br>            a = <span class="hljs-string">&#x27;0&#x27;</span>*(<span class="hljs-number">8</span>-<span class="hljs-built_in">len</span>(a)) + a <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(a)&lt;<span class="hljs-number">8</span> <span class="hljs-keyword">else</span> a<span class="hljs-comment">#如果二进制数长度小于8，应该在签名添加足够的0，使其长度达到8</span><br>            ip2num += a<span class="hljs-comment">#将转换后的二进制数添加到ip2num结尾</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">int</span>(ip2num,<span class="hljs-number">2</span>))<span class="hljs-comment">#将ip2num从二进制转化为十进制</span><br>        <span class="hljs-comment"># num to ip</span><br>        num2ip = []<span class="hljs-comment">#初始化一个空列表，用于存储转换后的IP地址</span><br>        num2 = <span class="hljs-built_in">bin</span>(<span class="hljs-built_in">int</span>(num,<span class="hljs-number">10</span>))[<span class="hljs-number">2</span>:]<span class="hljs-comment">#将输入的十进制数转换为二进制数</span><br>        num2 = <span class="hljs-string">&#x27;0&#x27;</span>*(<span class="hljs-number">32</span>-<span class="hljs-built_in">len</span>(num2))+num2 <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(num2)&lt;<span class="hljs-number">32</span> <span class="hljs-keyword">else</span> num2<br>        <span class="hljs-comment">#如果二进制数长度小于32，那么在签名添加0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<span class="hljs-comment">#进行四次循环，每次循环处理二进制数的一部分</span><br>            b = num2[<span class="hljs-number">8</span>*i:<span class="hljs-number">8</span>*i+<span class="hljs-number">8</span>]<br>            b = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">int</span>(b,<span class="hljs-number">2</span>))<span class="hljs-comment">#将而仅是数的这一部分从二进制转换为十进制</span><br>            num2ip.append(b)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;.&#x27;</span>.join(num2ip))<span class="hljs-comment">#将num2ip列表中的元素使用.连接起来，形成字符串，最后打印出来</span><br></code></pre></td></tr></table></figure><h1 id="输入整型数组和排序标识，对其元素按照升序或降序进行排序"><a href="#输入整型数组和排序标识，对其元素按照升序或降序进行排序" class="headerlink" title="输入整型数组和排序标识，对其元素按照升序或降序进行排序"></a>输入整型数组和排序标识，对其元素按照升序或降序进行排序</h1><blockquote><h3 id="输入描述：-3"><a href="#输入描述：-3" class="headerlink" title="输入描述："></a>输入描述：</h3><p>第一行输入数组元素个数<br>第二行输入待排序的数组，每个数用空格隔开<br>第三行输入一个整数0或1。0代表升序排序，1代表降序排序</p><h3 id="输出描述：-3"><a href="#输出描述：-3" class="headerlink" title="输出描述："></a>输出描述：</h3><p>输出排好序的数字</p><h2 id="示例1-4"><a href="#示例1-4" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">8</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">9</span> <span class="hljs-number">3</span> <span class="hljs-number">55</span> <span class="hljs-number">64</span> <span class="hljs-number">25</span><br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">9</span> <span class="hljs-number">25</span> <span class="hljs-number">55</span> <span class="hljs-number">64</span><br></code></pre></td></tr></table></figure><h2 id="示例2-2"><a href="#示例2-2" class="headerlink" title="示例2"></a>示例2</h2><p>输入：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>ls = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>rnk = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-keyword">if</span> rnk == <span class="hljs-number">0</span>:<br>    ls.sort()<br>    ls = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>,ls)<span class="hljs-comment">#需要转成字符串才能拼接</span><br><span class="hljs-keyword">elif</span> rnk == <span class="hljs-number">1</span>:<br>    ls.sort(reverse=<span class="hljs-literal">True</span>)<br>    ls = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>,ls)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27; &#x27;</span>.join(ls))<br></code></pre></td></tr></table></figure><h1 id="符号运算-求分数计算结果"><a href="#符号运算-求分数计算结果" class="headerlink" title="符号运算&#x2F;求分数计算结果"></a>符号运算&#x2F;求分数计算结果</h1><blockquote><p>给定一个表达式，求其分数计算结果。 </p><p>表达式的限制如下: </p><p>1.所有的输入数字皆为 正整数 (包括 0) </p><p>2.仅支持四则运算 (+ - *&#x2F;) 和括号 </p><p>3.结果为整数或分数，分数必须化为最简格式 (比如 6,3&#x2F;4,7&#x2F;8,90&#x2F;7) </p><p>4.除数可能为 0，如果遇到这种情况，直接输出“ERROR </p><p>5.输入和最终计算结果中的数字都不会超出整型范围 用例输入一定合法，不会出现括号匹配的情况。</p><p>输入描述 </p><p>字符串格式的表达式，仅支持 + - *&#x2F;，数字可能超过两位，可能带有空格，没有负数长度小于 200 个字符。 </p><p>输出描述 </p><p>表达式结果，以最简格式表达</p><p>如果结果为整数，那么直接输出整数 </p><p>如果结果为负数，那么分子分母不可再约分，可以为假分数，不可表达为带分数结果可能是负数，符号放在前面</p><p>示例1<br>输入<br>1 + 5 * 7 &#x2F; 8<br>输出：<br>43&#x2F;8<br>示例2<br>输入<br>1 &#x2F; （0 - 5）<br>输出：<br>-1&#x2F;5<br>示例3<br>输入<br>1 *  (3 * 4 &#x2F; (8 - (7 + 0)))<br>输出：<br>12</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> functools<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> copy<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">import</span> queue<br><br>nums = [] <span class="hljs-comment">#存储分数的栈。每个分数都表示为一个长度为2的列表，其中第一个元素是分子，第二个元素是分母。</span><br>operations = [] <span class="hljs-comment">#存储运算符的栈</span><br><br><span class="hljs-comment"># 最大公约数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gcd</span>(<span class="hljs-params">a,b</span>):<br>    <span class="hljs-keyword">if</span>(a%b==<span class="hljs-number">0</span>):<br>        <span class="hljs-keyword">return</span> b<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> gcd(b,a%b)<span class="hljs-comment">#用递归来找到最大公约数</span><br>    <br><span class="hljs-comment"># 用于执行运算符操作。从nums和operations中</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">eval_op</span>():<br>    <span class="hljs-keyword">global</span> nums,operations<br>    nums1 = nums.pop() <span class="hljs-comment">#取出最后一个操作数</span><br>    nums2 = nums.pop() <span class="hljs-comment">#取数倒数第二个操作数</span><br>    x = operations.pop() <span class="hljs-comment">#取出最后一个操作符</span><br>    result = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>] <span class="hljs-comment">#初始化结果</span><br>    <span class="hljs-keyword">if</span>(x == <span class="hljs-string">&#x27;*&#x27;</span> <span class="hljs-keyword">or</span> x == <span class="hljs-string">&#x27;+&#x27;</span> <span class="hljs-keyword">or</span> x == <span class="hljs-string">&#x27;-&#x27;</span>):<br>        result[<span class="hljs-number">0</span>] = nums2[<span class="hljs-number">0</span>] * nums1[<span class="hljs-number">0</span>] <span class="hljs-comment">#如果是加减乘，则分子相乘</span><br>    <span class="hljs-keyword">else</span>:<br>        result[<span class="hljs-number">0</span>] = nums2[<span class="hljs-number">0</span>] * nums1[<span class="hljs-number">1</span>] <span class="hljs-comment">#如果是除，则分子乘以分母</span><br><br>    sum_a = nums2[<span class="hljs-number">1</span>] * nums1[<span class="hljs-number">0</span>]<br>    sum_b = nums1[<span class="hljs-number">1</span>] * nums2[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">if</span>(x == <span class="hljs-string">&#x27;*&#x27;</span>):<br>        result[<span class="hljs-number">1</span>] = nums2[<span class="hljs-number">1</span>] * nums1[<span class="hljs-number">1</span>] <span class="hljs-comment">#如果是乘，则分母相乘</span><br>    <span class="hljs-keyword">elif</span> (x == <span class="hljs-string">&#x27;+&#x27;</span>):<br>        result[<span class="hljs-number">1</span>] = sum_a + sum_b <span class="hljs-comment">#如果是加，则分子相加</span><br>    <span class="hljs-keyword">elif</span> (x == <span class="hljs-string">&#x27;-&#x27;</span>):<br>        result[<span class="hljs-number">1</span>] = sum_a - sum_b <span class="hljs-comment">#如果是减，则分子相减</span><br>    <span class="hljs-keyword">else</span>:<br>        result[<span class="hljs-number">1</span>] = nums2[<span class="hljs-number">1</span>] * nums1[<span class="hljs-number">0</span>] <span class="hljs-comment">#如果是除，则分母乘以分子</span><br><br>    nums.append(result) <span class="hljs-comment">#将结果添加到操作数列表</span><br><br><span class="hljs-comment">#获取操作符的优先级</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_priority</span>(<span class="hljs-params">input_char</span>):<br>    <span class="hljs-keyword">if</span>(input_char == <span class="hljs-string">&#x27;+&#x27;</span> <span class="hljs-keyword">or</span> input_char == <span class="hljs-string">&#x27;-&#x27;</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <span class="hljs-comment">#加减的优先级为0</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> <span class="hljs-comment">#乘除的优先级为1</span><br>    <br><br>input_str = <span class="hljs-built_in">input</span>()<br>nums = []<br>operations = []<br>length = <span class="hljs-built_in">len</span>(input_str)<br>current = <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment">#初始化当前字符</span><br>i=<span class="hljs-number">0</span><span class="hljs-comment">#初始化索引</span><br><span class="hljs-keyword">while</span> (i&lt;length):<span class="hljs-comment">#遍历表达式</span><br>    <span class="hljs-keyword">if</span>(input_str[i].isdigit()):<span class="hljs-comment">#判断当前字符是否是数字</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">not</span> input_str[i].isdigit()):<span class="hljs-comment">#如果当前字符不是数字，跳出循环</span><br>                <span class="hljs-keyword">break</span><br>            current += input_str[i] <span class="hljs-comment">#将当前字符添加到当前数字</span><br>            <span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span> &gt;= length): <span class="hljs-comment">#如果索引超出范围，则跳出循环</span><br>                <span class="hljs-keyword">break</span><br>            i+=<span class="hljs-number">1</span><span class="hljs-comment">#索引加一</span><br>        nums.append([<span class="hljs-number">1</span>,<span class="hljs-built_in">int</span>(current)])<span class="hljs-comment">#将当前数字添加到操作数列表</span><br>        current = <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">#清空当前数字</span><br>    <span class="hljs-keyword">elif</span> (input_str[i] == <span class="hljs-string">&#x27;(&#x27;</span>):<span class="hljs-comment">#如果当前字符是左括号</span><br>        operations.append(input_str[i])<span class="hljs-comment">#将左括号添加到操作符列表</span><br>    <span class="hljs-keyword">elif</span> (input_str[i] == <span class="hljs-string">&#x27;)&#x27;</span>):<span class="hljs-comment">#如果当前字符是右括号</span><br>        <span class="hljs-keyword">while</span>(operations[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;(&#x27;</span>): <span class="hljs-comment">#如果操作符列表的最后一个元素不是左括号</span><br>            eval_op() <span class="hljs-comment">#执行操作符</span><br>        operations.pop(<span class="hljs-number">0</span>)<span class="hljs-comment">#删除操作符列表的最后一个元素（左括号）</span><br>    <span class="hljs-keyword">elif</span>(input_str[i] == <span class="hljs-string">&#x27; &#x27;</span>):<span class="hljs-comment">#如果当前字符是空格</span><br>        i+=<span class="hljs-number">1</span> <span class="hljs-comment">#索引加1</span><br>        <span class="hljs-keyword">continue</span> <span class="hljs-comment">#跳过当前循环</span><br>    <span class="hljs-keyword">else</span>: <span class="hljs-comment">#如果当前字符是操作符</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">len</span>(operations)&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> operations[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;(&#x27;</span> <span class="hljs-keyword">and</span> get_priority(input_str[i]) &lt;= get_priority(operations[<span class="hljs-number">0</span>])): <span class="hljs-comment">#如果操作符列表不为空，且最后一个元素不是左括号，且当前操作符的优先级小于等于最后一个操作符的优先级</span><br>            eval_op() <span class="hljs-comment">#执行操作符</span><br>        operations.append(input_str[i]) <span class="hljs-comment">#将当前操作符添加到操作符列表</span><br>    i+=<span class="hljs-number">1</span> <span class="hljs-comment">#索引加一</span><br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">len</span>(nums)&lt;=<span class="hljs-number">1</span>): <span class="hljs-comment">#如果操作数列表的长度小于等于1</span><br>        <span class="hljs-keyword">break</span> <span class="hljs-comment">#跳出循环</span><br>    <span class="hljs-keyword">else</span>:<br>        eval_op() <span class="hljs-comment">#执行操作符</span><br><br>result = nums[<span class="hljs-number">0</span>]<span class="hljs-comment">#获取结果</span><br><span class="hljs-keyword">if</span>(result[<span class="hljs-number">0</span>]==<span class="hljs-number">0</span>):<span class="hljs-comment">#如果分子为0</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;ERROR&quot;</span>)<span class="hljs-comment">#输出错误</span><br><span class="hljs-keyword">else</span>:<br>    up = gcd(result[<span class="hljs-number">0</span>],result[<span class="hljs-number">1</span>]) <span class="hljs-comment">#计算分子和分母的最大公约数</span><br>    result[<span class="hljs-number">0</span>] /= up <span class="hljs-comment">#分子除以最大公约数</span><br>    result[<span class="hljs-number">1</span>] /= up <span class="hljs-comment">#分母除以最大公约数</span><br>    output_str = <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment">#初始化输出字符串</span><br>    <span class="hljs-keyword">if</span>(result[<span class="hljs-number">0</span>] * result[<span class="hljs-number">1</span>]&lt;<span class="hljs-number">0</span>):<span class="hljs-comment">#如果结果为负数</span><br>        output_str += <span class="hljs-string">&quot;-&quot;</span><span class="hljs-comment">#在输出字符串前添加负号</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(result[<span class="hljs-number">0</span>]) == <span class="hljs-number">1</span>):<span class="hljs-comment">#如果分子绝对值为1</span><br>        <span class="hljs-built_in">print</span>(output_str+<span class="hljs-built_in">str</span>(result[<span class="hljs-number">1</span>]))<span class="hljs-comment">#输出分母</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(output_str+<span class="hljs-built_in">str</span>(<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">int</span>(result[<span class="hljs-number">1</span>]))) + <span class="hljs-string">&quot;/&quot;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">int</span>(result[<span class="hljs-number">0</span>]))))<span class="hljs-comment">#输出分数</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#基础</title>
    <link href="/2024/03/29/C-sharp%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/03/29/C-sharp%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>本文中使用注释格式写的正文文本均为尚未理解部分</p><h4 id="enum枚举类型"><a href="#enum枚举类型" class="headerlink" title="enum枚举类型"></a>enum枚举类型</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">enum</span> Season<br>&#123;<br>    Spring,<br>    Summer,<br>    Autumn,<br>    Winter<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>类中还可以有枚举enum</p></li><li><p>默认情况下，枚举的第一项的值为0，第二个值为1，依此类推。要从项中获取整数值，必须将该项显式转换为int</p></li><li><p>int myNum &#x3D; (int) Months.April;</p></li><li><p>您还可以指定自己的枚举值，接下来的项目将相应地更新该数字</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">enum</span> Months<br>&#123; January,  <span class="hljs-comment">// 0      </span><br> February,  <span class="hljs-comment">// 1 </span><br> March=<span class="hljs-number">6</span>,  <span class="hljs-comment">// 6      </span><br> April,   <span class="hljs-comment">// 7 </span><br> May,    <span class="hljs-comment">// 8 </span><br> June,    <span class="hljs-comment">// 9 </span><br> July    <span class="hljs-comment">// 10</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#">Func&lt;<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>&gt; square = x =&gt;x*x;<br>Console.WriteLine(square(<span class="hljs-number">5</span>));<br></code></pre></td></tr></table></figure><h4 id="swtich-表达式"><a href="#swtich-表达式" class="headerlink" title="swtich 表达式"></a>swtich 表达式</h4><p>一个矩形类的实现</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Runtime.InteropServices;<br><span class="hljs-keyword">using</span> System.Security.Cryptography.X509Certificates;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">RectangleApplication</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span><br>    &#123;<br>        <span class="hljs-built_in">double</span> length;<br>        <span class="hljs-built_in">double</span> width;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Acceptdetails</span>()</span><br>        &#123;<br>            length = <span class="hljs-number">4.5</span>;<br>            width = <span class="hljs-number">3.5</span>;<br><br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">GetArrea</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> length * width;<br><br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Display</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;legth:&#123;0&#125;&quot;</span>, length);<br>            Console.WriteLine(<span class="hljs-string">&quot;width:&#123;0&#125;&quot;</span>, width);<br>            Console.WriteLine(<span class="hljs-string">&quot;Area:&#123;0&#125;&quot;</span>, GetArrea());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">ExecuteRectangle</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params">String[] args</span>)</span><br>        &#123;<br>            Rectangle r = <span class="hljs-keyword">new</span> Rectangle();<br>            r.Acceptdetails();<br>            r.Display();<br>            Console.ReadLine();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p>可以在结构类型的声明中使用<code>ref</code>修饰符。</p><h3 id="C-中的注释"><a href="#C-中的注释" class="headerlink" title="C#中的注释"></a>C#中的注释</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">// 这是一行注释</span><br><span class="hljs-comment">/*这个是</span><br><span class="hljs-comment">多行注释</span><br><span class="hljs-comment">的使用格式*/</span><br></code></pre></td></tr></table></figure><p>rectangle类有两个成员变量length和width和三个成员函数executerectangle、getarea和display</p><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><ul><li>必须以字母，下划线或@开头</li><li>第一个字符不能是数字</li><li>不包含任何嵌入的空格或符号</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>值类型</li><li>引用类型</li><li>指针类型</li></ul><h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><h5 id="格式字符串"><a href="#格式字符串" class="headerlink" title="格式字符串"></a>格式字符串</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125; &#123;1&#125; &#123;2&#125;&quot;</span>,zero,one,two);<br></code></pre></td></tr></table></figure><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>元组功能可以将多个数据元素分组成一个。</p><p>下面的示例演示了如何声明元组变量、对其进行初始化并访问其数据成员。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#">(<span class="hljs-built_in">double</span>,<span class="hljs-built_in">int</span>)t1 = (<span class="hljs-number">4.5</span>,<span class="hljs-number">3</span>);<br>Console.WriteLine(<span class="hljs-string">$&quot;Tuple with elements<span class="hljs-subst">&#123;t1.Item1&#125;</span> and <span class="hljs-subst">&#123;t1.Item2&#125;</span>&quot;</span>);<br>(<span class="hljs-built_in">double</span> Sum,<span class="hljs-built_in">int</span> Count)t2=(<span class="hljs-number">4.5</span>,<span class="hljs-number">3</span>);<br>Console.WriteLine(<span class="hljs-string">$&quot;Sum of <span class="hljs-subst">&#123;t2.Count&#125;</span> elements is <span class="hljs-subst">&#123;t2.Sum&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>如上示例所示，如果要定义元组类型，需要指定其所有数据成员的类型，或者，可以指定字段名称。</p><p>虽然不能在元组类型中定义方法，但可以使用.NET提供的方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#">(<span class="hljs-built_in">double</span>,<span class="hljs-built_in">int</span>)t = (<span class="hljs-number">4.5</span>,<span class="hljs-number">3</span>);<br>Console.WriteLine(t.TOString());<br>Console.WriteLine(<span class="hljs-string">$&quot;Hash code of <span class="hljs-subst">&#123;t&#125;</span> is <span class="hljs-subst">&#123;t.GetHashCode()&#125;</span>&quot;</span>);<br></code></pre></td></tr></table></figure><p>元组支持相等运算符</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C#">(<span class="hljs-built_in">int</span> a, <span class="hljs-built_in">byte</span> b)left = (<span class="hljs-number">5</span>,<span class="hljs-number">10</span>);<br>(<span class="hljs-built_in">long</span> a, <span class="hljs-built_in">int</span> b)right = (<span class="hljs-number">5</span>,<span class="hljs-number">10</span>);<br>Console.WriteLine(left == right);<span class="hljs-comment">//output: True</span><br>Console.WriteLine(left!=right);<span class="hljs-comment">//output:False</span><br><span class="hljs-keyword">var</span> t1 =(A:<span class="hljs-number">5</span>,B:<span class="hljs-number">10</span>);<br><span class="hljs-keyword">var</span> t2 =(B:<span class="hljs-number">5</span>,A:<span class="hljs-number">10</span>);<br>Console.WriteLine(t1==t2);<span class="hljs-comment">//output:True</span><br>Console.WriteLine(t1!=t2);<span class="hljs-comment">//output:False</span><br></code></pre></td></tr></table></figure><h4 id="值类型，引用类型以及栈和堆的关系"><a href="#值类型，引用类型以及栈和堆的关系" class="headerlink" title="值类型，引用类型以及栈和堆的关系"></a>值类型，引用类型以及栈和堆的关系</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//以下文字中出现“栈、堆”均为比喻意而非实际意</span><br><span class="hljs-built_in">int</span> n1 = <span class="hljs-number">5</span>;<br><span class="hljs-built_in">int</span> n2 =n1;<br><span class="hljs-comment">//首先在栈中开辟一个内存空间来保存n1的值5，接着再在栈中开辟一个新的内存空间来保存n2的值5，所以显示出来的结果是5 5，然后将n2在栈中对应的空间保存的值修改为7，故显示出来的结果为5 7</span><br><span class="hljs-comment">//引用类型，声明一个引用类型的时候，首先是在“堆”中开辟一个内存空间来存放对应的值，然后在“栈”中开辟一个内存空间用于保存在“堆”中开辟的内存空间的地址。当系统调用引用类型的时候，首先去“栈”中获取到地址，然后根据地址在“堆”中找到对应的内存空间来获取到对应值</span><br><span class="hljs-built_in">string</span>[] a1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span> &#125;;<br><span class="hljs-built_in">string</span>[] a2 = a1;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; a2.Length; i++)<br>&#123;<br>    Console.WriteLine(a2[i]+<span class="hljs-string">&quot; &quot;</span>);<span class="hljs-comment">// a b c</span><br>&#125;<br>a1[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;d&quot;</span>;<br>Console.WriteLine();<span class="hljs-comment">//换行</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; a1.Length;i++)<br>&#123;<br>    Console.WriteLine(a2[i]+<span class="hljs-string">&quot; &quot;</span>);<span class="hljs-comment">// a b d</span><br>&#125;<br>Console.WriteLine();<br><span class="hljs-comment">//首先是在&quot;堆&quot;中开辟了一块内存空间(假设:0x55)，来保存数组的值，然后在&quot;栈&quot;中开辟一个内存空间(a1)用于保存地址0x55。当将a1赋值给a2的时候，是将地址赋值给了a2，即a2获得了地址0x55,因此当修改a1的值的时候，0x55对应内存空间中的值已经被改变，此时a2输出的值也是a b d </span><br><span class="hljs-built_in">string</span> a = <span class="hljs-string">&quot;1 2 3&quot;</span>;<br>stirng b = a;<br><br></code></pre></td></tr></table></figure><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>引用类型不包含存储在变量中的 实际数据，但它们包含对变量的引用——它们指向同一个内存位置。</p><p>使用多个变量时，引用类型可以指向一个内存位置。如果内存位置的数据是由一个变量改变的，其它变量回自动反映这种值的变化。</p><p><strong>内置的</strong>引用类型有<strong>object、dynamic、string</strong></p><h4 id="Object对象类型"><a href="#Object对象类型" class="headerlink" title="Object对象类型"></a>Object对象类型</h4><p>对象object类型是C#通用类型系统（Common Type System-CTS）中所有数据类型的终极类型。object是System.Object类的别名，所以对象Object类型可以被分配任何其它类型（值类型、引用类型、预定义类型或用户自定义类型）的值。但是，在分配之前，需要先进行类型转换。</p><p>当一个类型转换为对象类型时，被称之为<strong>装箱</strong>，转换为值类型时，则称之为<strong>拆箱</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">object</span> obj;<br>obj = <span class="hljs-number">100</span>; <span class="hljs-comment">//这是装箱</span><br></code></pre></td></tr></table></figure><h5 id="关于装箱和拆箱"><a href="#关于装箱和拆箱" class="headerlink" title="关于装箱和拆箱"></a>关于装箱和拆箱</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//装箱</span><br><span class="hljs-built_in">int</span> val = <span class="hljs-number">8</span>;<br><span class="hljs-built_in">object</span> obj = val;<span class="hljs-comment">//整数型数据转换为了对象型数据</span><br><span class="hljs-comment">//拆箱</span><br><span class="hljs-built_in">int</span> val = <span class="hljs-number">8</span>;<br><span class="hljs-built_in">object</span> obj = val;<span class="hljs-comment">//先装箱</span><br><span class="hljs-built_in">int</span> nval = (<span class="hljs-built_in">int</span>)obj;<span class="hljs-comment">//再拆箱</span><br><span class="hljs-comment">//只有装过箱的数据才能拆箱</span><br></code></pre></td></tr></table></figure><h5 id="obj和int之间的关系"><a href="#obj和int之间的关系" class="headerlink" title="obj和int之间的关系"></a>obj和int之间的关系</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">namespace</span> <span class="hljs-title">DataTypeApplication</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">int</span> a = <span class="hljs-number">9</span>;<br>            <span class="hljs-built_in">object</span> obj;<br>            obj = a;<br>            obj = <span class="hljs-number">10</span>;<br>            Console.WriteLine(<span class="hljs-string">&quot;2:&#123;0&#125;&quot;</span>,a);<span class="hljs-comment">//输出2:9</span><br>            Console.WriteLine(<span class="hljs-string">&quot;1:&#123;0&#125;&quot;</span>, obj);<span class="hljs-comment">//输出2:10</span><br>            Console.ReadLine();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//设置值int a = 9; obj = 10;不会对a的值进行改变，obj只是复制了int a的值出来然后进行操作而已。</span><br></code></pre></td></tr></table></figure><h4 id="Dynamic动态类型"><a href="#Dynamic动态类型" class="headerlink" title="Dynamic动态类型"></a>Dynamic动态类型</h4><p>可以存储任何类型的值在动态数据类型变量中。哲学变量的类型检查是在运行时发生的。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">dynamic</span> &lt;variable_name&gt; = <span class="hljs-keyword">value</span>;<br><span class="hljs-built_in">dynamic</span> d = <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><p>动态类型与对象类型相似，但是对象类型变量的类型检查是在编译时发生的，而动态类型变量的类型检查是在运行时发生的。</p><h4 id="String字符串类型"><a href="#String字符串类型" class="headerlink" title="String字符串类型"></a>String字符串类型</h4><p>字符串stirng类型允许您给变量分配任何字符串值，字符串类型是System.String类的别名。他是从对象Object类型派生的。字符串Stirng类型的值可以通过两种形式进行分配；引号和@引号。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C#">String str = <span class="hljs-string">&quot;runoob.com&quot;</span>;<br><span class="hljs-string">@&quot;runoob.com&quot;</span>;<br><span class="hljs-comment">//字符串前加@可以将转义字符(\)当作普通字符对待，比如</span><br>String str = <span class="hljs-string">@&quot;C:\\Windows&quot;</span>;<span class="hljs-comment">//相当于</span><br>String str = <span class="hljs-string">&quot;C:\\\\Windows&quot;</span>;<br><span class="hljs-comment">//@字符串中可以任意换行，换行符及缩进空格都计算在字符串长度之内</span><br> String str2 = <span class="hljs-string">@&quot;&lt;script type=&quot;&quot; text/javascript&quot;&quot;&gt;</span><br><span class="hljs-string">     &lt;!--</span><br><span class="hljs-string">     --&gt;</span><br><span class="hljs-string"> &lt;/script&gt;&quot;</span>;<br></code></pre></td></tr></table></figure><p>用户自定义引用类型有:class、interface或delegate。</p><h4 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h4><p>和C&#x2F;C++的指针没差</p><p>声明指针类型的语法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">type* identifier;<br><span class="hljs-built_in">char</span>* cptr;<br><span class="hljs-built_in">int</span>* iptr;<br></code></pre></td></tr></table></figure><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li>隐式类型转换</li><li>显式类型转换</li></ul><h4 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h4><p>隐式类型转换是指将一个较小范围的数据类型转换为较大范围的数据类型时，编译器会自动完成类型转换，这些转换是C#默认的以安全方式进行的转换，不会导致数据丢失。</p><p>例如，从小的整数型转换为大的整数型，从派生类转换为基类。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">byte</span> b = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">int</span> i = b; <span class="hljs-comment">//隐式转换，不需要显式转换</span><br></code></pre></td></tr></table></figure><p>将一个整数赋值给一个长整数，或将一个浮点数赋值给一个双精度浮点数，这种转换不会导致数据丢失</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> intValue = <span class="hljs-number">42</span>;<br><span class="hljs-built_in">long</span> longValue = intValue; <span class="hljs-comment">//隐式转换， 从int到long</span><br></code></pre></td></tr></table></figure><h4 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h4><p>显式类型转换，即强制类型转换。</p><p>即将一个较大范围的数据类型转换为较小范围的数据类型时，或者将一个对象类型转换为另一个对象类型时，需要使用强制类型转换符号进行显示转换，强制转换会造成数据丢失。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//int到byte</span><br><span class="hljs-built_in">int</span> i = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">byte</span> b = (<span class="hljs-built_in">byte</span>)i; <span class="hljs-comment">//显式转换，需要使用强制类型转换符号</span><br><span class="hljs-comment">//double到int</span><br><span class="hljs-built_in">double</span> doubleValue = <span class="hljs-number">3.14</span>;<br><span class="hljs-built_in">int</span> intValue = (<span class="hljs-built_in">int</span>)doubleValue;<br><span class="hljs-comment">//int到float</span><br><span class="hljs-built_in">int</span> intValue = <span class="hljs-number">42</span>;<br><span class="hljs-built_in">float</span> floatValue = (<span class="hljs-built_in">float</span>)intValue; <span class="hljs-comment">//损失精度</span><br><span class="hljs-comment">//int到string</span><br><span class="hljs-built_in">int</span> intValue = <span class="hljs-number">123</span>;<br><span class="hljs-built_in">string</span> stringValue = intValue.ToString();<br></code></pre></td></tr></table></figure><p>静态变量在整个类中可用</p><h3 id="封装-访问修饰符"><a href="#封装-访问修饰符" class="headerlink" title="封装&amp;访问修饰符"></a>封装&amp;访问修饰符</h3><ul><li><p><strong>public</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Drawing;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">DataTypeApplication</span><br>&#123;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> length;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> width;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">GetArea</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> length*width;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dsiplay</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;长度： &#123;0&#125;&quot;</span>, length);<br>            Console.WriteLine(<span class="hljs-string">&quot;宽度： &#123;0&#125;&quot;</span>, width);<br>            Console.WriteLine(<span class="hljs-string">&quot;面积： &#123;0&#125;&quot;</span>, GetArea());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            Rectangle r = <span class="hljs-keyword">new</span> Rectangle();<br>            r.length = <span class="hljs-number">4.5</span>;<br>            r.width = <span class="hljs-number">3.5</span>;<br>            r.Dsiplay();<br>            Console.ReadLine();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//在上述实例中，成员变量length和width被声明为public，所以它们可以被函数Main()使用Rectangle类的实例r来访问</span><br></code></pre></td></tr></table></figure></li><li><p><strong>private</strong></p><p>代码只能在同一类中访问</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//private访问修饰符指允许一个类中的函数访问它的私有成员，即使是类的实例也不能访问它的私有成员。</span><br><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Drawing;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">DataTypeApplication</span><br>&#123;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span><br>    &#123;<br>        <span class="hljs-comment">//私有成员变量</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">double</span> length;<br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">double</span> width;<br>        <br>        <span class="hljs-comment">//公有方法，用于从用户输入获取矩形的长度和宽度</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AcceptDetails</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;请输入长度&quot;</span>);<br>            length = Convert.ToDouble(Console.ReadLine());<br>            Console.WriteLine(<span class="hljs-string">&quot;请输入宽度:&quot;</span>);<br>            width = Convert.ToDouble(Console.ReadLine());<br>        &#125;<br>        <span class="hljs-comment">//公有方法，用于计算矩形的面积</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">GetArea</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> length*width;<br>        &#125;<br>        <span class="hljs-comment">//公有方法，用于显示矩形的属性和面积</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dsiplay</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;长度： &#123;0&#125;&quot;</span>, length);<br>            Console.WriteLine(<span class="hljs-string">&quot;宽度： &#123;0&#125;&quot;</span>, width);<br>            Console.WriteLine(<span class="hljs-string">&quot;面积： &#123;0&#125;&quot;</span>, GetArea());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-comment">//创建实例</span><br>            Rectangle r = <span class="hljs-keyword">new</span> Rectangle();<br>            <span class="hljs-comment">//通过公有方法从用户输入中获取矩形的长度和宽度</span><br>            r.AcceptDetails();<br>            <span class="hljs-comment">//通过公有方法显示矩形的属性和面积</span><br>            r.Dsiplay();<br>            Console.ReadLine();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//在上述实例中，length和width被声明为私有成员变量，以防止直接在类的外部访问和修改</span><br><span class="hljs-comment">//在progra类中，通过创建rectangle类的实例，然后调用其公有方法，来执行操作，这样主程序无法直接访问和修改矩形的长度和宽度，而是通过类提供的公有接口来进行操作，实现了封装</span><br></code></pre></td></tr></table></figure></li><li><p><strong>protected</strong></p><p>代码可以在同一类中访问，也可以在从该类继承的类中访问。</p></li><li><p><strong>internal</strong></p><p> 代码只能在它自己的程序集中访问，而不能从另一个程序集中访问。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">RectangleApplication</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span><br>    &#123;<br>        <span class="hljs-comment">//成员变量</span><br>        <span class="hljs-keyword">internal</span> <span class="hljs-built_in">double</span> length;<br>        <span class="hljs-keyword">internal</span> <span class="hljs-built_in">double</span> width;<br>        <br>        <span class="hljs-function"><span class="hljs-built_in">double</span> <span class="hljs-title">GetArea</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> length * width;<br>        &#125;<br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Display</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;长度： &#123;0&#125;&quot;</span>, length);<br>            Console.WriteLine(<span class="hljs-string">&quot;宽度： &#123;0&#125;&quot;</span>, width);<br>            Console.WriteLine(<span class="hljs-string">&quot;面积： &#123;0&#125;&quot;</span>, GetArea());<br>        &#125;<br>    &#125;<span class="hljs-comment">//end class Rectangle    </span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title">ExecuteRectangle</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            Rectangle r = <span class="hljs-keyword">new</span> Rectangle();<span class="hljs-comment">//Rectangle这个类定义的r里可以，它再定义个s或者t也可以</span><br>            r.length = <span class="hljs-number">4.5</span>;<br>            r.width = <span class="hljs-number">3.5</span>;<br>            r.Display();<br>            Console.ReadLine();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>protected internal</strong></p><p>允许在本类，派生类或者包含在该类的程序集中访问。也被用于实现继承。</p></li><li><p><strong>sealed</strong></p><p>用于修饰类和方法，防止被继承和重写。</p></li><li><p><strong>async</strong></p><p>使用<code>async</code>修饰符可将方法、lambda表达式或匿名方法指定为<strong>异步</strong>。如果对方法或表达式使用此修饰符，则称为<strong>异步方法</strong>。</p></li></ul><h5 id="摘自菜鸟教程的神评论"><a href="#摘自菜鸟教程的神评论" class="headerlink" title="摘自菜鸟教程的神评论"></a>摘自菜鸟教程的神评论</h5><ul><li>public事件，地球人都知道，全公开</li><li>protected事件，A，B，D知道（A和他的所有儿子知道，妻子C不知道）</li><li>private事件，只有A知道（隐私？心事？）</li><li>internal事件，A，B，C知道（A家里人都知道，私生子D不知道）</li><li>protected internal事件，A，B，C，D都知道,其它人不知道</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C#">&lt;Access Specifier&gt; &lt;Return Type&gt; &lt;Method Name&gt;(Parameter List)<br>&#123;<br>   Method Body<br>&#125;<br>&lt;访问修饰符&gt; &lt;返回类型&gt; &lt;方法名&gt;(参数列表)<br>&#123;<br>   方法主体<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="递归方法调用"><a href="#递归方法调用" class="headerlink" title="递归方法调用"></a>递归方法调用</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">CalculatorApplication</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">NumberManipulator</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">factorial</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> num</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">int</span> result;<br><br>            <span class="hljs-keyword">if</span> (num == <span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                result = factorial(num - <span class="hljs-number">1</span>) * num;<br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params">String[] args</span>)</span><br>        &#123;<br>            NumberManipulator n = <span class="hljs-keyword">new</span> NumberManipulator();<br>            Console.WriteLine(<span class="hljs-string">&quot;6的阶乘是:&#123;0&#125;&quot;</span>, n.factorial(<span class="hljs-number">6</span>));<br>            Console.WriteLine(<span class="hljs-string">&quot;7的阶乘是:&#123;0&#125;&quot;</span>,n.factorial(<span class="hljs-number">7</span>));<br>            Console.ReadLine();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="可空类型"><a href="#可空类型" class="headerlink" title="可空类型"></a>可空类型</h3><h4 id="单问号？和双问号？？"><a href="#单问号？和双问号？？" class="headerlink" title="单问号？和双问号？？"></a>单问号？和双问号？？</h4><p>?单问号用于对int，double，bool等无法直接赋值为null的数据结构类型进行null赋值，意思是这个数据结构类型是nullable类型的。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span>? i = <span class="hljs-number">3</span>;<br><span class="hljs-comment">//等同于</span><br>Nullable&lt;<span class="hljs-built_in">int</span>&gt; i = <span class="hljs-keyword">new</span> Nullable&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-number">3</span>);<br><span class="hljs-built_in">int</span> i;<span class="hljs-comment">//默认值0</span><br><span class="hljs-built_in">int</span>? i;<span class="hljs-comment">//默认值null</span><br></code></pre></td></tr></table></figure><p>??双问号用于判断一个变量在为null的时候返回一个指定的值。</p><h5 id="nullable类型"><a href="#nullable类型" class="headerlink" title="nullable类型"></a>nullable类型</h5><p>可空类型可以表示其基础值类型正常范围内的值，再加上一个null值。</p><p>如Nullable<int32>读作”可空的int32“，可以被赋值为 -2,147,483,648 到 2,147,483,647 之间的任意值，也可以被赋值为 null 值。</p><p>类似的，nullable<bool>变量可以被赋值为true或false或null。在处理数据库和其他包含可能未赋值的元素的数据类型时，将null赋值给数值类型或布尔型的功能特别有用。例如，数据库中的布尔型字段可以储存true或false，或者，该字段也可以未定义。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">CalculatorApplication</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">NullablesAtShow</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">int</span>? num1 = <span class="hljs-literal">null</span>;<br>            <span class="hljs-built_in">int</span>? num2 = <span class="hljs-number">45</span>;<br>            <span class="hljs-built_in">double</span>? num3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">double</span>?();<br>            <span class="hljs-built_in">double</span>? num4 = <span class="hljs-number">3.14159</span>;<br>            <span class="hljs-built_in">bool</span>? boolval = <span class="hljs-keyword">new</span> <span class="hljs-built_in">bool</span>?();<br>            Console.WriteLine(<span class="hljs-string">&quot;显示可空类型的值：&#123;0&#125;，&#123;1&#125;，&#123;2&#125;，&#123;3&#125;&quot;</span>,num1,num2,num3,num4);<br>            Console.WriteLine(<span class="hljs-string">&quot;一个可空的布尔值：&#123;0&#125;&quot;</span>, boolval);<br>            Console.ReadLine();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Null合并运算符？？"><a href="#Null合并运算符？？" class="headerlink" title="Null合并运算符？？"></a>Null合并运算符？？</h4><p>用于定义可空类型和引用类型的默认值。Null合并运算符为类型转换定义了一个预设值，以防可空类型的值为Null，如果第一个操作数的值为Null，则运算符返回第二个操作数的值，否则返回第一个操作数的值。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">CalculatorApplication</span><br>&#123;<br>  <br>    <span class="hljs-keyword">class</span> <span class="hljs-title">NullablesAtShow</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">double</span>? num1 = <span class="hljs-literal">null</span>;<br>            <span class="hljs-built_in">double</span>? num2 = <span class="hljs-number">3.14159</span>;<br>            <span class="hljs-built_in">double</span> num3;<br>            num3 = num1 ?? <span class="hljs-number">5.34</span>;<br>            Console.WriteLine(<span class="hljs-string">&quot;num3的值为:&#123;0&#125;&quot;</span>, num3);<br>            num3 = num2 ?? <span class="hljs-number">5.34</span>;<br>            Console.WriteLine(<span class="hljs-string">&quot;num3的值为:&#123;0&#125;&quot;</span>, num3);<br>            Console.ReadLine();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//声明语法</span><br>datatype[] arrayName;<br></code></pre></td></tr></table></figure><h5 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h5><p>声明一个数组不会在内存中初始化数组。当初始化数组变量时，可以赋值给数组。<br>数组是一个引用类型，所以需要使用关键字来创建数组实例</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">double</span>[] balance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">double</span>[<span class="hljs-number">10</span>];<br></code></pre></td></tr></table></figure><h5 id="赋值给数组"><a href="#赋值给数组" class="headerlink" title="赋值给数组"></a>赋值给数组</h5><p>可以通过使用索引号赋值给一个单独的数组元素</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">balance[<span class="hljs-number">0</span>] = <span class="hljs-number">4500.0</span>;<br></code></pre></td></tr></table></figure><p>可以在声明数组的同时给数组赋值</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">double</span>[] balance = &#123;<span class="hljs-number">2340.0</span>,<span class="hljs-number">4523.69</span>,<span class="hljs-number">3421.0</span>&#125;;<br></code></pre></td></tr></table></figure><p>可以创建并初始化数组</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">int</span> [] marks = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">5</span>] &#123;<span class="hljs-number">98</span>，<span class="hljs-number">99</span>，<span class="hljs-number">91</span>，<span class="hljs-number">87</span>，<span class="hljs-number">95</span>&#125;;<br></code></pre></td></tr></table></figure><p>在此情况下也可省略数组的大小</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">int</span> [] marks = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123;<span class="hljs-number">98</span>，<span class="hljs-number">99</span>，<span class="hljs-number">91</span>，<span class="hljs-number">87</span>，<span class="hljs-number">95</span>&#125;;<br></code></pre></td></tr></table></figure><p>可以赋值一个数组变量到另一个目标数组中。这种情况下，目标和源会指向相同的数组位置。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> [] marks = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123;<span class="hljs-number">98</span>，<span class="hljs-number">99</span>，<span class="hljs-number">91</span>，<span class="hljs-number">87</span>，<span class="hljs-number">95</span>&#125;;<br><span class="hljs-built_in">int</span> [] score = marks;<br></code></pre></td></tr></table></figure><p>当创建一个元素的时候，C#编译器会根据数组类型隐式初始化每个数组元素为一个默认值。如int数组的所有元素都会被初始化为0.</p><p>访问数组元素</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">double</span> salary = balance[<span class="hljs-number">9</span>];<br></code></pre></td></tr></table></figure><h5 id="使用foreach循环"><a href="#使用foreach循环" class="headerlink" title="使用foreach循环"></a>使用foreach循环</h5><p>可以使用foreach语句来遍历数组</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">ArrayApplicaiton</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">MyArray</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">int</span>[] n = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">10</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n.Length; i++)<br>            &#123;<br>                n[i] = i+<span class="hljs-number">100</span>;<br>            &#125;<br>            <span class="hljs-keyword">foreach</span>(<span class="hljs-built_in">int</span> j <span class="hljs-keyword">in</span> n)<br>            &#123;<br>                <span class="hljs-built_in">int</span> i = j - <span class="hljs-number">100</span>;<br>                Console.WriteLine(<span class="hljs-string">&quot;Element[&#123;0&#125;]=&#123;1&#125;&quot;</span>,i,j);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>使用*.ToString()进行格式化</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C#">DateTime dt = <span class="hljs-keyword">new</span> DateTime(<span class="hljs-number">2017</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">13</span>,<span class="hljs-number">16</span>,<span class="hljs-number">32</span>,<span class="hljs-number">108</span>);<br>dt.ToString(<span class="hljs-string">&quot;y yy yyy yyyy&quot;</span>);<span class="hljs-comment">//17 17 2017 2017</span><br>dt.ToString(<span class="hljs-string">&quot;M MM MMM MMMM&quot;</span>);<span class="hljs-comment">//4  04 四月 四月</span><br>dt.ToString(<span class="hljs-string">&quot;d dd ddd dddd&quot;</span>);<span class="hljs-comment">//1  01 周六 星期六</span><br>dt.ToString(<span class="hljs-string">&quot;t tt&quot;</span>);<span class="hljs-comment">//下 下午</span><br>dt.ToString(<span class="hljs-string">&quot;H HH&quot;</span>);<span class="hljs-comment">//13 13</span><br>dt.ToString(<span class="hljs-string">&quot;h hh&quot;</span>);<span class="hljs-comment">//1  01</span><br>dt.ToString(<span class="hljs-string">&quot;m mm&quot;</span>);<span class="hljs-comment">//16 16</span><br>dt.ToString(<span class="hljs-string">&quot;s ss&quot;</span>);<span class="hljs-comment">//32 32</span><br>dt.ToString(<span class="hljs-string">&quot;F FF FFF FFFF FFFFF FFFFFF FFFFFFF&quot;</span>);<span class="hljs-comment">//1 1  108 108  108   108    108</span><br>dt.ToString(<span class="hljs-string">&quot;f ff fff ffff fffff ffffff fffffff&quot;</span>);<span class="hljs-comment">//1 10 108 1080 10800 108000 1080000</span><br>dt.ToString(<span class="hljs-string">&quot;z zz zzz&quot;</span>);<span class="hljs-comment">//+8 +08 +08:00</span><br><br>dt.ToString(<span class="hljs-string">&quot;yyyy/MM/dd HH:mm:ss.fff&quot;</span>);　<span class="hljs-comment">//2017/04/01 13:16:32.108</span><br>dt.ToString(<span class="hljs-string">&quot;yyyy/MM/dd dddd&quot;</span>);　　　　　　<span class="hljs-comment">//2017/04/01 星期六</span><br>dt.ToString(<span class="hljs-string">&quot;yyyy/MM/dd dddd tt hh:mm&quot;</span>); <span class="hljs-comment">//2017/04/01 星期六 下午 01:16</span><br>dt.ToString(<span class="hljs-string">&quot;yyyyMMdd&quot;</span>);　　　　　　　　　<span class="hljs-comment">//20170401</span><br>dt.ToString(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss.fff&quot;</span>);　<span class="hljs-comment">//2017-04-01 13:16:32.108</span><br></code></pre></td></tr></table></figure><h3 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a>Struct</h3><p>类和结构在设计和使用时有不同的考虑因素，类适合表示复杂的对象和行为，支持继承和多态，而结构则更适合表示轻量级数据和值类型以提高性能并避免引用的管理开销。</p><ul><li>结构是<strong>值类型</strong>：它们在栈上分配内存而非在堆上，当结构实例传递给方法或赋值给另一变量时，将复制整个结构内容。</li><li>类是<strong>引用类型</strong>：它们在堆上分配内存。当类实例传递给方法或赋值给另一个变量时，实际上是传递引用（内存地址）而不是整个对象的副本。</li></ul><p>默认构造函数：</p><ul><li><strong>结构不能有无参数的构造函数</strong></li><li><strong>类可以有无参数的构造函数</strong></li></ul><h3 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h3><p>声明语法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">enum</span> &lt;enum_name&gt;<br>&#123;<br>    enumeration list<br>&#125;;<br><span class="hljs-built_in">enum</span> &lt;枚举类型名称&gt;<br>&#123;<br>   用逗号分隔的标识符列表<br>&#125;;<br><span class="hljs-built_in">enum</span> Days &#123;Sun,Mon,Tue,Wed,Thu,Fri,Sat&#125;<br></code></pre></td></tr></table></figure><p>枚举列表中每个符号代表一个整数值，一个比它前面的符号大的整数值。默认情况下第一个枚举符号的值是0；</p><p>实例</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EnumTest</span><br>&#123;<br>    <span class="hljs-built_in">enum</span> Day &#123; Sun, Mon, Tue, Wed, Thu, Fri, Sat &#125;;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> x = (<span class="hljs-built_in">int</span>)Day.Sun;<br>        <span class="hljs-built_in">int</span> y = (<span class="hljs-built_in">int</span>)Day.Fri;<br>        Console.WriteLine(<span class="hljs-string">&quot;Sun = &#123;0&#125;&quot;</span>, x);<br>        Console.WriteLine(<span class="hljs-string">&quot;Fri = &#123;0&#125;&quot;</span>, y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以自定义每个符号的值</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">enum</span> Days&#123;<br>    Mon = <span class="hljs-number">72</span>;<br>    Wed = <span class="hljs-number">33</span>;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>访问标识符指定了对类及其成员的访问规则，如果没有指定，则使用默认的访问标识符。类默认的访问标识符是<strong>internal</strong>，成员的默认访问标识符是<strong>private</strong>。</p><h4 id="部分类（partial-class）"><a href="#部分类（partial-class）" class="headerlink" title="部分类（partial class）"></a>部分类（partial class）</h4><p>在C#中有这么一种神奇的设定，在两个文件中使用同样的命名空间，然后在命名空间命名同样的类，不过前面加上<code>partial</code>关键字，编译器就会将这些部分合并成一个类。例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//test1.cs</span><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">MyNamespace</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method1</span>()</span>&#123;&#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//test2.cs</span><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">MyNamespace</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method2</span>()</span>&#123;&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器会理解为下面的内容</p><figure class="highlight c"><figcaption><span>#</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C">namespace MyNamespace<br>&#123;<br>    public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span></span><br><span class="hljs-class">    &#123;</span><br>        public <span class="hljs-type">void</span> <span class="hljs-title function_">Method1</span><span class="hljs-params">()</span> &#123; &#125;<br>        public <span class="hljs-type">void</span> <span class="hljs-title function_">Method2</span><span class="hljs-params">()</span> &#123; &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="嵌套类-Nested-Class"><a href="#嵌套类-Nested-Class" class="headerlink" title="嵌套类(Nested Class)"></a>嵌套类(Nested Class)</h4><p> 在一个类的内部定义类，内部的叫嵌套类，包含嵌套类的叫外围类。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Container</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Nested</span><br>    &#123;<br>        Nested() &#123; &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>嵌套类均默认为private类型，仅可从其包含的类型中进行访问。上面的示例中，Nested类无法访问外部类型。</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>类的构造函数是一个特殊的成员函数，当创建类的新对象时执行。</p><p>构造函数的名称与类的名称完全相同，它没有任何返回类型。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">LineApplication</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Line</span><br>    &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">double</span> length;<span class="hljs-comment">//线条的长度</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Line</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;对象已创建&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLength</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> len</span>)</span><br>        &#123;<br>            length = len;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">getLength</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> length;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            Line line = <span class="hljs-keyword">new</span> Line();<br>            <span class="hljs-comment">//这句执行成功之后就会返回“对象已创建”</span><br>            <span class="hljs-comment">//设置线条长度</span><br>            line.setLength(<span class="hljs-number">6.0</span>);<br>            Console.WriteLine(<span class="hljs-string">&quot;线条的长度&#123;0&#125;&quot;</span>,line.getLength());<br>            Console.ReadKey();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>默认的构造函数没有任何参数。但是如果需要一个带有参数的构造函数可以有参数，这种构造函数叫参数化构造函数。这种技术可以在创建对象的同时给对象赋初始值。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">LineApplication</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Line</span><br>    &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">double</span> length;<span class="hljs-comment">//线条的长度</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Line</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> len</span>)</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;对象已创建,length=&#123;0&#125;&quot;</span>,len);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLength</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> len</span>)</span><br>        &#123;<br>            length = len;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">getLength</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> length;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            Line line = <span class="hljs-keyword">new</span> Line(<span class="hljs-number">10.0</span>);<br>            Console.WriteLine(<span class="hljs-string">&quot;线条的长度&#123;0&#125;&quot;</span>, line);<br>            <span class="hljs-comment">//设置线条长度</span><br>            line.setLength(<span class="hljs-number">6.0</span>);<br>            Console.WriteLine(<span class="hljs-string">&quot;线条的长度&#123;0&#125;&quot;</span>,line.getLength());<br>            Console.ReadKey();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="C-中的析构函数"><a href="#C-中的析构函数" class="headerlink" title="C#中的析构函数"></a>C#中的析构函数</h4><p>类的析构函数是类的一个特殊成员函数，当类的对象超出范围时执行。</p><p>析构函数的名称是在类的名称前加一个“~”作为前缀，不返回值，也不带任何参数。</p><p>析构函数用于在结束程序（如关闭文件，释放内存）之前释放资源。析构函数不能继承或重载。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">LineApplication</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Line</span><br>    &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">double</span> length;<span class="hljs-comment">//线条的长度</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Line</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;对象已创建&quot;</span>);<br>        &#125;<br>        ~Line()<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;对象已删除&quot;</span>);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLength</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> len</span>)</span><br>        &#123;<br>            length = len;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">getLength</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> length;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            Line line = <span class="hljs-keyword">new</span> Line();<br>       <br>            <span class="hljs-comment">//设置线条长度</span><br>            line.setLength(<span class="hljs-number">6.0</span>);<br>            Console.WriteLine(<span class="hljs-string">&quot;线条的长度&#123;0&#125;&quot;</span>, line.getLength());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h4><p>可以用static将一个成员定义为静态的，当声明一个成员为静态时，意味着无论有多少个类的对象被创建，只会有一个该静态成员的副本。</p><p>关键字意味着类中只有一个该成员的实例。静态变量用于定义常量，因为它们的值可以通过直接调用类而不需要创建类的实例来获取。静态变量可在成员函数或类的定义外部进行初始化。也可以在类的定义内部初始化静态变量。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">StaticVarApplication</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">StaticVar</span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> num;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">count</span>()</span>&#123;<br>            num++;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">getNum</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> num;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">StaticTester</span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span>&#123;<br>            StaticVar s1 = <span class="hljs-keyword">new</span> StaticVar();<br>            StaticVar s2 = <span class="hljs-keyword">new</span> StaticVar();<br>            s1.count();<br>            s2.count();<br>            s1.count();<br>            s2.count();<br>            s1.count();<br>            s2.count();<br>            Console.WriteLine(<span class="hljs-string">&quot;s1的变量num:&#123;0&#125;&quot;</span>,s1.getNum());<br>            Console.WriteLine(<span class="hljs-string">&quot;s2的变量num:&#123;0&#125;&quot;</span>,s2.getNum());<br>            Console.ReadKey();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">s1 的变量 num： <span class="hljs-number">6</span><br>s2 的变量 num： <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>也可以将成员函数声明为static。这样的函数只能访问静态变量。<strong>静态函数在对象被创建之前就已经存在</strong>。以下的实例为静态函数的用法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">StaticVarApplication</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">StaticVar</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> num;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">count</span>()</span><br>        &#123;<br>            num++;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">getNum</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> num;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">StaticTester</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            StaticVar s = <span class="hljs-keyword">new</span> StaticVar();<br>            s.count();<br>            s.count();<br>            s.count();<br>            Console.WriteLine(<span class="hljs-string">&quot;变量num:&#123;0&#125;&quot;</span>, s.getNum()); <br>            Console.ReadKey();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">T</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">T</span>()</span> &#123;<br>        writeHello();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeHello</span>()</span>;<br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestHello</span>:<span class="hljs-title">T</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeHello</span>()</span> &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Helo&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Tease</span>:<span class="hljs-title">T</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeHello</span>()</span> &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;HA?&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main_like</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span> &#123;<br>        TestHello testHello = <span class="hljs-keyword">new</span>();<br>        Tease tease = <span class="hljs-keyword">new</span>();<br>        testHello.writeHello();<br>        tease.writeHello();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>不支持多重继承，但支持接口的多重继承，一个类可实现多个接口。</p><p><strong>一个类可继承多个接口，但只能继承自一个类。</strong></p><p>创建派生类的语法如下</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#">&lt;访问修饰符&gt; <span class="hljs-keyword">class</span>&lt;基类&gt;&#123;    <br>&#125;<br><span class="hljs-keyword">class</span> &lt;派生类&gt;:&lt;基类&gt;&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>派生类会继承基类的成员，除非它们被明确的标记为私有。</p><p>派生类可以通过关键字base类调用基类的构造函数和方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">InheritanceApplication</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWidth</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> w</span>)</span><br>        &#123;<br>            width = w;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHeight</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> h</span>)</span><br>        &#123;<br>            height = h;<br>        &#125;<br>        <span class="hljs-keyword">protected</span> <span class="hljs-built_in">int</span> width;<br>        <span class="hljs-keyword">protected</span> <span class="hljs-built_in">int</span> height;<br>    &#125;<br><br>    <span class="hljs-comment">//派生类</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span>:<span class="hljs-title">Shape</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">getArea</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> (width * height);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title">RectangleTester</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            Rectangle Rect = <span class="hljs-keyword">new</span> Rectangle();<br><br>            Rect.setWidth(<span class="hljs-number">5</span>);<br>            Rect.setHeight(<span class="hljs-number">7</span>);<br><br>            <span class="hljs-comment">//打印对象的面积</span><br>            Console.WriteLine(<span class="hljs-string">&quot;总面积:&#123;0&#125;&quot;</span>,Rect.getArea());<br>            Console.ReadKey();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="基类的初始化"><a href="#基类的初始化" class="headerlink" title="基类的初始化"></a>基类的初始化</h4><p>派生类继承了基类的成员变量和成员方法。因此父类对象应在子类对象创建之前被创建。您可以在成员初始化泪飙中进行父类的初始化。</p><h4 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h4><p>一个接口可以继承自一个或多个其它接口，派生接口继承了基接口的所有成员。</p><p>派生接口可以扩展基接口的成员列表，但不能改变它们的访问修饰符</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">interface</span> <span class="hljs-title">IBaseInterface</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Method1</span>()</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title">IDerivedInterface</span> : <span class="hljs-title">IBaseInterface</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Method2</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>继承接口的实例可以通过以下方式实现</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-comment">//定义一个基接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title">IBaseInterface</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Method1</span>()</span>;<br>&#125;<br><span class="hljs-comment">//定义一个派生接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title">IDerivedInterface</span> : <span class="hljs-title">IBaseInterface</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Method2</span>()</span>;<br>&#125;<br><span class="hljs-comment">//定义派生接口的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> : <span class="hljs-title">IDerivedInterface</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method1</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Method1 implementation&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method2</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Method2 implementation&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        MyClass obj = <span class="hljs-keyword">new</span> MyClass();<br>        obj.Method1();<br>        obj.Method2();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上实例中MyClass类实现了IDerivedInterface接口，因此必须提供IDerivedInterface中定义的所有方法，包括从IBaseInterface继承的Method1()方法。在Main方法中我们创建了MyClass的实例obj，并调用了它的方法。</p><h4 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h4><p>什么三姓家奴（）</p><p>单一继承是一个类只可以继承自一个父类，多继承是一个类可以继承多个父类。</p><p>C#不支持多重继承，但是可以使用接口来实现多重继承。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">InheritanceApplicaiton</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWidth</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> w</span>)</span><br>        &#123;<br>            width = w;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHeight</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> h</span>)</span><br>        &#123;<br>            height = h;<br>        &#125;<br>        <span class="hljs-keyword">protected</span> <span class="hljs-built_in">int</span> width;<br>        <span class="hljs-keyword">protected</span> <span class="hljs-built_in">int</span> height;<br>    &#125;<br>    <span class="hljs-comment">//基类PaintCost</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">PaintCost</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">getCost</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> area</span>)</span>;<br>    &#125;<br>    <span class="hljs-comment">//派生类</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> : <span class="hljs-title">Shape</span>,<span class="hljs-title">PaintCost</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">getArea</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> (width * height);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">getCost</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> area</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> area * <span class="hljs-number">70</span>;<br>        &#125;<br>        <span class="hljs-keyword">class</span> <span class="hljs-title">RectangleTester</span><br>        &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params">String[] args</span>)</span><br>            &#123;<br>                Rectangle Rect = <span class="hljs-keyword">new</span> Rectangle();<br>                <span class="hljs-built_in">int</span> area;<br>                Rect.setWidth(<span class="hljs-number">5</span>);<br>                Rect.setHeight(<span class="hljs-number">8</span>);<br>                area = Rect.getArea();<br>                <span class="hljs-comment">//打印对象的面积</span><br>                Console.WriteLine(<span class="hljs-string">&quot;总面积:&#123;0&#125;&quot;</span>,Rect.getArea());<br>                Console.WriteLine(<span class="hljs-string">&quot;油漆总成本:&#123;0&#125;&quot;</span>, Rect.getCost(area));<br>                Console.ReadKey();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><p>多态是同一个行为具有多个不同表现形式或形态的能力。</p><p>多态性意味着有多重形式。在面向对象编程范式中，多态性往往表现为“一个接口，多个功能”。</p><p>多态性可以是<strong>静态的</strong>或<strong>动态的</strong>。在<strong>静态多态性</strong>中，桉树的响应是在编译时发生的，在<strong>动态多态性</strong>中，函数的响应是在运行时发生的。</p><p>在C#中，每个类型都是多态的，因为包括用户定义类型在内的所有类型都继承自Object。</p><p>多态就是同一个接口，使用不同的实例而执行不同操作。</p><h4 id="静态多态"><a href="#静态多态" class="headerlink" title="静态多态"></a>静态多态</h4><p>在编译时，函数和对象的连接机制被称为早期绑定，也被称为静态绑定。C#提供了两种技术来实现静态多态性：</p><ul><li>函数重载</li><li>运算符重载</li></ul><h5 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h5><p>可以在同一个范围内对相同的函数名有多个定义。函数的定义必须彼此不同，可以是参数列表中的参数类型不同，也可以是参数的个数不同。不同重载只有返回类型不同的函数声明。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">PolymorphismApplication</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestData</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x ,<span class="hljs-built_in">int</span> y ,<span class="hljs-built_in">int</span> z</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> x + y + z;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> x + y;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            TestData dataClass = <span class="hljs-keyword">new</span> TestData();<br>            <span class="hljs-built_in">int</span> add1 = dataClass.Add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>            <span class="hljs-built_in">int</span> add2 = dataClass.Add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><br>            Console.WriteLine(<span class="hljs-string">&quot;add1&quot;</span>,add1);<br>            Console.WriteLine(<span class="hljs-string">&quot;add2&quot;</span>,add2);    <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用同名的函数print打印不同的数据类型</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">PolyMorphismApplication</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Printdata</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i</span>)</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;输出整型:&#123;0&#125;&quot;</span>, i);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> f</span>)</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;输出浮点型:&#123;0&#125;&quot;</span>, f);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s</span>)</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;输出字符串:&#123;0&#125;&quot;</span>,s);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            Printdata p = <span class="hljs-keyword">new</span> Printdata();<br>            p.print(<span class="hljs-number">1</span>);<br>            p.print(<span class="hljs-number">3.14159</span>);<br>            p.print(<span class="hljs-string">&quot;hello,world&quot;</span>);<br>            Console.ReadKey();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="动态多样性"><a href="#动态多样性" class="headerlink" title="动态多样性"></a>动态多样性</h4><p>C#允许使用关键字<strong>abstract</strong>创建抽象类，用于提供接口的部分类的实现。当一个派生类继承自该抽象类时，实现即完成。<strong>抽象类</strong>包含抽象方法，抽象方法可被派生类实现。派生类具有更专业的功能。</p><ul><li>不能创建一个抽象类的实例</li><li>不能在一个抽象类外部声明一个抽象方法</li><li>通过在类定义前面放置关键字<strong>sealed</strong>，可以将类声明为密封类。当一个类被声明为<strong>sealed</strong>的时候，它不能被继承。抽象类不能被声明为sealed</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">PolymorphismApplication</span><br>&#123;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">area</span>()</span>;<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> : <span class="hljs-title">Shape</span><br>    &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> length;<br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> width;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Rectangle</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a = <span class="hljs-number">0</span> ,<span class="hljs-built_in">int</span> b = <span class="hljs-number">0</span></span>)</span><br>        &#123;<br>            length = a;<br>            width = b;  <br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">int</span> <span class="hljs-title">area</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Rectangle类的面积:&quot;</span>);<br>            <span class="hljs-keyword">return</span> (width * length);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">RectangleTester</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            Rectangle r = <span class="hljs-keyword">new</span> Rectangle(<span class="hljs-number">10</span>,<span class="hljs-number">7</span>);<br>            <span class="hljs-built_in">double</span> a = r.area();<br>            Console.WriteLine(<span class="hljs-string">&quot;面积:&#123;0&#125;&quot;</span>, a);<br>            Console.ReadKey();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当有一个定义在类中的函数需要在继承类中实现时，可以使用虚方法。</p><p>虚方法是使用关键字<strong>virtual</strong>声明的。</p><p>虚方法可以在不同的继承类中有不同的实现。</p><p>对虚方法的调用是在运行时发生的。</p><p>动态多态性是通过<strong>抽象类</strong>和<strong>虚方法</strong>实现的。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> X &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Y &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Height &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Width &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-comment">//虚方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;执行基类的画图任务&quot;</span>);   <br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span>:<span class="hljs-title">Shape</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;画一个圆形&quot;</span>);<br>        <span class="hljs-keyword">base</span>.Draw();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span>:<span class="hljs-title">Shape</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;画一个方形&quot;</span>);<br>        <span class="hljs-keyword">base</span>.Draw();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span> : <span class="hljs-title">Shape</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;画一个三角形&quot;</span>);<br>        <span class="hljs-keyword">base</span>.Draw();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//创建一个List&lt;Shape&gt;对象，并向该对象添加Circle，Rectangle和Triangle</span><br>        <span class="hljs-keyword">var</span> shapes = <span class="hljs-keyword">new</span> List&lt;Shape&gt;<br>        &#123;<br>            <span class="hljs-keyword">new</span> Rectangle(),<br>            <span class="hljs-keyword">new</span> Triangle(),<br>            <span class="hljs-keyword">new</span> Circle()<br>        &#125;;<br>        <span class="hljs-comment">//使用foreach循环对该列表的派生类进行循环访问，并对其中的每个shape对象调用Draw方法</span><br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> shape <span class="hljs-keyword">in</span> shapes)<br>        &#123;<br>            shape.Draw();<br>        &#125;<br>        Console.WriteLine(<span class="hljs-string">&quot;按下任意键退出。&quot;</span>);<br>        Console.ReadKey();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过虚方法area()来计算不同形状图像的面积</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">PolyMorphismApplication</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span><br>    &#123;<br>        <span class="hljs-keyword">protected</span> <span class="hljs-built_in">int</span> width, height;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Shape</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a = <span class="hljs-number">0</span>,<span class="hljs-built_in">int</span> b= <span class="hljs-number">0</span></span>)</span><br>        &#123;<br>            width = a;<br>            height = b;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-built_in">int</span> <span class="hljs-title">area</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;父类的面积:&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span>: <span class="hljs-title">Shape</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Rectangle</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a  = <span class="hljs-number">0</span>,<span class="hljs-built_in">int</span> b = <span class="hljs-number">0</span></span>):<span class="hljs-title">base</span>(<span class="hljs-params">a,b</span>)</span><br>        &#123;<br><br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">int</span> <span class="hljs-title">area</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Rectangle类的面积：&quot;</span>);<br>            <span class="hljs-keyword">return</span> (width*height);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span>:<span class="hljs-title">Shape</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Triangle</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a = <span class="hljs-number">0</span>,<span class="hljs-built_in">int</span> b = <span class="hljs-number">0</span></span>):<span class="hljs-title">base</span>(<span class="hljs-params">a,b</span>)</span><br>        &#123;<br><br>        &#125; <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">int</span> <span class="hljs-title">area</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Triangle类的面积&quot;</span>);<br>            <span class="hljs-keyword">return</span> (width*height/<span class="hljs-number">2</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Caller</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CallerArea</span>(<span class="hljs-params">Shape sh</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">int</span> a;<br>            a = sh.area();<br>            Console.WriteLine(<span class="hljs-string">&quot;面积:&#123;0&#125;&quot;</span>,a);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Tester</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            Caller c = <span class="hljs-keyword">new</span> Caller();<br>            Rectangle r = <span class="hljs-keyword">new</span> Rectangle(<span class="hljs-number">10</span>,<span class="hljs-number">7</span>);<br>            Triangle t = <span class="hljs-keyword">new</span> Triangle(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>);<br>            c.CallerArea(r);    <br>            c.CallerArea(t);<br>            Console.ReadKey();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Interface接口"><a href="#Interface接口" class="headerlink" title="Interface接口"></a>Interface接口</h3><p>接口定义了所有类继承应遵循的语法合同。接口定义了语法合同<strong>是什么</strong>的部分，派生类定义了语法合同<strong>怎么做</strong>的部分。</p><p>接口定义了属性、方法和事件，这些都是接口的成员、接口只包含了成员的声明。成员的定义是派生类的责任。接口提供了派生类应遵循的标准结构。</p><p>接口使得实现接口的类或结构在形式上保持一致。</p><p>抽象类在某种程度上与接口类似，但是，它们大多只是用在当只有少数方法由基类声明由派生类实现时。</p><p>接口本身不能实现功能，它只是和声明实现该接口的对象订立一个必须实现哪些行为的契约。</p><h4 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h4><p>接口使用<strong>interface</strong>关键字声明，它与类的声明类似。接口声明默认是pulic的。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">interface</span> <span class="hljs-title">IMyInterface</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MethodToImplement</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上</p><h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>让一组名称与其他名称分隔开的方式。在一个命名空间中声明的类的名称与另一个命名空间中声明的相同的类的名称不冲突。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">first_space</span>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">namespace_c1</span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span>()</span>&#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Inside first_space&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">second_spce</span>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">namespace_c1</span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span>()</span>&#123;<br>            Console.WirteLine(<span class="hljs-string">&quot;Inside second_space&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">TestClass</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span>&#123;<br>        first_space.namespace_c1 fc = <span class="hljs-keyword">new</span> first_space.namespace_c1();<br>        second_space.namespace_c1 sc = <span class="hljs-keyword">new</span> second_space.namespace_c1();<br>        fc.func();<br>        sc.func();<br>        Console.ReadKey();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性是类、结构、和接口的命名成员。类或结构中的成员变量或方法称为<strong>域(Field)</strong>.属性是域的扩展，且可使用相同的语法来访问。它们使用<strong>访问器</strong>让私有域的属性可以被读写或操作。</p><p>属性不会确定存储位置，相反，它们具有可读写或计算它们值的<strong>访问器</strong>。</p><p>例如，有一个名为Students的类，带有age、name和code的私有域。我们不能在类的范围以外直接访问这些域，但是我我们可以拥有访问这些私有域的属性。</p><h4 id="访问器（Accessors）"><a href="#访问器（Accessors）" class="headerlink" title="访问器（Accessors）"></a>访问器（Accessors）</h4><p>属性的访问器包含有助于获取（读取或计算）或设置（写入）属性的可执行语句。访问器声明可包含一个get访问器，一个set访问器，或同时包含二者。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">runoob</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Student</span><br>    &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> code = <span class="hljs-string">&quot;N.A&quot;</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> name = <span class="hljs-string">&quot;not known&quot;</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> age = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">//声明类型为string的code属性</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Code<br>        &#123;<br>            <span class="hljs-keyword">get</span><br>            &#123;<br>                <span class="hljs-keyword">return</span> code;<br>            &#125;<br>            <span class="hljs-keyword">set</span><br>            &#123;<br>                code = <span class="hljs-keyword">value</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//声明类型为string的Name属性</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name<br>        &#123;<br>            <span class="hljs-keyword">get</span><br>            &#123;<br>                <span class="hljs-keyword">return</span> name;<br>            &#125;<br>            <span class="hljs-keyword">set</span><br>            &#123;<br>                name = <span class="hljs-keyword">value</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//声明类型为int的Age属性</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age<br>        &#123;<br>            <span class="hljs-keyword">get</span><br>            &#123;<br>                <span class="hljs-keyword">return</span> age;<br>            &#125;<br>            <span class="hljs-keyword">set</span><br>            &#123;<br>                age = <span class="hljs-keyword">value</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ToString</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Code = &quot;</span> + Code + <span class="hljs-string">&quot;,Name=&quot;</span> + Name + <span class="hljs-string">&quot;,Age=&quot;</span> + Age;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title">ExampleDemo</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>        &#123;<br>            <span class="hljs-comment">//创建一个新的Students对象</span><br>            Student s = <span class="hljs-keyword">new</span> Student();<br>            <span class="hljs-comment">//设置students的code、name和age</span><br>            s.Code = <span class="hljs-string">&quot;001&quot;</span>;<br>            s.Age = <span class="hljs-number">9</span>;<br>            s.Name = <span class="hljs-string">&quot;Murphy&quot;</span>;<br>            Console.WriteLine(<span class="hljs-string">&quot;Students Info:&#123;0&#125;&quot;</span>, s);<br>            <span class="hljs-comment">//增加年龄</span><br>            s.Age += <span class="hljs-number">1</span>;<br>            Console.WriteLine(<span class="hljs-string">&quot;Students Info:&#123;0&#125;&quot;</span>, s);<br>            Console.ReadKey();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="抽象属性"><a href="#抽象属性" class="headerlink" title="抽象属性"></a>抽象属性</h4><h3 id="文件类"><a href="#文件类" class="headerlink" title="文件类"></a>文件类</h3><h4 id="FileStream类"><a href="#FileStream类" class="headerlink" title="FileStream类"></a>FileStream类</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">FileStream &lt;object_name&gt; = <span class="hljs-keyword">new</span> FileStream(&lt;file_name&gt;,&lt;FileMode Enumerator&gt;,&lt;FileAccess Enumeratro&gt;,&lt;FileShare Enumerator&gt;);<br><span class="hljs-comment">//例如</span><br>FileStream F = <span class="hljs-keyword">new</span> FileStream(<span class="hljs-string">&quot;sample.txt&quot;</span>,FileMode.Open,FileAccess.ReadWrite);<br></code></pre></td></tr></table></figure><h4 id="WriteAllText"><a href="#WriteAllText" class="headerlink" title="WriteAllText()"></a>WriteAllText()</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.IO;<br><span class="hljs-built_in">string</span> wirteText = <span class="hljs-string">&quot;hello,world&quot;</span>;<br>File.WriteAllText(<span class="hljs-string">&quot;C:\\Users\\rolen\\Documents\\test2.txt&quot;</span>,wirteText);<br><span class="hljs-built_in">string</span> readText = File.ReadAllText(<span class="hljs-string">&quot;C:\\Users\\rolen\\Documents\\test2.txt&quot;</span>);<br>Console.Write(readText);<br></code></pre></td></tr></table></figure><h4 id="StreamReader类"><a href="#StreamReader类" class="headerlink" title="StreamReader类"></a>StreamReader类</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.IO;<br><span class="hljs-keyword">using</span> System.Text;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">FileApplication</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">try</span><br>            &#123;<br>                <span class="hljs-comment">//创建一个StreamReader的实例来读取文件</span><br>                <span class="hljs-comment">//using语句也能关闭StreamReader</span><br>                <span class="hljs-keyword">using</span> (StreamReader sr = <span class="hljs-keyword">new</span> StreamReader(<span class="hljs-string">&quot;C:\\Users\\rolen\\Documents\\硬盘处理.md&quot;</span>,Encoding.UTF8))<br>                &#123;<br>                    <span class="hljs-built_in">string</span> line;<br>                    <span class="hljs-comment">//从文件中读取并显示行，直到文件的末尾</span><br>                    <span class="hljs-keyword">while</span>((line = sr.ReadLine()) != <span class="hljs-literal">null</span>)<br>                    &#123;<br>                        Console.WriteLine(line);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (Exception e) <br>            &#123;<br>                <span class="hljs-comment">//向用户显示处错信息</span><br>                Console.WriteLine (<span class="hljs-string">&quot;The file could not be read0&quot;</span>);<br>                Console.WriteLine (e.Message);<br>            &#125;<br>            Console.ReadKey();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="StreamWriter类"><a href="#StreamWriter类" class="headerlink" title="StreamWriter类"></a>StreamWriter类</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.IO;<br><span class="hljs-keyword">using</span> System.Text;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">FileApplication</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">string</span>[] names = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123;<span class="hljs-string">&quot;Zara Ali&quot;</span>,<span class="hljs-string">&quot;Nuha Ali&quot;</span> &#125;;<br>            <span class="hljs-keyword">using</span> (StreamWriter sw = <span class="hljs-keyword">new</span> StreamWriter(<span class="hljs-string">&quot;C:\\Users\\rolen\\Documents\\test.txt&quot;</span>))<br>            &#123;<br>                <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">string</span> name <span class="hljs-keyword">in</span> names)<br>                &#123;<br>                    sw.WriteLine(name);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//从文件中读取并显示每行</span><br>            <span class="hljs-built_in">string</span> line = <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-keyword">using</span>(StreamReader sr = <span class="hljs-keyword">new</span> StreamReader(<span class="hljs-string">&quot;C:\\Users\\rolen\\Documents\\test.txt&quot;</span>))<br>            &#123;<br>                <span class="hljs-keyword">while</span>((line = sr.ReadLine())!= <span class="hljs-literal">null</span>)<br>                &#123;<br>                    Console.WriteLine(line);<br>                &#125;<br>            &#125;<br>            Console.ReadKey();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="遍历指定目录下所有文件"><a href="#遍历指定目录下所有文件" class="headerlink" title="遍历指定目录下所有文件"></a>遍历指定目录下所有文件</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.IO;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Text.RegularExpressions;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-built_in">string</span> target_path = <span class="hljs-string">&quot;C:\\Users\\rolen\\Documents\\example\\DataSet-tangshan0805\\labels\\train&quot;</span>;<br>        <span class="hljs-built_in">string</span> File_path = <span class="hljs-string">&quot;C:\\Users\\rolen\\Documents\\example\\log.txt&quot;</span>;<br><br>        <span class="hljs-comment">//遍历目录下的所有文件</span><br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">string</span> filepath <span class="hljs-keyword">in</span> Directory.GetFiles(target_path,<span class="hljs-string">&quot;*.json&quot;</span>))<span class="hljs-comment">//可以通过正则表达式指定文件类型</span><br>        &#123;<br>            <span class="hljs-keyword">try</span><br>            &#123;<br>                <span class="hljs-comment">//读取文件内容</span><br>                <span class="hljs-built_in">string</span> content = File.ReadAllText(filepath);<br><br>                <span class="hljs-comment">//使用正则表达式找到第一个数字</span><br>                Match match = Regex.Match(content, <span class="hljs-string">@&quot;\d+&quot;</span>);<br>                <span class="hljs-keyword">if</span> (match.Success)<br>                &#123;<br>                    <span class="hljs-comment">//将数字写入txt文档</span><br>                    File.AppendAllText(File_path, match.Value + Environment.NewLine);<br><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">catch</span>(Exception ex) <br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">$&quot;处理文件<span class="hljs-subst">&#123;filepath&#125;</span>时出错:<span class="hljs-subst">&#123;ex.Message&#125;</span>&quot;</span>);<br><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="索引器（Indexer）"><a href="#索引器（Indexer）" class="headerlink" title="索引器（Indexer）"></a>索引器（Indexer）</h3><p>索引器（Indexer）允许一个对象可以像数组一样使用下标的方式来访问。属性返回或设置一个特定的数据成员，所引起返回或设置对象实例的一个特定值。它把实例数据分为更小的部分，并索引每个部分，获取或设置每个部分。</p><p>索引器定义的时候不带有名称，但带有<strong>this</strong>关键字，它指向对象实例。</p><h4 id="索引和"><a href="#索引和" class="headerlink" title="索引和"></a>索引和</h4><h3 id="委托（Delegate）"><a href="#委托（Delegate）" class="headerlink" title="委托（Delegate）"></a>委托（Delegate）</h3><p>System.Action是一个内置的委托类型。委托是一种特殊的类型，它可以封装一个方法，使得你可以像操作对象一样来操作这个方法。</p><p>像是一把可以发射属性子弹的枪一样。</p><p>C#中的委托类似于C或C++中的指针。委托是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变。</p><p>委托特别用于实现事件和回调方法。所有的委托都派生自<strong>System.Delegate</strong>类。</p><h4 id="声明委托"><a href="#声明委托" class="headerlink" title="声明委托"></a>声明委托</h4><p>委托声明决定了可由该委托引用的方法。委托可指向一个与其具有相同标签的方法。例如，假设有一个委托：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">MyDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s</span>)</span>;<br></code></pre></td></tr></table></figure><p>上面的委托可被用于引用任何一个带有单一的string参数的方法，并返回一个int类型变量。</p><p>声明委托的语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">delegate</span> &lt;<span class="hljs-keyword">return</span> type&gt; &lt;<span class="hljs-built_in">delegate</span>-name&gt; &lt;parameter list&gt;<br></code></pre></td></tr></table></figure><h4 id="实例化委托"><a href="#实例化委托" class="headerlink" title="实例化委托"></a>实例化委托</h4><p>一旦声明了委托类型，委托对象必须使用new关键字来创建，且与一个特定的方法有关。当创建委托时，传递到new语句的参数就像方法调用一样书写，单不带有参数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printString</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s</span>)</span>;<br>...<br>printString ps1 = <span class="hljs-keyword">new</span> printString(WriteToScreen);<br>printString ps2 = <span class="hljs-keyword">new</span> printString(WriteToFile);<br></code></pre></td></tr></table></figure><p>下面的实例演示了委托的声明、实例化和使用，该委托可用于引用带有一个整形参数的方法，并返回一个整型值。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">NumberChanger</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> n</span>)</span>;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">DelegateApp1</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">TestDelegate</span><br>    &#123;<br>        <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> num = <span class="hljs-number">10</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">AddNum</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> p</span>)</span><br>        &#123;<br>            num += p;<br>            <span class="hljs-keyword">return</span> num;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">MultNum</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> q</span>)</span><br>        &#123;<br>            num *= q;<br>            <span class="hljs-keyword">return</span> num;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">getNum</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> num;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-comment">//创建委托实例</span><br>            NumberChanger nc1 = <span class="hljs-keyword">new</span> NumberChanger(AddNum);<br>            NumberChanger nc2 = <span class="hljs-keyword">new</span> NumberChanger(MultNum);<br>            <span class="hljs-comment">//使用委托对象调用方法</span><br>            nc1(<span class="hljs-number">25</span>);<br>            <span class="hljs-comment">//10+=25</span><br>            <span class="hljs-comment">//return 35</span><br>            Console.WriteLine(<span class="hljs-string">&quot;Value of Num: &#123;0&#125;&quot;</span>,getNum());<br>            <span class="hljs-comment">//35*=5</span><br>            <span class="hljs-comment">//return 175</span><br>            nc2(<span class="hljs-number">5</span>);<br>            Console.WriteLine(<span class="hljs-string">&quot;Value of Num: &#123;0&#125;&quot;</span>, getNum());<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="委托的多播"><a href="#委托的多播" class="headerlink" title="委托的多播"></a>委托的多播</h4><p>委托对象可使用”+“运算符进行合并。一个合并委托调用它所合并的两个委托。只有相同类型的委托可被合并。”-“运算符可用于从合并的委托中一处组件委托。</p><p>使用委托的这个有用的特点，可以创建一个委托被调用时要调用的方法的调用列表。这种设定叫做多播，也叫组播。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">NumberChanger</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> n</span>)</span>;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">DelegateApp1</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">TestDelegate</span><br>    &#123;<br>        <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> num = <span class="hljs-number">10</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">AddNum</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> p</span>)</span><br>        &#123;<br>            num += p;<br>            <span class="hljs-keyword">return</span> num;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">MultNum</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> q</span>)</span><br>        &#123;<br>            num *= q;<br>            <span class="hljs-keyword">return</span> num;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">getNum</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> num;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-comment">//创建委托实例</span><br>            NumberChanger nc;<br>            NumberChanger nc1 = <span class="hljs-keyword">new</span> NumberChanger(AddNum);<br>            NumberChanger nc2 = <span class="hljs-keyword">new</span> NumberChanger(MultNum);<br>            nc = nc1;<br>            nc += nc2;<br>            <span class="hljs-comment">//调用多播</span><br>            nc(<span class="hljs-number">5</span>);<br>            Console.WriteLine(<span class="hljs-string">&quot;Value of Num:&#123;0&#125;&quot;</span>,getNum());<br>            Console.ReadKey();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会返回下列结果：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">Value of Num: <span class="hljs-number">75</span><br></code></pre></td></tr></table></figure><h4 id="委托的用途"><a href="#委托的用途" class="headerlink" title="委托的用途"></a>委托的用途</h4><p>下面的实例演示了委托的用法。委托printString可用于引用带有一个字符串作为输入的方法，并不返回任何东西。</p><p>我们使用这个委托来调用两个方法，第一个把字符串打印到控制台，第二个把字符串打印到文件。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.IO;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">DelegateApp1</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">PrintString</span><br>    &#123;<br>        <span class="hljs-keyword">static</span> FileStream fs;<br>        <span class="hljs-keyword">static</span> StreamWriter sw;<br>        <span class="hljs-comment">//委托声明</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printString</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s</span>)</span>;<br>        <span class="hljs-comment">//该方法打印到控制台</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteToScreen</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> str</span>)</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;The String is:&#123;0&#125;&quot;</span>,str);<br>        &#125;<br>        <span class="hljs-comment">//该方法打印到文件</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteToFile</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s</span>)</span><br>        &#123;<br>            fs = <span class="hljs-keyword">new</span> FileStream(<span class="hljs-string">&quot;C:\\Users\\rolen\\Documents\\test.txt&quot;</span>, FileMode.Append, FileAccess.Write);<br>            sw = <span class="hljs-keyword">new</span> StreamWriter(fs);<br>            sw.WriteLine(s);<br>            sw.Flush();<br>            sw.Close();<br>            fs.Close();<br>        &#125;<br>        <span class="hljs-comment">//该方法把委托作为参数，并使用它调用方法</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendString</span>(<span class="hljs-params">printString ps</span>)</span><br>        &#123;<br>            ps(<span class="hljs-string">&quot;Hello,World&quot;</span>);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            printString ps1 = <span class="hljs-keyword">new</span> printString(WriteToScreen);<br>            printString ps2 = <span class="hljs-keyword">new</span> printString(WriteToFile);<br>            sendString(ps1);<br>            sendString(ps2);<br>            Console.ReadKey ();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="事件（Event）"><a href="#事件（Event）" class="headerlink" title="事件（Event）"></a>事件（Event）</h3><p><strong>事件（Event）</strong>上说是一个用户操作，例如，按键，点击，鼠标移动等，或者是一些提示信息，如系统生成的通知。</p><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p><code>List&lt;T&gt;</code>就是一个泛型类</p><p>泛型允许延迟编写类或方法中的编程元素的数据类型的规范，直到实际在程序中使用它的时候。换句话说，<strong>泛型允许编写一个可以与任何数据类型一起工作的类或方法</strong>。</p><p>可以通过数据类型的代替参数编写类或方法规范。当编译器遇到类的构造函数或方法的函数调用时，它会生成代码来处理指定的数据类型。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.ComponentModel;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">GenericApplication</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyGenericArray</span>&lt;<span class="hljs-title">T</span>&gt;<br>    &#123;<br>        <span class="hljs-keyword">private</span> T[] array;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyGenericArray</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> size</span>)</span><br>        &#123;<br>            array = <span class="hljs-keyword">new</span> T[size+<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getItem</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> array[index];<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setItem</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index, T <span class="hljs-keyword">value</span></span>)</span><br>        &#123;<br>            array[index] = <span class="hljs-keyword">value</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Tester</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-comment">//声明一个整数类型</span><br>            MyGenericArray&lt;<span class="hljs-built_in">int</span>&gt; intArray = <span class="hljs-keyword">new</span> MyGenericArray&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-number">5</span>);<br>            <span class="hljs-comment">//设置值</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> c = <span class="hljs-number">0</span>;c&lt;<span class="hljs-number">5</span>;c++)<br>            &#123;<br>                intArray.setItem(c, c*<span class="hljs-number">5</span>);<br>            &#125;<br>            <span class="hljs-comment">//获取值</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> c = <span class="hljs-number">0</span>;c&lt;<span class="hljs-number">5</span>;c++)<br>            &#123;<br>                Console.Write(intArray.getItem(c)+<span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>            Console.WriteLine();<br>            <span class="hljs-comment">//声明一个字符数组</span><br>            MyGenericArray&lt;<span class="hljs-built_in">char</span>&gt; charArray = <span class="hljs-keyword">new</span> MyGenericArray&lt;<span class="hljs-built_in">char</span>&gt;(<span class="hljs-number">5</span>);<br>            <span class="hljs-comment">//设置值</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> c = <span class="hljs-number">0</span>;c&lt;<span class="hljs-number">5</span>;c++)<br>            &#123;<br>                charArray.setItem(c, (<span class="hljs-built_in">char</span>)(c + <span class="hljs-number">97</span>));<br>            &#125;<br>            <span class="hljs-comment">//获取值</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> c=<span class="hljs-number">0</span>;c&lt;<span class="hljs-number">5</span>;c++)<br>            &#123;<br>                Console.Write(charArray.getItem(c)+<span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>            Console.WriteLine();<br>            Console.ReadKey();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="泛型的特性"><a href="#泛型的特性" class="headerlink" title="泛型的特性"></a>泛型的特性</h4><ul><li>有助于最大限度地重用代码、保护类型的安全和提高性能</li><li>可以创建泛型集合类，.NET框架类库在System.Collections.Generic命名空间中包含了一些新的泛型集合类。可以用这些泛型集合类来替代System.Collections中的集合类</li><li>可以创建自己的泛型接口、泛型类、泛型方法、泛型事件和泛型委托。</li></ul><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p>可以通过类型参数声明泛型方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">GenericMethodAppl</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Swap</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">ref</span> T lhs, <span class="hljs-keyword">ref</span> T rhs</span>)</span><br>        &#123;<br>            T temp;<br>            temp = lhs;<br>            lhs = rhs;<br>            rhs = temp;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">int</span> a, b;<br>            <span class="hljs-built_in">char</span> c, d;<br>            a = <span class="hljs-number">10</span>;<br>            b = <span class="hljs-number">20</span>;<br>            c = <span class="hljs-string">&#x27;I&#x27;</span>;<br>            d = <span class="hljs-string">&#x27;V&#x27;</span>;<br><br>            <span class="hljs-comment">//在交换之前显示值</span><br>            Console.WriteLine(<span class="hljs-string">&quot;Int values before calling swap:&quot;</span>);<br>            Console.WriteLine(<span class="hljs-string">&quot;a=&#123;0&#125;,b=&#123;1&#125;&quot;</span>,a,b);<br>            Console.WriteLine(<span class="hljs-string">&quot;Char value before calling swap:&quot;</span>);<br>            Console.WriteLine(<span class="hljs-string">&quot;C=&#123;0&#125;,d=&#123;1&#125;&quot;</span>,c,d);<br>            <span class="hljs-comment">//调用swap</span><br>            Swap&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-keyword">ref</span> a, <span class="hljs-keyword">ref</span> b);<br>            Swap&lt;<span class="hljs-built_in">char</span>&gt;(<span class="hljs-keyword">ref</span> c, <span class="hljs-keyword">ref</span> d);<br><br>            <span class="hljs-comment">//在交换之后显示</span><br>            Console.WriteLine(<span class="hljs-string">&quot;Int values after calling swap:&quot;</span>);<br>            Console.WriteLine(<span class="hljs-string">&quot;a=&#123;0&#125;,b=&#123;1&#125;&quot;</span>, a, b);<br>            Console.WriteLine(<span class="hljs-string">&quot;Char value after calling swap:&quot;</span>);<br>            Console.WriteLine(<span class="hljs-string">&quot;C=&#123;0&#125;,d=&#123;1&#125;&quot;</span>, c, d);<br>            Console.ReadKey ();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="泛型委托"><a href="#泛型委托" class="headerlink" title="泛型委托"></a>泛型委托</h4><p>可以通过类型参数定义泛型委托，如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-built_in">delegate</span> T <span class="hljs-title">NumberChangeer</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T n</span>)</span>;<br></code></pre></td></tr></table></figure><p>下面的实例演示了委托的使用：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#"><br></code></pre></td></tr></table></figure><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><p>泛型向.NET引入了类型参数的概念。泛型支持设计类和方法，可以在代码中使用该类或方法时，再定义一个或多个类型参数的规范。例如，通过使用泛型类型参数<code>T</code>，可以编写其他客户端代码能够使用的单个类，<code>而不会产生运行时转换或装箱操作的成本或风险</code>，如下所示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">// Declare the generic class.</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GenericList</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add</span>(<span class="hljs-params">T input</span>)</span> &#123; &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">TestGenericList</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ExampleClass</span> &#123; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// Declare a list of type int.</span><br>        GenericList&lt;<span class="hljs-built_in">int</span>&gt; list1 = <span class="hljs-keyword">new</span> GenericList&lt;<span class="hljs-built_in">int</span>&gt;();<br>        list1.Add(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// Declare a list of type string.</span><br>        GenericList&lt;<span class="hljs-built_in">string</span>&gt; list2 = <span class="hljs-keyword">new</span> GenericList&lt;<span class="hljs-built_in">string</span>&gt;();<br>        list2.Add(<span class="hljs-string">&quot;&quot;</span>);<br><br>        <span class="hljs-comment">// Declare a list of type ExampleClass.</span><br>        GenericList&lt;ExampleClass&gt; list3 = <span class="hljs-keyword">new</span> GenericList&lt;ExampleClass&gt;();<br>        list3.Add(<span class="hljs-keyword">new</span> ExampleClass());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用async和await进行异步编程"><a href="#使用async和await进行异步编程" class="headerlink" title="使用async和await进行异步编程"></a>使用async和await进行异步编程</h2><p>在C#中，异步编程是一种处理可能需要长时间运行的操作而不阻塞主线程的方法。通过<code>async</code>和<code>await</code>关键字以及<code>Task</code>和<code>Task&lt;T&gt;</code>对象来实现的。</p><p><strong>异步方法</strong>：使用<code>async</code>关键字定义的方法被称为异步方法。</p><p><strong>await运算符</strong>：在异步方法中，<code>await</code>运算符用于暂停当前方法的执行，直到等待的任务完成。在任务完成后，方法将从暂停的地方继续执行。</p><p>**Task和Task<T>**：这两个对象对异步操作进行建模。<code>Task</code>表示一个异步操作<code>Task&lt;T&gt;</code>表示一个返回值为T的异步操作。</p><p><code>Task</code>不是专为异步准备的，它表达的是一个线程，工作在线程池里的一个线程。</p><p>异步只是线程的一种应用，<code>Wait</code>，以及<code>Status</code>、<code>IsCanceled</code>、<code>IsCompleted</code>、<code>IsFaulted</code>等等，是给多线程准备的方法，因此要在异步中使用多线程的<code>Wait</code>或其它，从代码编译层面不会出错，但程序会。</p><p>尤其，<code>Task.Wait()</code>是一个同步方法，用于多线程中阻塞等待。</p><p><strong><code>Task.Wait()</code>是一个同步方法，用于多线程中阻塞等待，不是实现同步方法中调用异步方法的实现方式</strong>。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ol><li>线程是一个可执行路径，它可以独立于其它线程执行。</li><li>每一个线程都在操作系统的进程(Process)内执行，而操作系统进程提供了程序运行的独立环境</li><li>单线程应用，在进程的独立环境里只跑一个线程，所以该线程拥有独占权</li><li>多线程应用，单个进程中会跑多个线程，它们会共享当前的执行环境（尤其是内存）<ul><li>如一个线程在后台读取数据，另一个线程在数据到达后进行展示</li><li>这个数据就被称作是共享的状态</li></ul></li><li>例子</li></ol><h2 id="LINQ"><a href="#LINQ" class="headerlink" title="LINQ"></a>LINQ</h2><p>查询表达式采用声明性查询语法编写而成。可使用相同的基本查询表达式来查询和转换SQL数据库，ADO.NET数据集，XML文档和流以及.NET集合中的数据。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//创建数据源</span><br><span class="hljs-built_in">int</span>[] scores = &#123;<span class="hljs-number">97</span>,<span class="hljs-number">92</span>,<span class="hljs-number">81</span>,<span class="hljs-number">60</span>&#125;;<br><span class="hljs-built_in">int</span>[] numbers = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];<br><span class="hljs-comment">//定义查询表达式</span><br>IEnumerable&lt;<span class="hljs-built_in">int</span>&gt; scoreQuery = <br>    <span class="hljs-keyword">from</span> score <span class="hljs-keyword">in</span> scores<br>    <span class="hljs-keyword">where</span> score &gt; <span class="hljs-number">80</span><br>    <span class="hljs-keyword">select</span> score;<br><span class="hljs-keyword">var</span> numQuery =<br>    <span class="hljs-function"><span class="hljs-keyword">from</span> num <span class="hljs-keyword">in</span> numbers</span><br><span class="hljs-function">    <span class="hljs-title">where</span> (<span class="hljs-params">num%<span class="hljs-number">2</span></span>)</span>==<span class="hljs-number">0</span><br>    <span class="hljs-keyword">select</span> num;<br><span class="hljs-comment">//执行查询</span><br><span class="hljs-keyword">foreach</span>(<span class="hljs-built_in">int</span> i <span class="hljs-keyword">in</span> scoreQuery)<br>&#123;<br>    Console.WriteLine(i+<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br><span class="hljs-comment">//输出:97,92,81,60</span><br><span class="hljs-keyword">foreach</span>(<span class="hljs-built_in">int</span> num <span class="hljs-keyword">in</span> numQuery)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;&#123;0,1&#125;&quot;</span>,num);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查询表达式概述"><a href="#查询表达式概述" class="headerlink" title="查询表达式概述"></a>查询表达式概述</h3><ul><li>查询表达式可用于查询并转换所有启用了LINQ的数据源中的数据。例如，通过一个查询即可检索SQL数据库中的数据，并生成XML流作为输出。</li><li>查询表达式中的变量全都是强类型，尽管在许多情况下，无需显式提供类型，因为编译器可以推断出。</li><li>只有在循环访问查询变量后，才会执行查询，如上例<code>foreach</code>语句中。</li><li>建议在编写LINQ查询时尽量使用查询语法，并在必要时尽可能使用方法语法。</li><li>一些查询操作，如Count,Max等没有等效的查询表达式子句，因此必须表示为方法调用。</li><li>查询表达可被编译成表达式树或委托，具体视应用查询的类型而定。IEnumerable<T>查询编译为委托。IQueryable和IQueryable<T>查询编译为表达式树。</li></ul><h3 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h3><p>上例中的数据源是一个数组，它支持泛型IEnumberable<T>接口。可查询类型不需要进行修改或特殊处理就可以用作LINQ数据源。如果源数据还没有作为可查询类型出现在内存中，则LINQ提供程序必须以此方式表示源数据。</p><p>例如，LINQ to XML将XML文档加载到可查询的XElement类型中：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">XElement contacts = XElement.Load(<span class="hljs-string">@&quot;&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><ul><li><p><strong>Where</strong>:筛选满足条件的元素</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">var</span> result = collection.Where(x=&gt;x.Property == <span class="hljs-keyword">value</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong>FirstOrDefault</strong>：返回集合中的第一个元素，如果集合为空，则返回类的默认值</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">var</span> result = collection.FirstOrDefault();<br></code></pre></td></tr></table></figure></li><li><p><strong>OrderBy&#x2F;OrderByDescending</strong>:按照指定属性排序</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">var</span> result = collection.OrderBy(x =&gt; x.Property);<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>问题&amp;解决</title>
    <link href="/2024/03/29/%E9%97%AE%E9%A2%98&amp;%E8%A7%A3%E5%86%B3/"/>
    <url>/2024/03/29/%E9%97%AE%E9%A2%98&amp;%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="db文件是啥"><a href="#db文件是啥" class="headerlink" title=".db文件是啥"></a>.db文件是啥</h2><ul><li>.db文件是sqlite的数据库文件，通常用于存储和管理数据</li></ul><h2 id="方法和函数的区别是什么？"><a href="#方法和函数的区别是什么？" class="headerlink" title="方法和函数的区别是什么？"></a>方法和函数的区别是什么？</h2><ul><li>一般在面向对象的语言中，这个被称为方法，面向过程语言中被称为函数，没啥太大区别，都是接收输入的数据并返回数据</li><li>仅有的一点区别是：方法与其被调用的对象实例相关联，方法仅限于在其所包含的类中操作数据</li><li>在C++中可以创建与对象关联的函数，被称为成员函数，在其它语言中就是方法</li></ul><h2 id="C语言有没有修饰访问符？C语言该如何进行封装？"><a href="#C语言有没有修饰访问符？C语言该如何进行封装？" class="headerlink" title="C语言有没有修饰访问符？C语言该如何进行封装？"></a>C语言有没有修饰访问符？C语言该如何进行封装？</h2><ul><li>C语言没有修饰访问符</li></ul><h2 id="写法是什么意思？"><a href="#写法是什么意思？" class="headerlink" title="///&lt;summary&gt;...&lt;/summary&gt;写法是什么意思？"></a><code>///&lt;summary&gt;...&lt;/summary&gt;</code>写法是什么意思？</h2><ul><li>这是一种特殊的注释，被称为XML文档注释，这种注释可以被VisualStudio的IntelliSense（智能感知）和其他工具用来生成代码的文档</li><li>可以在属性、方法等前面输入&#x2F;&#x2F;&#x2F;来自动生成这种注</li></ul><h2 id="什么是数据回写？自动化项目中的数据回写有什么用？"><a href="#什么是数据回写？自动化项目中的数据回写有什么用？" class="headerlink" title="什么是数据回写？自动化项目中的数据回写有什么用？"></a>什么是数据回写？自动化项目中的数据回写有什么用？</h2><h2 id="什么是匿名函数？"><a href="#什么是匿名函数？" class="headerlink" title="什么是匿名函数？"></a>什么是匿名函数？</h2><h2 id="text和-txt有什么区别？"><a href="#text和-txt有什么区别？" class="headerlink" title=".text和.txt有什么区别？"></a>.text和.txt有什么区别？</h2><ul><li>没啥区别，文件扩展名不是文件格式，扩展名只是为了方便人快速识别文件格式和Windows上用于关联打开程序，只是一种约定而已，不代表文件本身格式，就像是将.zip文件扩展名改为.txt一样，不会影响文件本身内容</li></ul><h2 id="如何完全卸载influxdb"><a href="#如何完全卸载influxdb" class="headerlink" title="如何完全卸载influxdb"></a>如何完全卸载influxdb</h2><pre><code class="hljs">- 在C盘的用户文件夹下有`.influxdbv2`文件夹，删除，任务管理器停止后台进程</code></pre><h2 id="当前上下文中不存在名称“Console-WriteLine”是什么情况"><a href="#当前上下文中不存在名称“Console-WriteLine”是什么情况" class="headerlink" title="当前上下文中不存在名称“Console.WriteLine”是什么情况"></a>当前上下文中不存在名称“Console.WriteLine”是什么情况</h2><ul><li><p>命名空间未被引用——开头没有using System</p></li><li><p>大小写拼写错误</p></li><li><p>错误的上下文使用：Console.WriteLine是一个静态方法，它只能在方法内部使用，如果在类的定义中，但不在任何方法体内部去使用它，就会收到这个错误。</p></li><li><p>- </p></li><li><p>什么是回写？</p><ul><li>将数据读到内存上处理，处理之后写到硬盘上，这就是回写。</li></ul></li><li><p>.dll文件和python库之间有什么关系？</p><ul><li>.dll文件是动态链接库（Dynamic Link Library）的缩写，它包含了可以被多个程序共享的代码和数据。这些库通常是用C或C++编写的。</li><li>如<code>numpy</code>库的源代码中有大量的C代码，这些代码在安装numpy库的时候会被编译为动态链接库。然后在python中通过import numpy调用库的时候，python会加载动态链接库，并将其中国的函数和数据结构结构映射到python的命名空间中。</li><li>如调用numpy.arrary()的时候，实际上是在调用一个C语言实现的函数。这个函数会在C语言的环境中执行，然后将结果返回给python。</li></ul></li><li><p>在判断中，is not null和!&#x3D;null有什么区别吗？</p><ul><li><p>在大多数编程语言中没啥区别</p></li><li><p>在SQL中，这两者有重要区别。NULL是一种特殊的值，表示未知或缺失的数据。因此，NULL与任何值，包括NULL自己的比较结果都是未知的，即<code>NULL=NULL</code>和<code>NULL!=NULL</code>都不会返回<code>true</code></p></li><li><p>因此当想要检查一个字段是否为<code>NULL</code>的时候，应该用<code>IS NULL</code>或<code>IS NOT NULL</code>。</p></li><li><p>如<code>WHERE column IS NOT NULL</code>会选取那些column字段不为NULL的行。</p></li></ul></li><li><p>.yaml .json .xml文件格式各自用于做什么？有什么使用上要注意的事？</p><ul><li><strong>JSON（JavaScript Object Notation）</strong>：json简介易读，适用于API的请求和响应。它是一种轻量级的数据交换格式，易于人阅读和编写，同时也易于机器解析和生成。JSON采用完全独立于语言的文本格式，使得JSON成为理想的数据交换语言。</li><li><strong>XML(eXtensible Markup Language)</strong>: XML具有跨平台和跨语言的优点，适用于Web服务和RSS源。它是一种标记语言，可以用来编码文档和数据。XML的设计目标是强调通用性和简单性。尽管XML的使用在web上的数据序列化的用途已经减少，但它仍然被广泛用于存储和传输数据。</li><li><strong>YAML(YAML Ain’t Markup Language)<strong>：YAML适合用于需要人类可读的数据表示场景，如配置文件和日志文件。YAML是一种人类友好的数据序列化标注，它允许在不同语言之间交换数据。</strong>YAML是对JSON的超集，因此任何JSON文件都应该能够用YAML解析器解析</strong>。</li><li>XML用<strong>标记</strong>来定义结构数据，就像html那样</li><li>YAML使用<strong>缩进</strong>来定义结构化数据。就像python</li><li>JSON使用的是<strong>冒号和大括号</strong>来定义结构化数据</li><li><strong>数据传输</strong>的时候，XML和JSON很常见，尤其是<strong>JSON</strong>，在<strong>API</strong>的开发中变得非常普及</li><li><strong>文件大小</strong>上来说，同样的<strong>数据集</strong>。<strong>YAML文件最小，JSON次之，XML最大</strong></li><li><strong>学习难度上来说</strong>，<strong>YAML最难，JSON和XML相对简单</strong></li></ul></li><li><p>目前的这些主流语言的设计目的和初衷都是什么？</p></li><li><p>.ico文件和.resx文件是啥？.config文件一般是什么格式的？</p><ul><li><strong>.ico</strong>:图标文件</li><li><strong>.resx</strong>:资源文件格式，用于存储本地化字符串、图像和其他资源。通常用于.NET Framework应用程序，以便用于管理和本地化应用程序的资源。</li><li><strong>.config</strong>:在.NET应用程序中，包含应用程序的设置，如数据库连接字符串，应用该程序设置等。XML格式，允许开发者以结构化的方式定义配置选项。</li></ul></li><li><p>什么是组件？</p></li><li><p>什么是fody框架？</p><ul><li>一个针对.NET平台的IL（intermediate language）编织工具，允许开发人员在代码编译过程中对代码进行自动化的注入和修改，以实现一些常见的横切关注点</li></ul></li><li><h2 id="什么是横切关注点（Cross-cutting-conerns）？"><a href="#什么是横切关注点（Cross-cutting-conerns）？" class="headerlink" title="什么是横切关注点（Cross-cutting conerns）？"></a>什么是横切关注点（Cross-cutting conerns）？</h2></li><li><p>什么是ping&amp;pong?(计算机网络相关，非游戏)</p><ul><li>用来描述一种简单的请求&#x2F;响应模式，其中两个<strong>设备</strong>或<strong>进程</strong>之间进行基本的通信。</li><li>涉及到以下几个概念：<ul><li><strong>ICMP回显请求&#x2F;回显应答</strong>：<ul><li>最常见的ping-pong是ICMP（Internet control message protocol）的ping命令。一台设备发送一个ICMP回显请求消息给另一台设备，接收设备在收到请求后返返回一个ICMP回显应答消息。</li></ul></li><li><strong>TCP握手过程</strong>:<ul><li>在TCP（Transmission Control Protocol）连接建立过程中，也有ping-pong操作。最著名的是三次握手过程，客户端发送一个SYN（Synchronize Sequence Numbers）同步序列编号消息给服务器以开始连接服务器回复一个SYN-ACK同步-确认消息，最后客户端发送ACK确认消息完成连接建立</li></ul></li><li><strong>应用层协议</strong>:<ul><li>许多应用层协议，如HTTP或FTP，也使用请求&#x2F;响应模式。客户端发送一个请求到服务器，服务器处理请求并返回一个响应。</li></ul></li></ul></li></ul><h2 id="什么是网桥"><a href="#什么是网桥" class="headerlink" title="什么是网桥"></a>什么是网桥</h2><ul><li><p>一种网络设备，用于连接两个或多个局域网LAN并转发数据帧frame。网桥工作在OSI参考模型的数据链路层，主要用于在同一网络协议下连接两个或多个局域网，使他们成为一个逻辑上的网络。</p></li><li><p>没错，看完了上面的定义会让人想起交换机，现代网络中，网桥通常被交换机取代，交换机具有与网桥类似的功能，但性能更好、管理更简单。概念上，交换机可以看作是多端口的网桥。</p></li><li><p><strong>主要功能包括</strong>: </p><ul><li><strong>帧过滤</strong>：</li><li><strong>学习</strong></li><li><strong>转发</strong></li><li><strong>环路检测</strong></li><li><strong>隔离</strong></li></ul></li></ul></li><li><p>主要工作流程:</p><ul><li><strong>学习阶段</strong><ul><li>当网桥首次启动时，它开始学习阶段，通过接收网络上的数据帧来学习每个设备的MAC地址</li><li>网桥通过检查进入数据帧中的源MAC地址来学习这些地址，并记录这些MAC地址与数据帧到达的端口之间的关联。</li></ul></li></ul><h2 id="什么是4G模块"><a href="#什么是4G模块" class="headerlink" title="什么是4G模块"></a>什么是4G模块</h2><p>  <img src="/../images/%E9%97%AE%E9%A2%98&%E8%A7%A3%E5%86%B3/v2-86d3f4d428d8e1664d59c97ee6ff909d_1440w-1715759664937-3.webp" alt="img"></p><ul><li><p>4G模块是一种用于实现无线网络连接的设备，它可以让设备通过4G网络（第四代移动通信技术）进行数据通信。这种模块通常被集成到设备中，例如智能手机、平板电脑、物联网设备等，以实现无线互联网连接。</p></li><li><p>4G模块通常包括: </p><ul><li><strong>调制解调器</strong></li><li><strong>天线</strong></li><li><strong>SIM卡槽</strong></li><li><strong>处理器和存储器</strong></li></ul></li></ul><h2 id="什么是调制解调器（Modem）？"><a href="#什么是调制解调器（Modem）？" class="headerlink" title="什么是调制解调器（Modem）？"></a>什么是调制解调器（Modem）？</h2><ul><li>将数字信号转换为模拟信号（<strong>调制</strong>）将模拟信号转换为数字信号（<strong>解调</strong>）</li><li>在数字通信中，数据通常是以数字形式存在的，如二进制数据，但是，许多通信介质（电话线、光纤、无线电波）中，传递的是模拟信号，要转这么一手。</li></ul><h2 id="为什么4G模块每次上线都会获得一个新的IP地址"><a href="#为什么4G模块每次上线都会获得一个新的IP地址" class="headerlink" title="为什么4G模块每次上线都会获得一个新的IP地址"></a>为什么4G模块每次上线都会获得一个新的IP地址</h2><ul><li>在移动通信网络中，运营山通常采用动态IP地址分配的方式，即每次设备连接到网络时，运营商会从其IP地址池中动态分配一个可用的IP地址给设备使用。这种动态分配的IP地址通常具有一定的生命周期，一旦设备断开连接或一段时间未使用，分配的IP地址就会被释放，返回到IP地址池中供其他设备使用。</li></ul><h2 id="MQTT是什么？"><a href="#MQTT是什么？" class="headerlink" title="MQTT是什么？"></a>MQTT是什么？</h2><ul><li><p>Message Queuing Telemetry Transport 消息队列遥测传输，在应用层</p></li><li><p>一种轻量级的、开放式的、基于发布&#x2F;订阅模式的通信协议，用于物联网(loT)和机器到机器（M2M）通信。</p></li><li><p>MQTT协议的特点包括：</p><ol><li><strong>轻量级</strong>：MQTT协议设计简洁，通信开销小，适用于资源受限的设备和网络环境，如传感器、嵌入式设备、移动设备等。</li><li><strong>发布&#x2F;订阅模式</strong>：MQTT使用发布&#x2F;订阅模式进行消息传递，消息发送者（发布者）将消息发布到特定的主题（Topic），消息接收者（订阅者）通过订阅特定的主题来接收消息。这种模式使得设备之间可以进行松耦合的通信，易于扩展和管理。</li><li><strong>可靠性</strong>：MQTT支持不同级别的消息传递质量（QoS），包括最多一次（QoS 0）、至少一次（QoS 1）和仅一次（QoS 2），可根据应用需求选择适当的消息传递质量级别。</li><li><strong>持久性</strong>：MQTT支持持久会话和持久订阅，使得设备断线后可以恢复之前的会话状态和订阅关系。</li><li><strong>安全性</strong>：MQTT协议支持基于TLS&#x2F;SSL的加密通信和基于用户名和密码的身份认证，保障通信的安全性和隐私性。</li></ol></li></ul><h2 id="什么是寄存器（Register）？"><a href="#什么是寄存器（Register）？" class="headerlink" title="什么是寄存器（Register）？"></a>什么是寄存器（Register）？</h2><h2 id="什么是PLC（Programmable-Logic-Controller）？"><a href="#什么是PLC（Programmable-Logic-Controller）？" class="headerlink" title="什么是PLC（Programmable Logic Controller）？"></a>什么是PLC（Programmable Logic Controller）？</h2><pre><code class="hljs">- 一种借鉴了冯诺依曼机的专为工业自动化控制设计和优化的专用计算设备</code></pre></li></ul><h2 id="原语是什么意思？"><a href="#原语是什么意思？" class="headerlink" title="原语是什么意思？"></a>原语是什么意思？</h2><pre><code class="hljs">- 在计算机科学中，原语通常是指操作系统提供的一些基本的、不可分割的操作，这些操作作为系统调用供用户程序使用。如进程控制、信号、文件操作等可以被视为原语。- 在编程语言中，原语也可以指最基本的操作或函数，它们是构建更复杂程序的基础。</code></pre><h2 id="什么是组件的连接字（Component-Connector）？"><a href="#什么是组件的连接字（Component-Connector）？" class="headerlink" title="什么是组件的连接字（Component Connector）？"></a>什么是组件的连接字（Component Connector）？</h2><ul><li><p>一个软件架构和设计模式中的术语，形容不同组件或模块之间相互连接和通信的机制或接口</p><ul><li><strong>接口（Interface）</strong>：<ul><li>在面向对象编程中，接口定义了一组方法和属性，组件通过实现这些接口来进行通信。</li></ul></li><li><strong>API（应用程序编程接口）</strong>：<ul><li>API是一组预定义的函数、协议和工具，用于构建软件应用。组件通过调用API来实现交互。</li></ul></li><li><strong>服务（Service）</strong>：<ul><li>在服务导向架构（SOA）或微服务架构中，服务作为独立的业务功能单元，组件通过服务调用来交互。</li></ul></li><li><strong>消息队列（Message Queue）</strong>：<ul><li>组件通过发送和接收消息来进行异步通信，消息队列是这种通信方式的典型实现。</li></ul></li><li><strong>事件（Event）</strong>：<ul><li>组件可以基于事件来通信，其中某个组件触发事件，其他组件监听并响应这些事件。</li></ul></li><li><strong>管道（Pipe）</strong>：<ul><li>在某些系统设计中，管道可以作为进程间通信的手段，允许数据从一个进程流向另一个进程。</li></ul></li><li><strong>套接字（Socket）</strong>：<ul><li>网络编程中，套接字用于在网络中的不同主机上的组件之间建立通信。</li></ul></li><li><strong>数据库（Database）</strong>：<ul><li>组件可以通过数据库来共享数据，数据库作为一个共享的存储机制，允许组件进行读写操作。</li></ul></li><li><strong>文件系统（File System）</strong>：<ul><li>组件可以通过读写文件来交换数据，文件系统在这里充当连接字的角色。</li></ul></li><li><strong>通信协议（Communication Protocol）</strong>：<ul><li>在网络通信中，如TCP&#x2F;IP、HTTP等协议定义了数据传输的规则，是组件间通信的基础。</li></ul></li><li><strong>中间件（Middleware）</strong>：<ul><li>中间件提供了一种在不同系统或组件之间传递数据的方法，它可以处理不同系统之间的通信细节。</li></ul></li></ul></li><li><p>在DBeaver上配置数据库到底是怎样的过程？DBeaver这个软件的作用又是什么？</p><ul><li>商业版本可以支持各种 NoSQL 和大数据平台：MongoDB、InfluxDB、Apache Cassandra、Redis、Apache Hive 等。</li></ul><h2 id="什么是套接字（Socket）？"><a href="#什么是套接字（Socket）？" class="headerlink" title="什么是套接字（Socket）？"></a>什么是套接字（Socket）？</h2><ul><li>是网络通信的一个基本概念和工具，它提供了在计算机网络中进行数据交换的端点</li></ul><h2 id="什么是上位机？"><a href="#什么是上位机？" class="headerlink" title="什么是上位机？"></a>什么是上位机？</h2><h2 id="什么是端口转发？什么是内网穿透？二者有什么异同？"><a href="#什么是端口转发？什么是内网穿透？二者有什么异同？" class="headerlink" title="什么是端口转发？什么是内网穿透？二者有什么异同？"></a>什么是端口转发？什么是内网穿透？二者有什么异同？</h2><ul><li>端口转发 （Port ForWarding）</li></ul><h2 id="什么是注册表？"><a href="#什么是注册表？" class="headerlink" title="什么是注册表？"></a>什么是注册表？</h2><ul><li>一个硬盘上的数据库，存着window和安装的软件的设置</li></ul><h2 id="Windows的回收站是个什么设定？"><a href="#Windows的回收站是个什么设定？" class="headerlink" title="Windows的回收站是个什么设定？"></a>Windows的回收站是个什么设定？</h2><ul><li>每个盘符有一定的空间存放，文件被删除后不是直接从硬盘上消失，而是被标注为可覆盖</li></ul><h2 id="Linux是否有回收站机制？"><a href="#Linux是否有回收站机制？" class="headerlink" title="Linux是否有回收站机制？"></a>Linux是否有回收站机制？</h2><ul><li>无</li></ul><h2 id="什么是缓存锁（Cache-Locking）？"><a href="#什么是缓存锁（Cache-Locking）？" class="headerlink" title="什么是缓存锁（Cache Locking）？"></a>什么是缓存锁（Cache Locking）？</h2><ul><li>一种用于控制对共享资源的访问机制，特别是在多线程或分布式系统中。当多个进程或线程需要访问相同的数据时，缓存锁可以确保</li></ul><h2 id="什么是双向转发（Two-way-Forwarding）？"><a href="#什么是双向转发（Two-way-Forwarding）？" class="headerlink" title="什么是双向转发（Two-way Forwarding）？"></a>什么是双向转发（Two-way Forwarding）？</h2><ul><li>双向转发通常是在网络通信中，数据可以在两个方向上进行传输，即发送</li></ul><h2 id="什么是有限状态机？"><a href="#什么是有限状态机？" class="headerlink" title="什么是有限状态机？"></a>什么是有限状态机？</h2><ul><li>有限状态机（Finite State Machine，FSM）是一种计算模型，它由一组状态以及在这些状态之间的转移组成。</li></ul></li><li><p>vs中打包和生成的区别是什么？</p><ul><li><strong>主要区别</strong>:<ul><li><strong>范围</strong>：生成通常只涉及编译源代码，而打包涉及更全面的部署准备过程</li><li><strong>依赖项</strong>:打包过程会考虑应用程序的所有依赖性，并确保它们被包含在部署包中</li><li><strong>部署</strong>：打包通常是为了直接支持部署，而生成是为了确保代码可以编译成功</li><li><strong>配置</strong>:打包可以包含特定的配置选项，如发布配置、目标框架、运行时标识符等</li></ul></li></ul></li><li><p><strong>MQTT Broker</strong> 是一种服务器，它负责接收来自发布者（Publishers）的消息，并将这些消息分发给订阅了相应主题（Topics）的订阅者（Subscribers）。它的主要功能包括：</p><ol><li><p><strong>消息路由</strong>：接收发布者发送的消息，并根据订阅者的订阅主题将消息路由到正确的订阅者。</p></li><li><p><strong>会话管理</strong>：维护客户端连接的会话信息，包括连接状态、订阅信息和消息队列。</p></li><li><p><strong>消息存储</strong>：存储持久化消息，以便在订阅者不可用时保留消息，并在订阅者恢复连接时传递消息。</p></li><li><p><strong>质量保证</strong>：根据 QoS（Quality of Service）等级，确保消息按规定的可靠性传递。</p><h3 id="MQTT-Broker-的工作原理"><a href="#MQTT-Broker-的工作原理" class="headerlink" title="MQTT Broker 的工作原理"></a>MQTT Broker 的工作原理</h3><ol><li><strong>客户端连接</strong>：客户端（包括发布者和订阅者）通过网络连接到 Broker。连接建立后，客户端可以发布消息或订阅主题。</li><li><strong>消息发布</strong>：发布者将消息发送到 Broker，并指定一个或多个主题。消息可以携带不同的 QoS 等级，决定消息的传递可靠性。</li><li><strong>消息订阅</strong>：订阅者向 Broker 订阅感兴趣的主题。订阅请求可以指定 QoS 等级，决定订阅者希望接收消息的可靠性。</li><li><strong>消息路由和分发</strong>：Broker 接收到消息后，根据订阅者的订阅信息，将消息分发给相应的订阅者。</li></ol><h3 id="QoS（服务质量）等级"><a href="#QoS（服务质量）等级" class="headerlink" title="QoS（服务质量）等级"></a>QoS（服务质量）等级</h3><p>MQTT 定义了三个 QoS 等级，以满足不同的可靠性需求：</p><ul><li><strong>QoS 0</strong>：至多一次（At most once），消息发送但不确认，不保证消息到达（“最佳努力”传递）。</li><li><strong>QoS 1</strong>：至少一次（At least once），消息发送并确认，确保消息至少到达一次，但可能会有重复。</li><li><strong>QoS 2</strong>：仅一次（Exactly once），消息发送并通过四步握手确认，确保消息仅到达一次，最可靠但开销最大。</li></ul><h3 id="常见的-MQTT-Broker-实现"><a href="#常见的-MQTT-Broker-实现" class="headerlink" title="常见的 MQTT Broker 实现"></a>常见的 MQTT Broker 实现</h3><p>有许多开源和商业的 MQTT Broker 实现，以下是一些常见的 MQTT Broker：</p><ul><li><strong>Mosquitto</strong>：一个轻量级的开源 MQTT Broker，适合嵌入式设备和小型物联网项目。</li><li><strong>EMQX</strong>：一个高性能的开源 MQTT Broker，支持大规模并发连接，适合大型物联网项目。</li><li><strong>HiveMQ</strong>：一个商业 MQTT Broker，提供企业级功能和支持。</li><li><strong>Eclipse Paho</strong>：Eclipse 基金会下的一个开源 MQTT 客户端库和 Broker 项目。</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>MQTT Broker 被广泛应用于物联网（IoT）场景中，包括但不限于：</p><ul><li><strong>智能家居</strong>：设备之间的通信和控制，如智能灯、智能插座等。</li><li><strong>工业自动化</strong>：机器和传感器之间的数据传输和监控。</li><li><strong>车联网</strong>：车辆数据的采集和实时传输。</li><li><strong>医疗健康</strong>：医疗设备的数据传输和监控。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>MQTT Broker 是 MQTT 协议的核心组件，负责管理消息的传递和分发。通过支持发布&#x2F;订阅模式、QoS 等级和会话管理，MQTT Broker 提供了高效可靠的消息传输机制，适用于各种物联网应用场景。选择合适的 MQTT Broker 取决于项目的规模、性能要求和特定功能需求。</p></li></ol><h2 id="什么是分治（Divide-and-Conquer）"><a href="#什么是分治（Divide-and-Conquer）" class="headerlink" title="什么是分治（Divide and Conquer）"></a>什么是分治（Divide and Conquer）</h2><p>是一种算法设计范式，通过将问题分解为更小的子问题来解决，然后递归地解决这些子问题，并最终将子问题的解结合并形成原问题的解。</p><p>- </p><h2 id="什么是安装证书"><a href="#什么是安装证书" class="headerlink" title="什么是安装证书"></a>什么是安装证书</h2><ul><li><p>安装证书通常指的是在计算机或设备上添加<strong>数字证书</strong>的过程。数字证书是一种用于加密和验证通信的安全性工具，通常用于加密和保护网络通信、网站身份验证等方面。在安装证书的过程中，用户将数字证书文件添加到其操作系统、浏览器或应用程序的信任存储中，以确保与其他实体的安全通信。</p><h3 id="安装证书的常见场景"><a href="#安装证书的常见场景" class="headerlink" title="安装证书的常见场景"></a>安装证书的常见场景</h3><ol><li><strong>网站身份验证</strong>：Web 浏览器通常会使用数字证书来验证网站的身份。当用户访问一个使用 HTTPS 协议的网站时，网站会向浏览器发送其数字证书，浏览器会验证证书的有效性，并确定是否与信任的证书颁发机构相关联。</li><li><strong>电子邮件加密</strong>：在电子邮件通信中，数字证书可以用于加密和签名邮件，确保邮件内容的保密性和完整性。</li><li><strong>VPN 连接</strong>：VPN（Virtual Private Network）连接通常需要数字证书来验证用户的身份和加密通信。</li></ol></li></ul><ol start="4"><li><strong>客户端身份验证</strong>：在某些系统中，客户端需要提供数字证书来验证其身份，以访问受限资源或服务。</li></ol><h3 id="安装证书的步骤"><a href="#安装证书的步骤" class="headerlink" title="安装证书的步骤"></a>安装证书的步骤</h3><p>  安装数字证书通常涉及以下步骤：</p><ol><li><strong>获取证书</strong>：用户需要获取数字证书文件，通常是由可信任的证书颁发机构（CA）签发的。这些证书可以是网站的 SSL 证书、电子邮件签名证书等。</li><li><strong>导入证书</strong>：用户需要将数字证书导入其操作系统、浏览器或应用程序的证书存储中。导入证书的方法取决于所使用的操作系统和软件。</li><li><strong>信任证书</strong>：一旦证书被导入，用户可能需要手动将其标记为受信任的证书。这样做可以确保系统或软件信任证书颁发机构签发的证书，并在与其他实体通信时使用它们。</li><li><strong>配置选项</strong>：有时，用户可能需要在操作系统、浏览器或应用程序中配置一些选项，以确保数字证书被正确地使用和管理。</li></ol><h3 id="安全考虑"><a href="#安全考虑" class="headerlink" title="安全考虑"></a>安全考虑</h3><p>在安装数字证书时，需要注意以下安全考虑：</p><ul><li><p><strong>来源可信性</strong>：确保从可信任的来源获取数字证书，避免使用来自不可信任或未知来源的证书。</p><ul><li><strong>验证证书有效性</strong>：在安装证书之前，用户应该验证证书的有效性，包括证书的有效期、签发者等信息。</li></ul></li><li><p><strong>保护私钥</strong>：如果证书包含私钥，则需要确保私钥的保密性，以防止未经授权的访问或使用。</p><ul><li><strong>定期更新</strong>：定期检查和更新证书，以确保其仍然有效，并且与安全最佳实践保持一致。</li></ul><p>通过正确地安装和管理数字证书，用户可以增强其网络通信的安全性和可信度，并确保与其他实体的安全通信。</p></li></ul></li><li><p>var parts &#x3D; content.Split(new string[] { “&amp;&amp;” }, StringSplitOptions.None); 这句话是什么意思</p></li></ul><h3 id="代码部分解释"><a href="#代码部分解释" class="headerlink" title="代码部分解释"></a>代码部分解释</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">csharp<br>复制代码<br><span class="hljs-keyword">var</span> parts = content.<span class="hljs-built_in">Split</span>(<span class="hljs-keyword">new</span> string[] &#123; <span class="hljs-string">&quot;&amp;&amp;&quot;</span> &#125;, StringSplitOptions.<span class="hljs-built_in">None</span>);<br></code></pre></td></tr></table></figure><h3 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h3><ol><li><strong><code>content</code></strong>:<ul><li>这是一个字符串变量，包含需要分割的原始字符串内容。在你的示例中，它是去掉包头和包尾后的HJ212数据字符串。</li></ul></li><li><strong><code>Split</code>方法</strong>:<ul><li><code>Split</code>方法是C#中用于将字符串分割成子字符串数组的方法。</li></ul></li><li><strong><code>new string[] &#123; &quot;&amp;&amp;&quot; &#125;</code></strong>:<ul><li>这是指定的分隔符数组。在这里，<code>&quot;&amp;&amp;&quot;</code>是用来分割字符串的特定子字符串。</li><li><code>new string[] &#123; &quot;&amp;&amp;&quot; &#125;</code>表示创建一个包含一个元素的字符串数组，该元素是<code>&quot;&amp;&amp;&quot;</code>。</li></ul></li><li><strong><code>StringSplitOptions.None</code></strong>:<ul><li>这是一个枚举值，指定在分割操作中不忽略空条目。如果指定为<code>StringSplitOptions.RemoveEmptyEntries</code>，则会忽略结果数组中的空字符串。</li></ul></li></ol><h2 id="如何获取元组中的变量？"><a href="#如何获取元组中的变量？" class="headerlink" title="如何获取元组中的变量？"></a>如何获取元组中的变量？</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">var</span> (Rtd,Flag) = tuple;<br><span class="hljs-comment">//解构元组</span><br></code></pre></td></tr></table></figure><ul><li><pre><code class="C#">FiTools.BridgeManager.Bridge: System.OperationCanceledException: The operation was canceled.   at System.Threading.CancellationToken.ThrowOperationCanceledException()   at System.Threading.CancellationToken.ThrowIfCancellationRequested()   at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.ThrowException(SocketError error, CancellationToken cancellationToken)   at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.System.Threading.Tasks.Sources.IValueTaskSource&lt;System.Net.Sockets.Socket&gt;.GetResult(Int16 token)   at System.Net.Sockets.TcpListener.&lt;AcceptTcpClientAsync&gt;g__WaitAndWrap|32_0(ValueTask`1 task)   at FiTools.BridgeManager.Bridge.BeginTcpProxy() in C:\uzone\项目\2024\2024-01 山东港口集团日照港 智慧环保一期\代码\BridgeManager\Bridge.cs:line 75<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>一般这种报错，有多行at的这种是什么原因？要怎么看才能更直观的获得信息？<br><br>- 在 C# 程序中，当异常发生时，通常会有一个堆栈跟踪（stack trace），它列出了异常抛出时调用堆栈的内容。每行 `at` 都表示一个方法调用，从最内层的方法开始，一直到异常抛出的位置。通过分析堆栈跟踪，可以更直观地了解异常是在哪里发生的，以及调用链中的哪些方法可能导致了这个异常。<br><br>  ### 一般性解释<br><br>  堆栈跟踪的每一行 `at` 表示调用堆栈中的一个方法。堆栈跟踪从内到外显示方法调用顺序，最后一行通常是最外层方法，第一行是最内层方法（即异常实际抛出的地方）。<br><br>  ### 示例堆栈跟踪<br><br></code></pre></td></tr></table></figure>  plaintext复制代码System.OperationCanceledException: The operation was canceled.     at System.Threading.CancellationToken.ThrowOperationCanceledException()     at System.Threading.CancellationToken.ThrowIfCancellationRequested()     at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.ThrowException(SocketError error, CancellationToken cancellationToken)     at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.System.Threading.Tasks.Sources.IValueTaskSource&lt;System.Net.Sockets.Socket&gt;.GetResult(Int16 token)     at System.Net.Sockets.TcpListener.&lt;AcceptTcpClientAsync&gt;g__WaitAndWrap|32_0(ValueTask`1 task)     at FiTools.BridgeManager.Bridge.BeginTcpProxy() in C:\uzone\项目\2024\2024-01 山东港口集团日照港 智慧环保一期\代码\BridgeManager\Bridge.cs:line 75  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-section">### 分析堆栈跟踪</span><br><br><span class="hljs-bullet">1.</span> <span class="hljs-strong">**异常类型和消息**</span>：<br><br><span class="hljs-bullet">   -</span> <span class="hljs-code">`System.OperationCanceledException: The operation was canceled.`</span> 表示抛出了一个操作取消异常，通常由取消标记（<span class="hljs-code">`CancellationToken`</span>）引发。<br><br><span class="hljs-bullet">2.</span> <span class="hljs-strong">**堆栈跟踪行**</span>：<br><br><span class="hljs-bullet">   -</span> <span class="hljs-code">`at System.Threading.CancellationToken.ThrowOperationCanceledException()`</span> 表示异常在 <span class="hljs-code">`ThrowOperationCanceledException`</span> 方法中抛出。<br><br><span class="hljs-bullet">   -</span> 其他 <br><br></code></pre></td></tr></table></figure>       at       <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-code">          行表示调用链中的方法，依次为：</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">         -</span> <span class="hljs-code">`System.Threading.CancellationToken.ThrowIfCancellationRequested()`</span><br><span class="hljs-bullet">         -</span> <span class="hljs-code">`System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.ThrowException(SocketError error, CancellationToken cancellationToken)`</span><br><span class="hljs-bullet">         -</span> <span class="hljs-code">`System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.System.Threading.Tasks.Sources.IValueTaskSource&lt;System.Net.Sockets.Socket&gt;.GetResult(Int16 token)`</span><br><span class="hljs-bullet">         -</span> <span class="hljs-code">`System.Net.Sockets.TcpListener.&lt;AcceptTcpClientAsync&gt;g__WaitAndWrap|32_0(ValueTask`</span>1 task)`<br><span class="hljs-bullet">         -</span> <span class="hljs-code">`FiTools.BridgeManager.Bridge.BeginTcpProxy() in C:\uzone\项目\2024\2024-01 山东港口集团日照港 智慧环保一期\代码\BridgeManager\Bridge.cs:line 75`</span><br><br><span class="hljs-bullet">    3.</span> <span class="hljs-strong">**源代码位置**</span>：<br><br><span class="hljs-bullet">       -</span> 最后一行 <span class="hljs-code">`at FiTools.BridgeManager.Bridge.BeginTcpProxy() in C:\uzone\项目\2024\2024-01 山东港口集团日照港 智慧环保一期\代码\BridgeManager\Bridge.cs:line 75`</span> 提供了源代码文件的路径和行号，表明异常在 <span class="hljs-code">`Bridge.cs`</span> 文件的第 75 行发生。<br><br><span class="hljs-section">## 目前主流的编程语言的初衷是什么？它们的创造者现在如何评价它们？</span><br><br><span class="hljs-section">### 1. C</span><br><br><span class="hljs-strong">**创造者**</span>：丹尼斯·里奇（Dennis Ritchie）<br><span class="hljs-strong">**初衷**</span>：C语言是在1970年代早期由贝尔实验室的丹尼斯·里奇开发的，目的是为开发UNIX操作系统提供一种高效且灵活的语言。C语言继承了B语言的某些特性，并增加了类型系统以提高编程的安全性和表达能力。<br><span class="hljs-strong">**评价**</span>：丹尼斯·里奇认为，C语言成功地达到了他的目标，即提供了一种既接近硬件又适合高级程序设计的语言。它的简单性和效率使其成为系统编程和嵌入式编程的主流语言之一。<br><br><span class="hljs-section">### 2. Java</span><br><br><span class="hljs-strong">**创造者**</span>：詹姆斯·高斯林（James Gosling）<br><span class="hljs-strong">**初衷**</span>：Java语言最初于1990年代初在Sun Microsystems开发，目标是创建一种跨平台的编程语言，能够在不同的设备和操作系统上运行。Java的设计哲学是“写一次，运行到处”（Write Once, Run Anywhere），并且注重安全性和稳定性。<br><span class="hljs-strong">**评价**</span>：詹姆斯·高斯林对Java的评价是，它成功地实现了跨平台的目标，并成为了互联网时代的关键编程语言之一。尽管随着时间推移，Java面临了一些新的挑战和竞争，但其核心理念和影响力依然强大。<br><br><span class="hljs-section">### 3. Python</span><br><br><span class="hljs-strong">**创造者**</span>：吉多·范罗苏姆（Guido van Rossum）<br><span class="hljs-strong">**初衷**</span>：Python语言于1980年代末至1990年代初由吉多·范罗苏姆开发，目的是创建一种易于阅读和使用的编程语言，能够帮助程序员快速开发和调试代码。Python强调简洁和可读性，力求减少程序员的认知负担。<br><span class="hljs-strong">**评价**</span>：吉多·范罗苏姆对Python的发展表示满意，他认为Python在保持简单和易用的同时，已经发展成为一个功能强大的语言，广泛应用于数据科学、人工智能、Web开发等领域。<br><br><span class="hljs-section">### 4. JavaScript</span><br><br><span class="hljs-strong">**创造者**</span>：布兰登·艾克（Brendan Eich）<br><span class="hljs-strong">**初衷**</span>：JavaScript于1995年由布兰登·艾克在Netscape公司开发，目标是为Web浏览器添加一种轻量级的脚本语言，以便于处理用户交互和动态内容。JavaScript的设计注重简便和灵活性。<br><span class="hljs-strong">**评价**</span>：布兰登·艾克认为，尽管JavaScript起初面临许多批评和挑战，但它已经成长为一种重要的编程语言，推动了Web技术的发展。如今，JavaScript不仅在客户端编程中占据主导地位，还扩展到了服务器端（如Node.js）。<br><br><span class="hljs-section">### 5. C++</span><br><br><span class="hljs-strong">**创造者**</span>：比雅尼·斯特劳斯特鲁普（Bjarne Stroustrup）<br><span class="hljs-strong">**初衷**</span>：C++是在1980年代由比雅尼·斯特劳斯特鲁普开发的，目的是在C语言的基础上增加面向对象编程的特性，从而提高程序的模块化和可维护性。C++兼顾了系统编程的效率和高级程序设计的灵活性。<br><span class="hljs-strong">**评价**</span>：比雅尼·斯特劳斯特鲁普认为，C++成功地达到了他的设计目标，并且在工业界和学术界得到了广泛应用。他对C++的演变和持续发展表示欣慰，并认为它在现代软件开发中仍然具有重要地位。<br><br><span class="hljs-section">### 6. Ruby</span><br><br><span class="hljs-strong">**创造者**</span>：松本行弘（Yukihiro &quot;Matz&quot; Matsumoto）<br><span class="hljs-strong">**初衷**</span>：Ruby语言于1990年代中期由松本行弘开发，目标是创建一种简洁且强大的编程语言，使程序员在编程时感到愉悦和高效。Ruby融合了多种编程范式，强调优雅和简便。<br><span class="hljs-strong">**评价**</span>：松本行弘对Ruby的成功感到高兴，尤其是在Web开发领域（如Ruby on Rails的影响）。他认为Ruby实现了他当初的设计理念，让编程变得更有乐趣和创造性。<br><br><span class="hljs-section">### 7. Swift</span><br><br><span class="hljs-strong">**创造者**</span>：克里斯·拉特纳（Chris Lattner）<br><span class="hljs-strong">**初衷**</span>：Swift语言由克里斯·拉特纳在苹果公司主导开发，发布于2014年，目的是取代Objective-C，提供一种现代、安全、快速的编程语言，适用于iOS和macOS应用开发。Swift结合了现代编程语言的最佳特性，注重安全性和性能。<br><span class="hljs-strong">**评价**</span>：克里斯·拉特纳对Swift的评价非常正面，他认为Swift在简化开发过程、提高代码安全性和执行性能方面表现出色。Swift的快速普及和广泛应用表明它达到了预期的目标。<br><br>这些编程语言的创造者普遍认为，他们的语言在实现最初的设计目标方面取得了成功，并且在各自的应用领域内产生了深远的影响。尽管随着时间的推移，每种语言都面临新的挑战和竞争，但其核心理念和影响力依然显著。<br><br><br><br><span class="hljs-section">## Web浏览器是什么？</span><br><br><br><br><span class="hljs-section">## influxdb数据库是什么？它是一种类似于MySQL的东西还是像DBeaver一样可以使用多种数据库的工具？</span><br><br>InfluxDB是一种时序数据库（Time Series Database），专门设计用于处理高写入和查询性能的时间序列数据，如监控数据、传感器数据和物联网数据。它与传统的关系型数据库（如MySQL）不同，主要用于存储和查询按时间顺序排列的数据。<br><br>以下是关于InfluxDB的一些关键点：<br><br><span class="hljs-section">#### InfluxDB的特点</span><br><br><span class="hljs-bullet">1.</span> <span class="hljs-strong">**专为时间序列数据设计**</span>：InfluxDB优化了存储和查询时间序列数据，提供高效的写入和读取性能。<br><span class="hljs-bullet">2.</span> <span class="hljs-strong">**SQL类查询语言**</span>：使用InfluxQL或Flux（InfluxData自己的脚本语言）来执行复杂的查询。<br><span class="hljs-bullet">3.</span> <span class="hljs-strong">**无需预定义模式**</span>：你可以在运行时添加新的字段和标签，无需预定义数据库的模式。<br><span class="hljs-bullet">4.</span> <span class="hljs-strong">**高效的数据压缩和存储**</span>：支持数据的自动压缩和删除，优化存储空间的使用。<br><span class="hljs-bullet">5.</span> <span class="hljs-strong">**集成和扩展性**</span>：提供丰富的API和插件，可以与多种数据收集工具和可视化工具（如Grafana）集成。<br><br><span class="hljs-section">#### InfluxDB vs. MySQL</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**数据模型**</span>：MySQL是一个关系型数据库，采用表、行和列的模式，而InfluxDB是一个时序数据库，采用测量（measurement）、字段（field）和标签（tag）的模式。<br><span class="hljs-bullet">-</span> <span class="hljs-strong">**查询语言**</span>：MySQL使用SQL，InfluxDB使用InfluxQL或Flux。<br><span class="hljs-bullet">-</span> <span class="hljs-strong">**应用场景**</span>：MySQL适合传统的业务数据管理，如用户信息、订单记录等；InfluxDB更适合时间序列数据管理，如传感器数据、服务器监控数据等。<br><br><span class="hljs-section">#### InfluxDB vs. DBeaver</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**功能**</span>：InfluxDB是一个数据库系统，专门用于存储和处理时间序列数据。DBeaver则是一个数据库管理工具，可以连接和管理多种数据库系统，包括MySQL、PostgreSQL、SQLite、Oracle、SQL Server等。<br><span class="hljs-bullet">-</span> <span class="hljs-strong">**用途**</span>：InfluxDB用于存储和查询时序数据，而DBeaver用于数据库开发和管理工作，可以对多种数据库系统进行操作和查询。<br><br><span class="hljs-section">#### 使用场景</span><br><br>InfluxDB通常用于以下场景：<br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**监控和报警**</span>：服务器性能监控、应用程序监控、基础设施监控等。<br><span class="hljs-bullet">-</span> <span class="hljs-strong">**物联网（IoT）**</span>：传感器数据收集和分析。<br><span class="hljs-bullet">-</span> <span class="hljs-strong">**金融数据分析**</span>：股票价格、交易量等金融时间序列数据。<br><span class="hljs-bullet">-</span> <span class="hljs-strong">**工业数据**</span>：工业设备数据监控和预测维护。<br><br><span class="hljs-section">#### 示例</span><br><br>假设你在使用InfluxDB来存储服务器的CPU使用率数据，你可以用以下示例来展示如何插入和查询数据：<br><br><span class="hljs-strong">**写入数据**</span><br><br></code></pre></td></tr></table></figure></code></pre></li></ul><p>bash<br>复制代码<br>curl -i -XPOST ‘<a href="http://localhost:8086/write?db=mydb">http://localhost:8086/write?db=mydb</a>‘ –data-binary ‘cpu,host&#x3D;server01,region&#x3D;uswest value&#x3D;0.64’</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-strong">**查询数据**</span><br><br></code></pre></td></tr></table></figure><p>sql<br>复制代码<br>SELECT “value” FROM “cpu” WHERE “host” &#x3D; ‘server01’ AND “region” &#x3D; ‘uswest’</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>总的来说，InfluxDB是一个专门用于处理时间序列数据的数据库系统，而不是一个多数据库管理工具。它的设计和优化使其在处理大量时间序列数据时表现优异。<br><br>## 什么是构析函数（Destructor）？<br><br>析构函数是类的特殊方法，当对象被垃圾回收时调用。它用于清理资源（如关闭文件、释放内存）。析构函数的名称与类名相同，并且前面加上波浪号（`~`）。<br><br>#### 特点：<br><br>- 名称与类名相同，前面加上波浪号（`~`）。<br>- 没有参数和返回类型。<br>- 每个类最多只有一个析构函数，不能重载。<br>- 由垃圾回收器（GC）调用，不确定何时调用。<br><br>#### 示例：<br><br>```c#<br>public <span class="hljs-keyword">class</span> Resource<br>&#123;<br>    <span class="hljs-comment">// 析构函数</span><br>    ~Resource()<br>    &#123;<br>        <span class="hljs-comment">// 清理资源的代码</span><br>        Console.WriteLine(<span class="hljs-string">&quot;Destructor called&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="什么是OPC-UA"><a href="#什么是OPC-UA" class="headerlink" title="什么是OPC UA"></a>什么是OPC UA</h2><p>OPC UA（OPC Unified Architecture）是一个独立于平台、面向服务、开放和安全的通信架构。它被设计用来实现不同供应商的工业自动化设备、系统和软件应用之间的互操作性3。OPC UA信息模型定义了使用各种传输协议交换数据的编码规格3。</p><p>OPC UA的主要特点包括：</p><ol><li><strong>功能对等性</strong>：所有COM OPC Classic规范都映射到UA，包含数据访问、报警和事件以及历史数据访问等功能3。</li><li><strong>平台独立性</strong>：OPC UA可在从嵌入式微控制器到基于云的基础设施的任何平台上部署使用，不依赖于特定的操作系统或硬件平台23。</li><li><strong>安全性</strong>：提供信息加密、身份认证和审核等安全特性，确保数据传输的安全性23。</li><li><strong>可扩展性</strong>：能够添加新功能而不影响现有应用程序，支持新技术和方法的集成2。</li><li><strong>信息模型完整性</strong>：OPC UA信息建模框架将数据转换为信息，支持复杂信息的建模和扩展2。</li></ol><p>OPC UA广泛应用于工业自动化和物联网领域，如数据收集、设备集成、远程监控、历史数据访问等3。此外，OPC UA还支持发布&#x2F;订阅（PubSub）机制，允许通过不同的协议推送数据3。</p><h2 id="什么是执行器"><a href="#什么是执行器" class="headerlink" title="什么是执行器"></a>什么是执行器</h2><p>在软件开发中，<strong>执行器 (Executor)</strong> 通常是一个负责执行特定任务或操作的组件。执行器可以是一个函数、方法、脚本或任何能够执行特定逻辑的代码段。它通常与触发器结合使用，触发器负责监控某些条件或事件，当这些条件满足时，触发器会调用执行器来执行相应的操作。</p><h2 id="正则表达式的语法是什么样的？"><a href="#正则表达式的语法是什么样的？" class="headerlink" title="正则表达式的语法是什么样的？"></a>正则表达式的语法是什么样的？</h2><p>正则表达式由普通字符（例如字母和数字）和特殊字符组成。特殊字符包括：</p><ul><li><code>.</code>：点字符可以匹配任何单个字符（除了换行符）。</li><li><code>*</code>：星号表示前面的元素可以出现零次或多次。</li><li><code>+</code>：加号表示前面的元素至少出现一次。</li><li><code>?</code>：问号表示前面的元素可以出现零次或一次。</li><li><code>[]</code>：方括号定义一个字符集合，匹配其中的任意一个字符。</li><li><code>()</code>：圆括号用于分组，也用于捕获匹配的文本。</li><li><code>|</code>：竖线表示逻辑“或”，匹配两个或多个选项中的一个。</li><li><code>\d</code>：匹配任意数字，等同于 <code>[0-9]</code>。</li><li><code>\w</code>：匹配任意字母数字字符，包括下划线。</li><li><code>\s</code>：匹配任何空白字符（空格、制表符、换行符等）。</li></ul><h2 id="什么是程序设计的开闭原则？"><a href="#什么是程序设计的开闭原则？" class="headerlink" title="什么是程序设计的开闭原则？"></a>什么是程序设计的开闭原则？</h2><p>开闭原则（Open&#x2F;Closed Principle, OCP）是面向对象编程中的一个重要原则，它是SOLID设计原则中的第一个原则。开闭原则的核心思想是：软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。这意味着设计时应该使软件实体能够容易地扩展新功能，而不需要修改现有的代码。</p><p>具体来说，开闭原则包含以下几个要点：</p><ol><li><strong>对扩展开放</strong>：当需要增加新功能时，应该能够通过添加新的代码来实现，而不是修改现有的代码。</li><li><strong>对修改关闭</strong>：现有的代码应该是稳定的，不应该因为添加新功能而需要修改已有的代码。</li></ol><p>开闭原则的实现通常依赖于以下几个设计模式：</p><ul><li><strong>抽象</strong>：定义抽象层，使得扩展可以在不修改现有代码的情况下进行。</li><li><strong>多态</strong>：通过多态机制，可以在运行时根据对象的实际类型来调用相应的方法，从而实现功能的扩展。</li><li><strong>接口</strong>：使用接口来定义系统的契约，通过实现不同的接口来扩展功能。</li><li><strong>装饰者模式</strong>：允许用户在不修改对象结构的情况下，动态地给对象添加额外的职责。</li><li><strong>工厂模式</strong>：使用工厂模式来创建对象，可以在不修改现有代码的情况下增加新的对象类型。</li></ul><p>遵循开闭原则可以提高代码的可维护性和可扩展性，同时也有助于降低软件的复杂度和开发成本。</p><h2 id="什么是SOLID设计原则？"><a href="#什么是SOLID设计原则？" class="headerlink" title="什么是SOLID设计原则？"></a>什么是SOLID设计原则？</h2><p>SOLID设计原则是面向对象编程中的五个基本原则，它们提供了一种设计高质量软件的方法论。这些原则相互独立但又相互关联，共同指导开发者创建易于维护、扩展和理解的软件系统。以下是SOLID原则的简要介绍：</p><ol><li><p><strong>单一职责原则（Single Responsibility Principle, SRP）</strong>：</p><ul><li>一个类应该只有一个引起它变化的原因，即一个类只负责一项职责。</li></ul></li><li><p><strong>开闭原则（Open&#x2F;Closed Principle, OCP）</strong>：</p><ul><li>类应该对扩展开放，对修改关闭。这意味着设计时应该使软件实体能够容易地扩展新功能，而不需要修改现有的代码。</li></ul></li><li><p><strong>里氏替换原则（Liskov Substitution Principle, LSP）</strong>：</p><ul><li>子类对象必须能够替换掉它们的父类对象，并且不破坏系统的正确性。即基类可以被子类无缝替换，而不影响程序的行为。</li></ul></li><li><p><strong>接口隔离原则（Interface Segregation Principle, ISP）</strong>：</p><ul><li>不应该强迫客户依赖于它们不使用的方法。一个类不应该依赖于它不使用的接口，应该将大的接口拆分成小的、特定的接口。</li></ul></li><li><p><strong>依赖倒置原则（Dependency Inversion Principle, DIP）</strong>：</p><ul><li>高层模块不应该依赖于低层模块，两者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。</li></ul></li></ol><p>SOLID设计原则帮助开发者避免设计上的常见错误，比如过度耦合和脆弱的代码，从而提高代码的可维护性、可扩展性和可测试性。这些原则并不总是需要同时应用，而是根据具体情况灵活运用。</p><h2 id="什么是生成叙事？"><a href="#什么是生成叙事？" class="headerlink" title="什么是生成叙事？"></a>什么是生成叙事？</h2><p>你在游戏里和别的玩家交互，你被K了头，这个就是生成叙事。它是多人游戏特有的。</p><h2 id="ConcurrentDictionary是啥？"><a href="#ConcurrentDictionary是啥？" class="headerlink" title="ConcurrentDictionary是啥？"></a>ConcurrentDictionary是啥？</h2><p><code>ConcurrentDictionary</code> 是 .NET 中的一个线程安全的字典实现，属于 <code>System.Collections.Concurrent</code> 命名空间。它允许多个线程同时读写字典，而不需要额外的同步机制，因为它内部使用了细粒度锁定和其他并发控制技术来确保操作的原子性和线程安全。</p><p><code>ConcurrentDictionary</code> 提供了与 <code>Dictionary&lt;TKey,TValue&gt;</code> 类似的功能，但它更适合在高并发环境中使用。它支持以下特性：</p><ul><li><strong>线程安全</strong>：多个线程可以同时访问字典进行读取或更新操作，而不会互相干扰。</li><li><strong>高性能</strong>：通过减少锁定的粒度，<code>ConcurrentDictionary</code> 可以提供比传统的 <code>Dictionary</code> 更好的并发性能。</li><li><strong>灵活性</strong>：提供了多种添加、删除和查找元素的方法，包括返回默认值的选项，如果键不存在。</li><li><strong>扩展性</strong>：可以与其他并发集合一起使用，以构建复杂的并发数据结构。</li></ul><p>使用 <code>ConcurrentDictionary</code> 时，你不需要手动锁定字典的各个部分，因为 <code>ConcurrentDictionary</code> 已经为你管理了这些细节。这使得它成为多线程应用程序中的首选数据结构之一，特别是当你需要在多个线程之间共享和修改数据时。</p><h2 id="sortedset是什么类型？"><a href="#sortedset是什么类型？" class="headerlink" title="sortedset是什么类型？"></a>sortedset是什么类型？</h2><p><code>SortedSet&lt;T&gt;</code> 是 .NET 中的一个集合类型，属于 <code>System.Collections.Generic</code> 命名空间。它是一个基于红黑树的有序集合，提供了线程安全的添加、删除和搜索操作。以下是 <code>SortedSet&lt;T&gt;</code> 的一些关键特性：</p><ol><li><p><strong>有序性</strong>：<code>SortedSet&lt;T&gt;</code> 保证其中的元素按照特定的顺序排列。默认情况下，元素按照其自然排序顺序（即 <code>IComparable&lt;T&gt;</code> 接口定义的顺序）进行排序。如果元素类型不实现 <code>IComparable&lt;T&gt;</code>，或者你希望使用不同的排序方式，可以通过提供一个 <code>IComparer&lt;T&gt;</code> 实现来指定自定义的排序逻辑。</p></li><li><p><strong>唯一性</strong>：<code>SortedSet&lt;T&gt;</code> 中的元素是唯一的。如果尝试添加一个已经存在于集合中的元素，该元素不会被重复添加。</p></li><li><p><strong>效率</strong>：红黑树的实现确保了 <code>SortedSet&lt;T&gt;</code> 提供了高效的元素添加、删除和搜索操作。例如，添加、删除和查找操作通常都是对数时间复杂度（O(log n)）。</p></li><li><p><strong>范围查询</strong>：<code>SortedSet&lt;T&gt;</code> 支持高效的范围查询，可以快速找到在指定范围内的所有元素。</p></li><li><p><strong>并集、交集和差集操作</strong>：<code>SortedSet&lt;T&gt;</code> 提供了方便的方法来执行集合的并集、交集和差集操作。</p></li><li><p><strong>线程安全</strong>：虽然 <code>SortedSet&lt;T&gt;</code> 本身不是线程安全的，但是可以通过使用 <code>ConcurrentBag&lt;T&gt;</code> 或者通过外部同步机制来确保线程安全。</p></li></ol><p><code>SortedSet&lt;T&gt;</code> 适用于需要有序集合且元素唯一性的场景，例如，存储一组唯一项并保持它们有序，或者实现某些算法（如集合操作、范围搜索等）。</p><h2 id="Hashset不是一个键值对，而是一种用哈希表实现的便于查询的集合？"><a href="#Hashset不是一个键值对，而是一种用哈希表实现的便于查询的集合？" class="headerlink" title="Hashset不是一个键值对，而是一种用哈希表实现的便于查询的集合？"></a>Hashset不是一个键值对，而是一种用哈希表实现的便于查询的集合？</h2><p>是的，您的理解是正确的。<code>HashSet&lt;T&gt;</code> 不是键值对集合，而是一种基于哈希表实现的集合，它主要用于存储不重复的元素。以下是 <code>HashSet&lt;T&gt;</code> 的一些关键特性：</p><ol><li><p><strong>元素唯一性</strong>：<code>HashSet&lt;T&gt;</code> 保证所有元素都是唯一的。如果尝试添加一个已经存在的元素，该元素不会被添加到集合中。</p></li><li><p><strong>基于哈希表</strong>：<code>HashSet&lt;T&gt;</code> 的内部实现基于哈希表，这意味着它使用元素的哈希码来快速定位元素，从而提供高效的查找、插入和删除操作。</p></li><li><p><strong>无序性</strong>：与 <code>Dictionary&lt;TKey, TValue&gt;</code> 不同，<code>HashSet&lt;T&gt;</code> 不保证元素的顺序。元素的添加和遍历顺序可能与元素的实际存储顺序不同。</p></li><li><p><strong>高效操作</strong>：<code>HashSet&lt;T&gt;</code> 提供平均常数时间复杂度（O(1)）的添加、删除和查找操作。</p></li><li><p><strong>不包含键值对</strong>：与字典不同，<code>HashSet&lt;T&gt;</code> 只存储单一类型的元素，不包含键值对结构。每个元素既是键也是值。</p></li><li><p><strong>线程安全性</strong>：<code>HashSet&lt;T&gt;</code> 本身不是线程安全的。如果需要在多线程环境中使用，需要采取额外的同步措施。</p></li><li><p><strong>遍历能力</strong>：<code>HashSet&lt;T&gt;</code> 可以很容易地使用 <code>foreach</code> 循环进行遍历，因为 <code>IEnumerable&lt;T&gt;</code> 接口提供了迭代集合元素的能力。</p></li><li><p><strong>迭代器接口</strong>：<code>HashSet&lt;T&gt;</code> 实现了 <code>IEnumerable&lt;T&gt;</code> 和 <code>IEnumerable</code> 接口。这些接口要求实现一个名为 <code>GetEnumerator</code> 的方法，该方法返回一个实现了 <code>IEnumerator&lt;T&gt;</code> 或 <code>IEnumerator</code> 的对象。</p></li><li><p><strong>封装内部结构</strong>：<code>GetEnumerator</code> 方法封装了 <code>HashSet&lt;T&gt;</code> 的内部结构和元素的检索逻辑，使得用户无需了解哈希表的工作原理，就可以遍历集合中的所有元素。</p></li><li><p><strong>类型安全</strong>：由于 <code>HashSet&lt;T&gt;</code> 是泛型集合，它可以确保存储的元素类型是一致的。当你使用 <code>foreach</code> 遍历时，你可以直接声明变量 <code>a</code> 的类型为 <code>string</code>（如果 <code>HashSet&lt;T&gt;</code> 存储的是 <code>string</code> 类型的元素），并且知道 <code>foreach</code> 循环中的每个元素都将是 <code>string</code> 类型。</p></li><li><p><strong>性能</strong>：尽管 <code>HashSet&lt;T&gt;</code> 是基于哈希表实现的，但 <code>foreach</code> 遍历的性能通常与元素的数量成正比，而不是与哈希表的大小或复杂性成正比。这意味着即使哈希表很大，遍历集合的速度也很快。</p></li></ol><p><code>HashSet&lt;T&gt;</code> 非常适合用于需要快速查找和确保元素唯一性的场景，例如去重、集合操作（并集、交集、差集）等。</p><h2 id="什么是离岸公司"><a href="#什么是离岸公司" class="headerlink" title="什么是离岸公司"></a>什么是离岸公司</h2><p>离岸公司（Offshore Company）是指在特定的被称为离岸法区的国家和地区内成立的有限责任公司或股份有限公司，而这些公司并不在其注册地进行实质业务活动。这些地区通常是一些岛国，它们通过制定宽松的经济区域政策和公司法来吸引国际投资和注册公司，提供税收优惠、高度的商业隐私和保密性、以及外汇自由等优势。</p><p>离岸公司的主要特点包括：</p><ul><li>高度的保密性：股东资料、股权比例、收益状况等信息享有保密权利，通常不对外公开。</li><li>税收优惠：与一般公司相比，离岸公司通常只需支付年度管理费，而不需要缴纳其他税款，或享受其他税收减免政策。</li><li>外汇自由：资金转移没有太多限制，便于进行国际资金流动和交易。</li><li>法律环境宽松：离岸法区通常提供宽松的法律环境，有利于公司运营和资本运作。</li><li>运营地分离：离岸公司的注册地和实际经营地是分离的，它们主要在注册地以外的地区进行业务活动。</li></ul><p>常见的离岸法区包括英属维尔京群岛（BVI）、开曼群岛、巴哈马群岛、塞舌尔群岛、新加坡、香港等。这些地区因其政策优势，成为全球企业进行国际业务、资本运作和税务筹划的热门选择。</p><h2 id="MySQL安装过程中提到的两个数据库是什么？"><a href="#MySQL安装过程中提到的两个数据库是什么？" class="headerlink" title="MySQL安装过程中提到的两个数据库是什么？"></a>MySQL安装过程中提到的两个数据库是什么？</h2><h3 id="Sakila-数据库"><a href="#Sakila-数据库" class="headerlink" title="Sakila 数据库"></a>Sakila 数据库</h3><ul><li><strong>简介</strong>：Sakila 是一个电影租赁店的数据库。它的设计用于展示复杂的 SQL 查询和数据库功能。</li><li><strong>内容</strong>：包括表格如电影、演员、库存、客户和租赁记录等。</li><li><strong>用途</strong>：适用于学习和演示如何处理更复杂的关系数据库操作，例如多表连接、子查询、触发器、存储过程和视图等。</li></ul><h3 id="World-数据库"><a href="#World-数据库" class="headerlink" title="World 数据库"></a>World 数据库</h3><ul><li><strong>简介</strong>：World 数据库包含有关世界国家、城市和语言的地理和人口统计数据。</li><li><strong>内容</strong>：包括三个主要表：国家（country）、城市（city）和国家语言（countrylanguage）。</li><li><strong>用途</strong>：适用于进行简单的查询和数据操作，了解基本的数据库操作，例如选择、插入、更新和删除等。</li></ul><h3 id="下载和安装"><a href="#下载和安装" class="headerlink" title="下载和安装"></a>下载和安装</h3><p>这两个数据库可以从 MySQL 官方网站下载，并通过 MySQL Workbench 或命令行工具导入到你的 MySQL 服务器中。</p><h3 id="示例用途"><a href="#示例用途" class="headerlink" title="示例用途"></a>示例用途</h3><ul><li><strong>教育和学习</strong>：帮助学生和初学者了解如何设计和操作数据库。</li><li><strong>测试和开发</strong>：开发者可以使用这些数据进行功能测试和应用开发。</li><li><strong>查询示例</strong>：提供一系列示例查询，展示如何使用 SQL 进行数据操作和分析。</li></ul><h3 id="官方资源"><a href="#官方资源" class="headerlink" title="官方资源"></a>官方资源</h3><ul><li><a href="https://dev.mysql.com/doc/sakila/en/">Sakila 数据库文档</a></li><li><a href="https://dev.mysql.com/doc/index-other.html">World 数据库文档</a></li></ul><p>这些数据库为学习和演示 MySQL 的各种功能提供了良好的起点。</p><h1 id="进程间通信的方式都有什么？"><a href="#进程间通信的方式都有什么？" class="headerlink" title="进程间通信的方式都有什么？"></a>进程间通信的方式都有什么？</h1><ol><li><strong>管道（Pipes）</strong>：允许一个进程与另一个进程进行单向通信。</li><li><strong>命名管道（Named Pipes）</strong>：类似于管道，但是可以在不相关的进程之间进行通信。</li><li><strong>消息队列（Message Queues）</strong>：允许进程发送和接收消息。</li><li><strong>共享内存（Shared Memory）</strong>：允许多个进程访问同一块内存区域。</li><li><strong>套接字（Sockets）</strong>：支持进程在网络中的通信。</li><li><strong>信号（Signals）</strong>：是一种简单的通信方式，用于发送通知。</li><li><strong>信号量（Semaphores）</strong>：用于控制对共享资源的访问。</li><li><strong>文件映射（Memory-mapped Files）</strong>：将文件内容映射到内存中，允许多个进程通过读写文件来通信。</li></ol><h1 id="接口和抽象类的区别到底是啥？有的编程语言抽象类不能多继承吗？所有编程语言都支持接口多继承？接口的多继承就是所谓的优先使用组合而非继承？"><a href="#接口和抽象类的区别到底是啥？有的编程语言抽象类不能多继承吗？所有编程语言都支持接口多继承？接口的多继承就是所谓的优先使用组合而非继承？" class="headerlink" title="接口和抽象类的区别到底是啥？有的编程语言抽象类不能多继承吗？所有编程语言都支持接口多继承？接口的多继承就是所谓的优先使用组合而非继承？"></a>接口和抽象类的区别到底是啥？有的编程语言抽象类不能多继承吗？所有编程语言都支持接口多继承？接口的多继承就是所谓的优先使用组合而非继承？</h1><p>抽象类是一种可以支持实现一定方法并继承的接口</p><h1 id="NTP是啥"><a href="#NTP是啥" class="headerlink" title="NTP是啥"></a>NTP是啥</h1><p>NTP，即网络时间协议（Network Time Protocol），是一种用于同步网络中所有系统时钟以使用同一时间的协议。它确保了计算机系统之间的时间同步，这对于很多应用和服务来说是非常重要的，比如日志记录、数据库同步、网络安全协议等。</p><p>NTP 包括协议本身以及在网络计算机上运行的客户端和服务器程序。NTP 服务器可以安装在服务器上，而客户端程序可以安装在需要时间同步的任何计算机上。</p><p>要在服务器上安装 NTP 服务器程序，你可以按照以下步骤进行：</p><ol><li>更新系统软件包：<code>sudo apt update -y</code></li><li>安装 NTP 服务器：<code>sudo apt install ntp</code></li><li>（可选）验证安装：<code>sntp --version</code></li><li>配置 NTP 服务器使用最近的 NTP 服务器池，这通常通过编辑 <code>/etc/ntp.conf</code> 文件来完成，并添加或更改服务器池的地址。</li></ol><p>在 Ubuntu 系统上，一旦 NTP 服务器安装并配置好，你可以配置 NTP 客户端来与服务器同步时间。这可以通过安装 <code>ntpdate</code> 程序来实现，并确保客户端能够通过修改 <code>/etc/hosts</code> 文件来解析 NTP 服务器的主机名。</p><p>此外，如果 NTP 服务器需要从外部时间源获取时间，可以通过配置防火墙规则来允许传入的 NTP 流量，通常是在 UDP 端口 123 上。</p><p>总的来说，NTP 是确保网络中计算机时间一致性的关键工具，通过在服务器上安装 NTP 服务并在客户端上进行相应的配置，可以轻松实现时间的同步。</p><h1 id="extern-partial字段都是什么意思？为什么他俩和abstract字段标记可以没有方法主体？"><a href="#extern-partial字段都是什么意思？为什么他俩和abstract字段标记可以没有方法主体？" class="headerlink" title="extern,partial字段都是什么意思？为什么他俩和abstract字段标记可以没有方法主体？"></a>extern,partial字段都是什么意思？为什么他俩和abstract字段标记可以没有方法主体？</h1><h1 id="回调函数是啥？有什么用？"><a href="#回调函数是啥？有什么用？" class="headerlink" title="回调函数是啥？有什么用？"></a>回调函数是啥？有什么用？</h1><h3 id="什么是回调函数？"><a href="#什么是回调函数？" class="headerlink" title="什么是回调函数？"></a><strong>什么是回调函数？</strong></h3><p>回调函数（Callback Function）是一种编程技术，是指将一个函数作为参数传递给另一个函数，当某些特定事件发生或某个操作完成时，由这个函数（即回调函数）被调用，从而实现动态执行逻辑。</p><p>通俗地讲，回调函数就像是一种“预约机制”，你告诉某个函数：“一旦发生某件事情，记得调用我传给你的这个函数。”</p><hr><h3 id="回调函数的特点"><a href="#回调函数的特点" class="headerlink" title="回调函数的特点"></a><strong>回调函数的特点</strong></h3><ol><li><strong>延迟执行</strong>：回调函数不是立即执行，而是在某个事件发生或条件满足后才被调用。</li><li><strong>动态行为</strong>：主函数的行为可以根据传入的回调函数不同而发生变化。</li><li><strong>解耦设计</strong>：通过回调函数，可以将主逻辑与特定行为分离，增强代码的可扩展性。</li></ol><hr><h3 id="回调函数的应用场景"><a href="#回调函数的应用场景" class="headerlink" title="回调函数的应用场景"></a><strong>回调函数的应用场景</strong></h3><ol><li><p>异步操作</p><p>：</p><ul><li>例如文件读取完成后，通知用户数据已经准备好。</li></ul></li><li><p>事件驱动编程</p><p>：</p><ul><li>鼠标点击、按键触发等。</li></ul></li><li><p>算法设计</p><p>：</p><ul><li>例如排序算法中自定义比较逻辑。</li></ul></li><li><p>框架与库设计</p><p>：</p><ul><li>通过回调函数，用户可以在库函数执行时插入自己的逻辑。</li></ul></li></ol><hr><h3 id="C-中的回调函数实现"><a href="#C-中的回调函数实现" class="headerlink" title="C# 中的回调函数实现"></a><strong>C# 中的回调函数实现</strong></h3><p>在 C# 中，回调函数通常通过以下三种方式实现：</p><ol><li><strong>委托（Delegate）</strong></li><li><strong>匿名函数（Anonymous Method）和 Lambda 表达式</strong></li><li><strong>接口（Interface）</strong></li></ol><hr><h4 id="1-使用委托实现回调"><a href="#1-使用委托实现回调" class="headerlink" title="1. 使用委托实现回调"></a><strong>1. 使用委托实现回调</strong></h4><p>委托是 C# 中的一个类型，用于封装方法。它是实现回调函数最常见的方式。</p><p><strong>示例：用委托实现简单回调</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-comment">// 定义一个委托</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CallbackDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>;<br><br>    <span class="hljs-comment">// 主函数：接受回调函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoSomething</span>(<span class="hljs-params">CallbackDelegate callback</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;开始执行操作...&quot;</span>);<br>        <span class="hljs-comment">// 模拟操作完成后调用回调函数</span><br>        callback(<span class="hljs-string">&quot;操作已完成！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 定义回调函数</span><br>        CallbackDelegate myCallback = (message) =&gt; Console.WriteLine(<span class="hljs-string">$&quot;回调消息：<span class="hljs-subst">&#123;message&#125;</span>&quot;</span>);<br><br>        <span class="hljs-comment">// 将回调函数传递给主函数</span><br>        DoSomething(myCallback);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong>：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang">开始执行操作...<br>回调消息：操作已完成！<br></code></pre></td></tr></table></figure><hr><h4 id="2-使用匿名方法或-Lambda-表达式实现回调"><a href="#2-使用匿名方法或-Lambda-表达式实现回调" class="headerlink" title="2. 使用匿名方法或 Lambda 表达式实现回调"></a><strong>2. 使用匿名方法或 Lambda 表达式实现回调</strong></h4><p>在 C# 中，匿名方法和 Lambda 表达式可以用作回调函数，语法更简洁。</p><p><strong>示例：用 Lambda 表达式实现回调</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CallbackDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoSomething</span>(<span class="hljs-params">CallbackDelegate callback</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;执行一些操作...&quot;</span>);<br>        callback(<span class="hljs-string">&quot;操作完成，Lambda 表达式回调成功！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 使用 Lambda 表达式直接传递回调</span><br>        DoSomething((message) =&gt; Console.WriteLine(<span class="hljs-string">$&quot;回调消息：<span class="hljs-subst">&#123;message&#125;</span>&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="3-使用接口实现回调"><a href="#3-使用接口实现回调" class="headerlink" title="3. 使用接口实现回调"></a><strong>3. 使用接口实现回调</strong></h4><p>通过接口实现回调是一种面向对象的方式，通常用于设计更复杂的场景。</p><p><strong>示例：用接口实现回调</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title">ICallback</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnComplete</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ICallback _callback;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Worker</span>(<span class="hljs-params">ICallback callback</span>)</span><br>    &#123;<br>        _callback = callback;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoWork</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;正在工作...&quot;</span>);<br>        <span class="hljs-comment">// 模拟工作完成后调用回调</span><br>        _callback.OnComplete(<span class="hljs-string">&quot;工作完成，接口回调成功！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span> : <span class="hljs-title">ICallback</span><br>&#123;<br>    <span class="hljs-comment">// 实现回调接口</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnComplete</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;回调收到消息：<span class="hljs-subst">&#123;message&#125;</span>&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 创建回调实现类</span><br>        Program program = <span class="hljs-keyword">new</span> Program();<br><br>        <span class="hljs-comment">// 创建 Worker 并传入回调</span><br>        Worker worker = <span class="hljs-keyword">new</span> Worker(program);<br><br>        <span class="hljs-comment">// 执行任务</span><br>        worker.DoWork();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong>：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang">正在工作...<br>回调收到消息：工作完成，接口回调成功！<br></code></pre></td></tr></table></figure><hr><h4 id="4-使用-Action-和-Func-简化回调"><a href="#4-使用-Action-和-Func-简化回调" class="headerlink" title="4. 使用 Action 和 Func 简化回调"></a><strong>4. 使用 <code>Action</code> 和 <code>Func</code> 简化回调</strong></h4><p>在 C# 中，<code>Action</code> 和 <code>Func</code> 是内置的委托类型，通常用于更简洁的回调函数定义。</p><p><strong>示例：使用 <code>Action</code> 实现回调</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoSomething</span>(<span class="hljs-params">Action&lt;<span class="hljs-built_in">string</span>&gt; callback</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;操作进行中...&quot;</span>);<br>        callback(<span class="hljs-string">&quot;使用 Action 进行回调&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        DoSomething((message) =&gt; Console.WriteLine(<span class="hljs-string">$&quot;回调消息：<span class="hljs-subst">&#123;message&#125;</span>&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>示例：使用 <code>Func</code> 实现回调</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Execute</span>(<span class="hljs-params">Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; operation</span>)</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> result = operation(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;计算结果：<span class="hljs-subst">&#123;result&#125;</span>&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 使用 Func 定义回调</span><br>        Execute((x, y) =&gt; x + y);  <span class="hljs-comment">// 输出：计算结果：30</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul><li><strong>回调函数</strong>是通过动态传递逻辑来实现程序灵活性和解耦的重要工具。</li><li>在 C# 中，回调函数可以通过委托、Lambda 表达式、接口等方式实现。</li><li><code>Action</code> 和 <code>Func</code> 提供了更加简洁的回调机制，非常适合现代开发场景。</li><li>根据需求选择合适的实现方式，委托适合简单场景，接口适合复杂设计，而 <code>Action</code> 和 <code>Func</code> 更加高效便捷。</li></ul><h1 id="委托是个什么设定？"><a href="#委托是个什么设定？" class="headerlink" title="委托是个什么设定？"></a>委托是个什么设定？</h1><p>虽然委托一开始创建的时候是要传入一个函数的，但并不一定的不空的，如果空的话可以直接&#x3D;&#x3D;null的</p><h1 id="RESTful-Web-API-是什么？"><a href="#RESTful-Web-API-是什么？" class="headerlink" title="RESTful Web API 是什么？"></a>RESTful Web API 是什么？</h1><p>RESTful Web API（Representational State Transferful Web API）是一种基于REST（Representational State Transfer，表现层状态转移）原则构建的Web API，它定义了客户端和服务器之间交互数据的方式。REST是一种软件架构风格，用于设计网络应用程序，使得它们可以通过标准的HTTP协议进行通信。</p><p>RESTful Web API 通常具有以下特点：</p><ol><li><p><strong>无状态（Stateless）</strong>：每个请求从客户端到服务器都包含所有必要的信息来理解和处理请求。服务器不会存储任何客户端请求之间的信息。</p></li><li><p><strong>统一接口（Uniform Interface）</strong>：通过定义一组标准的HTTP方法（如GET、POST、PUT、DELETE等），客户端可以对资源进行操作。</p></li><li><p><strong>可缓存（Cacheable）</strong>：数据被标记为可缓存或不可缓存。如果数据是可缓存的，客户端可以存储数据副本以提高性能。</p></li><li><p><strong>分层系统（Layered System）</strong>：客户端通常不知道它们是直接与服务器通信，还是与中间层（如代理、网关）通信。</p></li><li><p><strong>通过超媒体作为应用状态的引擎（HATEOAS）</strong>：API应该提供足够的信息，使得用户可以发现下一步可以执行的操作。</p></li></ol><p>在RESTful Web API中，资源（如用户、产品、文章等）通过URI（统一资源标识符）进行标识，并且通过HTTP方法进行操作：</p><ul><li><strong>GET</strong>：用于检索资源。</li><li><strong>POST</strong>：用于创建新资源。</li><li><strong>PUT</strong>：用于更新现有资源。</li><li><strong>DELETE</strong>：用于删除资源。</li></ul><p>RESTful Web API的设计使得它们易于理解和使用，同时也便于与其他基于HTTP的应用程序集成。这种API风格在现代Web开发中非常流行，因为它简单、灵活且易于扩展。</p><h1 id="什么是强类型语法？"><a href="#什么是强类型语法？" class="headerlink" title="什么是强类型语法？"></a>什么是强类型语法？</h1><h1 id="抽象类和接口的区别是什么？"><a href="#抽象类和接口的区别是什么？" class="headerlink" title="抽象类和接口的区别是什么？"></a>抽象类和接口的区别是什么？</h1><p>接口只规定不实现，抽象类可以实现，而且还带访问封装，接口没有封装。</p><p>设计理念<br>接口的设计理念：<br>•契约导向：接口强调的是行为契约，任何实现接口的类都必须提供接口中定义的方法。<br>•解耦和灵活性：接口使得代码更加解耦和灵活，便于单元测试和依赖注入。<br>抽象类的设计理念：<br>•代码复用：抽象类允许在基类中提供一些默认的实现，从而减少代码重复。<br>•层次结构：抽象类适用于具有层次结构的场景，提供了一种在基类和派生类之间共享代码的方式。<br>选择指南<br>•使用接口：当你需要定义一组不相关类的共同行为，或者需要实现多重继承时。<br>•使用抽象类：当你需要为一组相关类提供一个共同的基类，并且希望在基类中提供一些默认的实现时。</p><h1 id="所谓的便携wifi实际上是对手机热点功能的一种模拟？还是说是反过来的-手机热点功能是对便携wifi功能的一种模拟"><a href="#所谓的便携wifi实际上是对手机热点功能的一种模拟？还是说是反过来的-手机热点功能是对便携wifi功能的一种模拟" class="headerlink" title="所谓的便携wifi实际上是对手机热点功能的一种模拟？还是说是反过来的?手机热点功能是对便携wifi功能的一种模拟?"></a>所谓的便携wifi实际上是对手机热点功能的一种模拟？还是说是反过来的?手机热点功能是对便携wifi功能的一种模拟?</h1><p>便携 WiFi 和手机热点功能的核心原理确实相似，但从发展历史上来看，是手机热点功能对便携 WiFi 的一种模拟。</p><h3 id="便携-WiFi（独立设备）的发展在前"><a href="#便携-WiFi（独立设备）的发展在前" class="headerlink" title="便携 WiFi（独立设备）的发展在前"></a>便携 WiFi（独立设备）的发展在前</h3><p>便携 WiFi（例如 MiFi 设备）通常是一个独立的硬件设备，内置了 SIM 卡槽，能够直接连接移动运营商的网络，并将此连接通过 WiFi 分享给其他设备。早期的便携 WiFi 是设计用来为笔记本电脑、平板等设备提供互联网连接，最早的便携 WiFi 距今已有十多年历史。</p><h3 id="手机热点功能的出现"><a href="#手机热点功能的出现" class="headerlink" title="手机热点功能的出现"></a>手机热点功能的出现</h3><p>随着智能手机的发展和移动互联网的普及，手机具备了较强的处理能力并支持移动数据连接，因此将手机变为“便携 WiFi”成为了可能。手机热点功能就是利用手机内置的 WiFi 模块，将移动网络共享给其他设备。这个功能可以看作对便携 WiFi 的一种“模拟”，因为它在原理上是类似的：连接移动网络并创建 WiFi 热点供其他设备连接。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>虽然两者的实现方式略有不同，但本质上手机热点是在模仿便携 WiFi 的工作方式，提供了一种便捷的解决方案。</p><h1 id="多个点的质心或者说中心点有什么特性"><a href="#多个点的质心或者说中心点有什么特性" class="headerlink" title="多个点的质心或者说中心点有什么特性"></a>多个点的质心或者说中心点有什么特性</h1><p>质心（centroid）或中心点是指多个点的 “平均位置”。在几何学和物理学中，质心是一个集合的质量中心，对于一组给定的点，它是所有点的加权平均位置。如果这些点在同一平面或空间中，质心就是这些点坐标的平均值。</p><h3 id="质心的基本定义"><a href="#质心的基本定义" class="headerlink" title="质心的基本定义"></a>质心的基本定义</h3><p>对于一组 (n) 个点，点的坐标为$ (x_1, y_1), (x_2, y_2), …, (x_n, y_n)$，其质心 $G &#x3D; (x_c, y_c) $可以通过以下方式计算：<br>$$<br>x_c &#x3D; \frac{1}{n} \sum_{i&#x3D;1}^{n} x_i<br>$$</p><p>$$<br>y_c &#x3D; \frac{1}{n} \sum_{i&#x3D;1}^{n} y_i<br>$$</p><p>对于三维空间中的点，质心的计算公式类似：</p><p>$$<br>x_c &#x3D; \frac{1}{n} \sum_{i&#x3D;1}^{n} x_i<br>$$<br>$$<br>y_c &#x3D; \frac{1}{n} \sum_{i&#x3D;1}^{n} y_i<br>$$<br>$$<br>z_c &#x3D; \frac{1}{n} \sum_{i&#x3D;1}^{n} z_i<br>$$</p><p>即，质心是所有点在各个坐标轴上的平均坐标。</p><h3 id="质心的特性"><a href="#质心的特性" class="headerlink" title="质心的特性"></a>质心的特性</h3><ol><li><p><strong>位置是各点坐标的平均值</strong>：<br>质心是所有点在每个坐标轴上的坐标的算术平均值。</p></li><li><p><strong>不依赖于点的权重</strong>（假设所有点的质量相等）：<br>如果每个点都有相同的质量，那么质心就是这些点的算术平均位置。</p><p>如果不同点的质量不同，则质心的计算应考虑点的质量。对于带权重的情况，质心是加权平均数：</p><p>$$<br>x_c &#x3D; \frac{\sum_{i&#x3D;1}^{n} m_i \cdot x_i}{\sum_{i&#x3D;1}^{n} m_i}<br>$$<br>$$<br>y_c &#x3D; \frac{\sum_{i&#x3D;1}^{n} m_i \cdot y_i}{\sum_{i&#x3D;1}^{n} m_i}<br>$$</p><p>其中 (m_i) 是第 (i) 个点的质量，(x_i) 和 (y_i) 是第 (i) 个点的坐标。</p></li><li><p><strong>质心是平衡点</strong>：<br>如果你在二维平面上画一个图形，并将这个图形按质心进行平衡，它应该是平衡的。也就是说，如果在质心的位置上放一个支点，那么这个图形就不会倾斜。</p></li><li><p><strong>质心与几何形状有关</strong>：<br>对于规则形状（如正多边形、圆形等），质心位于形状的对称中心。对于不规则形状，它可能位于形状内部或外部，取决于点的分布。</p></li><li><p><strong>质心不一定在已知的点集内</strong>：<br>在某些情况下，质心可能位于给定点集之外，特别是在计算多边形的质心时。对于一个简单的凸多边形，质心通常位于该多边形内部，但对于复杂的凹形状，质心可能位于多边形外部。</p></li><li><p><strong>具有旋转对称性</strong>：<br>对于一个平面上的对称图形（如圆形、正多边形等），质心通常位于其对称中心。</p></li><li><p><strong>计算简单且高效</strong>：<br>质心的计算方法通常非常简单，只需要计算所有点的坐标的平均值即可。对于大多数应用而言，这种计算的时间复杂度为 (O(n))，其中 (n) 是点的数量。</p></li></ol><h3 id="质心的应用"><a href="#质心的应用" class="headerlink" title="质心的应用"></a>质心的应用</h3><ul><li><strong>物理学</strong>：质心概念用于描述物体的质量中心，特别是在分析物体的运动时（例如转动惯量）。</li><li><strong>计算几何</strong>：在图形处理中，质心用于寻找图形的几何中心，广泛应用于碰撞检测、分割和配准等任务。</li><li><strong>图像处理</strong>：在图像中，质心可以用来描述形状或物体的重心，常用于形状分析、目标追踪和图像分割。</li><li><strong>计算机图形学</strong>：质心用于计算模型的中心点，帮助进行模型对齐和变换。</li></ul><h3 id="质心计算的例子"><a href="#质心计算的例子" class="headerlink" title="质心计算的例子"></a>质心计算的例子</h3><ol><li><p><strong>二维点集的质心计算</strong>：</p><p>给定四个点：<br>$$<br>(1, 2), (4, 6), (7, 8), (10, 12)<br>$$</p><p>质心的计算：<br>$$<br>x_c &#x3D; \frac{1 + 4 + 7 + 10}{4} &#x3D; 5.5<br>$$<br>$$<br>y_c &#x3D; \frac{2 + 6 + 8 + 12}{4} &#x3D; 7<br>$$</p><p>所以质心为 ((5.5, 7))。</p></li><li><p><strong>三维点集的质心计算</strong>：</p><p>给定三个点：<br>$$<br>(1, 2, 3), (4, 5, 6), (7, 8, 9)<br>$$</p><p>质心的计算：<br>$$<br>x_c &#x3D; \frac{1 + 4 + 7}{3} &#x3D; 4<br>$$<br>$$<br>y_c &#x3D; \frac{2 + 5 + 8}{3} &#x3D; 5<br>$$<br>$$<br>z_c &#x3D; \frac{3 + 6 + 9}{3} &#x3D; 6<br>$$</p><p>所以质心为 ((4, 5, 6))。</p></li></ol><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>质心是多个点的“平均位置”，通常用于表示一组点的几何中心。在计算时，质心是各点坐标的算术平均值，对于带有不同质量的点集合，质心可以通过加权平均计算。质心在物理学、计算几何、图像处理等领域有广泛的应用。</p><h1 id="为什么在MAUI应用中使用Process-GetProcesses-方法无法获得所有的进程信息"><a href="#为什么在MAUI应用中使用Process-GetProcesses-方法无法获得所有的进程信息" class="headerlink" title="为什么在MAUI应用中使用Process.GetProcesses()方法无法获得所有的进程信息?"></a>为什么在MAUI应用中使用Process.GetProcesses()方法无法获得所有的进程信息?</h1><p>在 Android 设备上使用 <code>Process.GetProcesses()</code> 只能获取到<strong>自己所在的进程</strong>或是非常有限的信息，这是由 Android 的沙盒和权限机制所决定的。和传统桌面或服务器环境的 .NET 不同，Android 并不允许普通应用程序访问系统中所有进程的详细信息。</p><h2 id="为什么会这样？"><a href="#为什么会这样？" class="headerlink" title="为什么会这样？"></a>为什么会这样？</h2><ol><li><strong>Android 沙盒机制</strong><br> 每个 Android 应用都运行在自己的“应用沙盒”中，进程之间隔离很严格。应用无权直接访问其他进程的信息，除非拥有系统级权限或特定的授权。</li><li><strong>权限限制</strong><br> Android 并没有对普通第三方应用开放类似于在桌面系统上遍历所有进程的接口。即使你调用了 <code>Process.GetProcesses()</code>，最终底层的实现也只能让你看到自己进程的基本信息。</li><li><strong>安全策略</strong><br> 出于安全和隐私的考虑，Android 系统对进程、文件等访问做了严格的限制，防止不同应用之间互相窥探或干扰。</li></ol><h2 id="如果想获取所有进程信息，该怎么做？"><a href="#如果想获取所有进程信息，该怎么做？" class="headerlink" title="如果想获取所有进程信息，该怎么做？"></a>如果想获取所有进程信息，该怎么做？</h2><p>一般来说，在<strong>非 Root 环境</strong>下，普通应用几乎没有办法获取系统中所有进程的详细信息。以下是一些可能但并不一定可行的途径：</p><ol><li><strong>Root 权限</strong><ul><li>如果设备已经 Root，那么可以通过访问 <code>/proc</code> 文件系统或使用一些系统级命令（如 <code>ps</code>、<code>top</code> 等）来获取所有进程信息。</li><li>但是这会导致应用只能在 Root 后的设备上运行，并且在官方应用商店上架会遇到限制。</li></ul></li><li><strong>系统签名 &#x2F; 定制 ROM</strong><ul><li>如果你在开发系统应用（即使用了与系统相同的签名）或是开发针对定制 ROM 的特权应用，则可以使用 Android 的系统 API（如 <code>ActivityManagerService</code>）来获取所有进程信息。</li><li>这通常只适用于设备厂商或在特殊场景（比如企业、特定硬件项目）下定制的 Android 系统。</li></ul></li><li><strong>ActivityManager APIs（有限信息）</strong><ul><li>有些情况下，可以用 <code>Android.App.ActivityManager</code>（Java &#x2F; Xamarin.Android）获取<strong>部分</strong>正在运行的任务&#x2F;服务信息，不过从 Android 5.0 开始，能获取到的信息也变得非常有限，且通常只能拿到应用层级的概览（比如包名、进程计数），而非完整进程列表。</li></ul></li><li><strong>Shell 命令（有限，且受权限限制）</strong><ul><li>即使你执行类似 <code>Runtime.getRuntime().exec(&quot;ps&quot;)</code> 的命令，若没有 Root 权限，也只能查看到<strong>自己所在应用</strong>及部分系统可见的进程。</li></ul></li></ol><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul><li><strong>在普通的 Android 应用环境下，无法用 <code>Process.GetProcesses()</code> 获取所有进程。</strong></li><li>这并不是 .NET 或 C# 的问题，而是 Android 操作系统本身的安全沙盒设计导致的行为。</li><li>如果确有需要（比如做系统工具、ROM 定制、设备管理等），就必须获得更高权限（Root 或系统签名），然后才能使用系统底层接口或 Shell 命令来获取全部进程信息。</li></ul><p>因此，如果只是做一般的 App 开发，往往只能获取到<strong>自己</strong>的进程信息，这在移动平台上是标准且合规的行为。</p><h1 id="热更新热重载是怎么做到的-是什么原理"><a href="#热更新热重载是怎么做到的-是什么原理" class="headerlink" title="热更新热重载是怎么做到的?是什么原理?"></a>热更新热重载是怎么做到的?是什么原理?</h1><p>“热更新”(Hot Update) 或“热重载”(Hot Reload) 指的是在应用程序<strong>运行时</strong>，对代码或资源文件的修改能够<strong>实时</strong>(或接近实时) 地在应用中生效，而<strong>无需完全重启</strong>应用的技术。不同的平台和框架有不同的实现方式，但总体思路是一致的：<strong>监听到代码或资源文件有改动，就把改动后的部分重新加载并替换原有的逻辑或内容</strong>，从而使运行中的程序能即时应用新代码。</p><p>下面以常见的场景来举例说明原理。</p><hr><h2 id="一、在-NET-C-中的-Hot-Reload-原理"><a href="#一、在-NET-C-中的-Hot-Reload-原理" class="headerlink" title="一、在 .NET &#x2F; C# 中的 Hot Reload 原理"></a>一、在 .NET &#x2F; C# 中的 Hot Reload 原理</h2><h3 id="1-“编辑并继续”-Edit-and-Continue-技术的演进"><a href="#1-“编辑并继续”-Edit-and-Continue-技术的演进" class="headerlink" title="1. “编辑并继续”(Edit and Continue) 技术的演进"></a>1. “编辑并继续”(Edit and Continue) 技术的演进</h3><p>早在 Visual Studio 里就有 “Edit and Continue” 功能：当你在调试（Debug）过程中修改了某些 C# 代码，VS 会尝试把修改过的<strong>方法体</strong>重新编译成 IL(中间语言)，并把它<strong>注入</strong>到正在调试的进程中，从而实现“无需停止调试就能应用新代码”的效果。</p><p>.NET 6+ 将此功能推广为更通用的 “Hot Reload”：</p><ol><li><strong>实时监视源码文件变动</strong>：VS&#x2F;CLI 的监视器(FileWatcher)发现文件更新后触发事件。</li><li><strong>重新编译仅修改的部分</strong>：只编译你刚改的类或方法，得到新的 IL。</li><li><strong>将新 IL 注入到运行中的程序</strong>：.NET 运行时（通过元数据和IL定位）找到对应的类或方法，替换其方法体。</li></ol><p><strong>局限</strong>：</p><ul><li>只能修改<strong>方法的实现</strong>、局部变量、表达式等；</li><li><strong>无法</strong>轻易修改方法签名、类的继承结构、泛型定义等较大范围的结构性更改；</li><li>如果改动超出“Hot Reload”可处理的范围，就需要重启或重新编译整个应用。</li></ul><h3 id="2-XAML-Hot-Reload-WPF-Xamarin-MAUI"><a href="#2-XAML-Hot-Reload-WPF-Xamarin-MAUI" class="headerlink" title="2. XAML Hot Reload (WPF &#x2F; Xamarin &#x2F; MAUI)"></a>2. XAML Hot Reload (WPF &#x2F; Xamarin &#x2F; MAUI)</h3><ul><li>针对 UI 层(XAML)的修改，如调整控件布局、样式等，也可以在运行时注入新的 XAML 资源，刷新 UI 视图。</li><li>实现思路：监听到 XAML 文件改动，重新编译 XAML-&gt;BAML(或生成 C# UI 代码)，调用运行时的刷新机制来动态更新界面树。</li></ul><hr><h2 id="二、在前端框架中的-Hot-Reload-Hot-Module-Replacement"><a href="#二、在前端框架中的-Hot-Reload-Hot-Module-Replacement" class="headerlink" title="二、在前端框架中的 Hot Reload &#x2F; Hot Module Replacement"></a>二、在前端框架中的 Hot Reload &#x2F; Hot Module Replacement</h2><h3 id="1-Webpack-的-HMR-Hot-Module-Replacement"><a href="#1-Webpack-的-HMR-Hot-Module-Replacement" class="headerlink" title="1. Webpack 的 HMR (Hot Module Replacement)"></a>1. Webpack 的 HMR (Hot Module Replacement)</h3><ul><li>前端构建工具（如 Webpack、Vite）会在开发模式下启动一个 <strong>dev server</strong> 并监控(<code>watch</code>) 源文件的变动。</li><li>一旦检测到文件更新，会<strong>只重新编译改动的模块</strong>，并通过 WebSocket 等方式将“更新的模块包”推送到浏览器。</li><li>浏览器端有一个运行时（HMR Runtime），会<strong>替换</strong>对应模块的旧代码，而无需刷新整个网页。</li><li>对于 React&#x2F;Vue 等框架，如果能保持组件状态，就可实现真正“局部更新、不刷新、不丢失状态”的热重载。</li></ul><h3 id="2-React-Refresh-Vue-Hot-Reload"><a href="#2-React-Refresh-Vue-Hot-Reload" class="headerlink" title="2. React Refresh &#x2F; Vue Hot Reload"></a>2. React Refresh &#x2F; Vue Hot Reload</h3><ul><li>React Refresh 利用 Babel 在编译时给组件插桩(instrument)，在运行时检测到代码更新后<strong>只替换对应组件的渲染逻辑</strong>。</li><li>Vue 的单文件组件(.vue)编译后也带有 HMR hook，检测到更新就只替换该组件的部分，不用刷新整页。</li></ul><hr><h2 id="三、在移动端的-Hot-Reload-React-Native-Flutter"><a href="#三、在移动端的-Hot-Reload-React-Native-Flutter" class="headerlink" title="三、在移动端的 Hot Reload (React Native &#x2F; Flutter)"></a>三、在移动端的 Hot Reload (React Native &#x2F; Flutter)</h2><h3 id="1-React-Native"><a href="#1-React-Native" class="headerlink" title="1. React Native"></a>1. React Native</h3><ul><li>Metro bundler 监听 JavaScript&#x2F;TypeScript 文件更新，重新打包相应模块，利用 “Fast Refresh” (类似 HMR) 向运行中的 APP 注入。</li><li>RN 遍历组件树，只重绘受影响的组件，不用重启整个原生应用。</li></ul><h3 id="2-Flutter"><a href="#2-Flutter" class="headerlink" title="2. Flutter"></a>2. Flutter</h3><ul><li>Dart VM 提供了 “hot reload&#x2F;hot restart” 能力。</li><li><strong>hot reload</strong>：在 Dart 层可以将修改过的代码注入到正在运行的 Dart VM 中，Flutter 框架会重建 widget 树并渲染更新，但不会丢失原有状态(如变量、路由栈)。</li><li><strong>hot restart</strong>：比 hot reload范围更大，会完全重启 Dart isolate，但依旧不需要重新启动整个原生进程。</li></ul><hr><h2 id="四、总体机制与原理"><a href="#四、总体机制与原理" class="headerlink" title="四、总体机制与原理"></a>四、总体机制与原理</h2><p>无论是后端(.NET Java)、前端(Webpack、Vite)还是移动端(Flutter、RN)，它们的做法可归纳为：</p><ol><li><strong>监控源码或资源文件改动</strong>：文件系统监听(File System Watcher)或特殊插件(DevServer)发现你保存了文件。</li><li><strong>局部编译&#x2F;增量编译</strong>：只编译改动过的源码模块&#x2F;方法&#x2F;资源，得到新的字节码(IL、JS bundle)或UI资源(XAML、CSS)。</li><li><strong>动态加载并替换</strong>：将新编译的结果注入到内存中，替换掉原有的部分。</li><li><strong>框架层做状态管理</strong>：许多框架会尽可能保持原来的运行状态(变量值、组件状态等)，只更新逻辑或视图，从而达到“热更新”效果。</li></ol><h3 id="核心要点"><a href="#核心要点" class="headerlink" title="核心要点"></a>核心要点</h3><ul><li><strong>编译器或打包器层面</strong>支持增量编译。</li><li><strong>运行时</strong>需要可以“热插拔”新的代码或资源。</li><li>有些变化（比如大范围结构性修改）必须要重新启动，因为运行时无法动态地“改血统、改签名”。</li><li>很多框架为了让开发体验更好，会尽可能地支持“状态保留”，这样你就不必每次改完代码后重新手动执行一系列操作(如登录、跳到某个流程等)。</li></ul><hr><h2 id="五、Cookie-效果之类的常见误解"><a href="#五、Cookie-效果之类的常见误解" class="headerlink" title="五、Cookie 效果之类的常见误解"></a>五、Cookie 效果之类的常见误解</h2><ul><li>“热重载”是针对应用本身的代码或资源进行替换，与<strong>Cookie&#x2F;Session</strong>这类网络状态无关。</li><li>如果应用中维护某些会话或数据状态，只要运行时不会被重启，这些状态就可被保留。在做前端 HMR&#x2F;后端 Hot Reload 时，Cookie&#x2F;Session 信息仍然可以在请求中正常传递。</li></ul><hr><h2 id="六、小结"><a href="#六、小结" class="headerlink" title="六、小结"></a>六、小结</h2><p><strong>热更新、热重载的本质</strong>：在<strong>不重启进程</strong>(或者不刷新整个页面&#x2F;应用)的前提下，<strong>动态替换</strong>部分已编译（或已加载）的代码&#x2F;资源，以实现更快的开发调试迭代。</p><ul><li>在 <strong>.NET</strong> 中，主要利用了 <strong>Edit and Continue</strong> &#x2F; <strong>Hot Reload</strong> 的机制来对方法体或 XAML 进行动态更新；</li><li>在 <strong>Web</strong> 前端，主要利用 **HMR(Hot Module Replacement)**，通过增量打包+运行时替换来只更新改动的模块；</li><li>在 <strong>Flutter &#x2F; React Native</strong> 中，利用虚拟机或 bundler 的能力将修改后的 Dart&#x2F;JS 代码注入运行时，并进行局部重渲染。</li></ul><p><strong>收益</strong>：开发者可以<strong>大大减少编译、启动、登录等步骤</strong>，快速看到最新修改的效果，提高开发效率。</p><p>这就是热更新&#x2F;热重载“能做到且如何做到”的基本原理。</p><h1 id="什么是ROS"><a href="#什么是ROS" class="headerlink" title="什么是ROS?"></a>什么是ROS?</h1><h1 id="为什么GC是独立组件-通用框架又是什么-什么又是规则引擎"><a href="#为什么GC是独立组件-通用框架又是什么-什么又是规则引擎" class="headerlink" title="为什么GC是独立组件?通用框架又是什么?什么又是规则引擎?"></a>为什么GC是独立组件?通用框架又是什么?什么又是规则引擎?</h1><h1 id="关于GC、通用框架和规则引擎的解释"><a href="#关于GC、通用框架和规则引擎的解释" class="headerlink" title="关于GC、通用框架和规则引擎的解释"></a>关于GC、通用框架和规则引擎的解释</h1><h2 id="为什么GC-垃圾回收-是独立组件？"><a href="#为什么GC-垃圾回收-是独立组件？" class="headerlink" title="为什么GC(垃圾回收)是独立组件？"></a>为什么GC(垃圾回收)是独立组件？</h2><p>GC(垃圾回收)作为独立组件存在有几个重要原因：</p><ol><li><strong>关注点分离</strong>：GC专注于内存管理这一单一职责，与程序的核心逻辑分离</li><li><strong>复杂性封装</strong>：垃圾回收算法复杂(如标记-清除、分代收集等)，独立封装便于维护</li><li><strong>可替换性</strong>：不同应用场景可能需要不同的GC策略(如实时系统用增量GC，服务器用并行GC)</li><li><strong>跨语言通用性</strong>：类似JVM、.NET CLR等运行时环境可以共享GC组件</li></ol><h2 id="什么是通用框架？"><a href="#什么是通用框架？" class="headerlink" title="什么是通用框架？"></a>什么是通用框架？</h2><p>通用框架是指为解决某一类问题而设计的基础软件结构，具有以下特点：</p><ol><li><strong>可扩展性</strong>：通过继承、组合等方式扩展功能</li><li><strong>可配置性</strong>：通过参数或配置文件调整行为</li><li><strong>重用性</strong>：为多个具体应用提供共用基础</li><li><strong>控制反转</strong>：框架控制程序流程，开发者填充具体逻辑</li></ol><p>例如：Spring(Java)、Django(Python)、React(前端)等都是通用框架</p><h2 id="什么是规则引擎？"><a href="#什么是规则引擎？" class="headerlink" title="什么是规则引擎？"></a>什么是规则引擎？</h2><p>规则引擎是一种将业务规则与应用程序代码分离的系统，特点包括：</p><ol><li><strong>业务逻辑外部化</strong>：规则通常存储在数据库或配置文件中</li><li><strong>声明式编程</strong>：关注”做什么”而非”如何做”</li><li><strong>推理引擎</strong>：使用算法(如Rete)高效匹配和执行规则</li><li><strong>动态更新</strong>：无需重新部署即可修改规则</li></ol><p>常见规则引擎：Drools、Jess、IBM ODM等</p><p>三者关系：GC保障内存安全，通用框架提供应用基础结构，规则引擎处理灵活的业务逻辑，它们共同构建健壮的软件系统。</p><h1 id="为什么try-catch-throw-不是一个好的做法"><a href="#为什么try-catch-throw-不是一个好的做法" class="headerlink" title="为什么try{}catch{throw}不是一个好的做法?"></a>为什么try{}catch{throw}不是一个好的做法?</h1><p><img src="/../images/%E9%97%AE%E9%A2%98&%E8%A7%A3%E5%86%B3/image-20250329231632185.png" alt="image-20250329231632185"></p><p><img src="/../images/%E9%97%AE%E9%A2%98&%E8%A7%A3%E5%86%B3/image-20250329231714549.png" alt="image-20250329231714549"></p><p><img src="/../images/%E9%97%AE%E9%A2%98&%E8%A7%A3%E5%86%B3/image-20250329231736194.png" alt="image-20250329231736194"></p><p>KVS key value store</p><h1 id="什么是Mock和Fake对象"><a href="#什么是Mock和Fake对象" class="headerlink" title="什么是Mock和Fake对象?"></a>什么是Mock和Fake对象?</h1><p>这两个概念主要用于单元测试，用于替代真实依赖，方便测试和验证。</p><ul><li>Mock（模拟对象）：用来验证行为，比如“这个方法有没有被调用、调用了几次、参数是什么”。常用 Moq、NSubstitute 等库生成。</li><li>Fake（伪对象）：有简单实现的假对象，能返回预设数据，但不验证行为。比如内存数据库、内存队列等。</li></ul><h1 id="设计模式描述的是一种逻辑上的关系，并不关心具体实现，我的这个理解对吗"><a href="#设计模式描述的是一种逻辑上的关系，并不关心具体实现，我的这个理解对吗" class="headerlink" title="设计模式描述的是一种逻辑上的关系，并不关心具体实现，我的这个理解对吗?"></a>设计模式描述的是一种逻辑上的关系，并不关心具体实现，我的这个理解对吗?</h1><p>你的理解是正确的。<br>设计模式（Design Pattern）本质上描述的是一种通用的、可复用的解决方案，用于应对特定场景下常见的软件设计问题。它关注的是对象之间的协作关系、职责分配和交互方式，而不是具体的代码实现或技术细节。</p><ul><li><p>设计模式强调的是“结构”、“意图”和“约定”，而不是“怎么写代码”。</p></li><li><p>具体实现可以因语言、框架、项目需求而异，但模式背后的思想和逻辑关系是通用的。</p></li></ul><p>举例说明：</p><ul><li><p>观察者模式（Observer Pattern）描述的是“一个对象状态变化时，通知所有依赖它的对象”，但不规定你用事件、回调还是消息队列实现。</p></li><li><p>单例模式（Singleton Pattern）描述的是“全局唯一实例”，但不关心你用静态变量、懒加载还是线程安全锁。<br>总结：<br>设计模式关注的是抽象的设计思想和对象关系，而不是具体实现细节。你的理解完全正确。</p></li></ul><h1 id="给我讲讲，图片的hsv是什么东西-为什么视觉识别需要用到这个"><a href="#给我讲讲，图片的hsv是什么东西-为什么视觉识别需要用到这个" class="headerlink" title="给我讲讲，图片的hsv是什么东西?为什么视觉识别需要用到这个?"></a>给我讲讲，图片的hsv是什么东西?为什么视觉识别需要用到这个?</h1><p>HSV是一种常用的颜色空间，全称是<strong>Hue（色相）、Saturation（饱和度）、Value（明度）</strong>。<br>它和我们常见的RGB（红绿蓝）颜色空间不同，HSV更符合人类对颜色的感知方式。</p><ul><li><strong>H（色相）</strong>：表示颜色的类型，比如红色、绿色、蓝色等，取值范围一般是0~360度。</li><li><strong>S（饱和度）</strong>：表示颜色的纯度，越高颜色越鲜艳，越低越灰白。</li><li><strong>V（明度）</strong>：表示颜色的亮度，越高越亮，越低越暗。</li></ul><h3 id="为什么视觉识别常用HSV？"><a href="#为什么视觉识别常用HSV？" class="headerlink" title="为什么视觉识别常用HSV？"></a>为什么视觉识别常用HSV？</h3><ol><li><strong>抗光照变化能力强</strong><br>HSV空间把颜色和亮度分开了，光照变化主要影响V（明度），而H（色相）和S（饱和度）基本不变，这样可以更稳定地识别颜色。</li><li><strong>颜色分割更直观</strong><br>在RGB空间下，同一种颜色在不同光照下RGB值变化很大，而在HSV空间下，色相（H）基本不变，便于用阈值分割出特定颜色区域。</li><li><strong>更接近人眼感知</strong><br>HSV空间的表示方式更符合人类对颜色的理解，比如我们说“红色”“绿色”其实就是色相（H）。</li></ol><h3 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h3><p>比如你要识别红色物体，在HSV空间下只需要判断H在红色范围内即可，而不用关心光照强弱带来的V变化。</p><hr><p><strong>总结：</strong><br>HSV让颜色识别更简单、更稳定，是视觉识别中特别常用的颜色空间。</p><h1 id="什么是哈希加盐"><a href="#什么是哈希加盐" class="headerlink" title="什么是哈希加盐?"></a>什么是哈希加盐?</h1><p><strong>加盐（Salting）</strong>就是给原始密码**添加一段随机字符串**，然后再进行哈希，以增加破解的难度。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">plaintext复制编辑原始密码：<span class="hljs-number">123456</span><br>随机盐：  x7!@K2<br><br>加盐后：  <span class="hljs-string">&quot;123456x7!@K2&quot;</span><br>哈希值：  MD5(<span class="hljs-string">&quot;123456x7!@K2&quot;</span>) =&gt; <span class="hljs-number">9</span>f1a3e...（不同了）<br></code></pre></td></tr></table></figure><ul><li>盐是<strong>每个用户随机生成的</strong>，并和哈希值一起存储在数据库中。</li><li>即使两个用户用相同密码，因为盐不同，最终哈希值也不同。</li></ul><hr><h2 id="✅-四、加盐哈希的好处"><a href="#✅-四、加盐哈希的好处" class="headerlink" title="✅ 四、加盐哈希的好处"></a>✅ 四、加盐哈希的好处</h2><table><thead><tr><th>问题</th><th>加盐能解决吗？</th><th>说明</th></tr></thead><tbody><tr><td>彩虹表攻击</td><td>✅ 防止</td><td>因为每次加盐都不同，彩虹表无法预制所有组合</td></tr><tr><td>相同密码哈希相同</td><td>✅ 防止</td><td>即使密码一样，加了不同的盐也会得出不同哈希</td></tr><tr><td>被盗哈希后能反推密码</td><td>❌ 不能完全防止</td><td>加盐只是增加破解难度，不能让哈希变得可逆</td></tr></tbody></table><hr><h2 id="🛠-五、哈希加盐的存储方式"><a href="#🛠-五、哈希加盐的存储方式" class="headerlink" title="🛠 五、哈希加盐的存储方式"></a>🛠 五、哈希加盐的存储方式</h2><p>数据库通常会<strong>同时存盐和哈希值</strong>：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">plaintext复制编辑用户名 |<span class="hljs-string"> 盐（Salt） </span>|<span class="hljs-string"> 哈希值</span><br><span class="hljs-string">-------</span>|<span class="hljs-string">------------</span>|<span class="hljs-string">----------------------------</span><br><span class="hljs-string">Alice  </span>|<span class="hljs-string"> x7!@K2     </span>|<span class="hljs-string"> 9f1a3ec1d...</span><br><span class="hljs-string">Bob    </span>|<span class="hljs-string"> Pz#09d     </span>|<span class="hljs-string"> 3ae2b1e3f...</span><br></code></pre></td></tr></table></figure><p>验证密码时：</p><ol><li>拿出用户的盐</li><li>拼接输入的密码</li><li>再哈希</li><li>和数据库中哈希值对比</li></ol><h1 id="syncthing这种软件到底是什么原理-在没有我提供公网Ip的情况下它是怎么进行文件同步的"><a href="#syncthing这种软件到底是什么原理-在没有我提供公网Ip的情况下它是怎么进行文件同步的" class="headerlink" title="syncthing这种软件到底是什么原理?在没有我提供公网Ip的情况下它是怎么进行文件同步的?"></a>syncthing这种软件到底是什么原理?在没有我提供公网Ip的情况下它是怎么进行文件同步的?</h1><p>Syncthing 是一种 <strong>去中心化</strong> 的文件同步工具，其核心原理是 <strong>点对点（P2P）传输</strong>，不依赖中央服务器，而是直接在设备之间建立连接进行文件同步。即使在 <strong>没有公网 IP</strong> 的情况下，它仍然可以通过以下机制实现同步：</p><hr><h3 id="1-设备发现机制（Discovery-Server）"><a href="#1-设备发现机制（Discovery-Server）" class="headerlink" title="1. 设备发现机制（Discovery Server）"></a><strong>1. 设备发现机制（Discovery Server）</strong></h3><p>Syncthing 使用 <strong>全球发现服务器（Global Discovery Server）</strong> 来帮助设备找到彼此：</p><ul><li>每个设备在启动时，会向发现服务器注册自己的 <strong>设备 ID</strong> 和 <strong>网络信息</strong>（如内网 IP 和端口）。</li><li>当另一台设备尝试连接时，它会查询发现服务器，获取目标设备的 <strong>最新网络位置</strong>，然后尝试直接建立连接。</li><li>如果设备在同一个局域网内，Syncthing 还能通过 <strong>本地广播（LAN Discovery）</strong> 自动发现彼此，无需依赖外部服务器。</li></ul><hr><h3 id="2-NAT-穿透（P2P-直连）"><a href="#2-NAT-穿透（P2P-直连）" class="headerlink" title="2. NAT 穿透（P2P 直连）"></a><strong>2. NAT 穿透（P2P 直连）</strong></h3><p>如果设备位于不同的局域网（如家庭 Wi-Fi 和公司网络），Syncthing 会尝试 <strong>NAT 穿透（打洞）</strong>：</p><ul><li>使用 <strong>UDP 打洞（UDP Hole Punching）</strong> 技术，让两个设备通过协商后的端口直接通信。</li><li>如果 NAT 类型支持（如 Full Cone NAT），设备可以直接建立 P2P 连接，无需第三方服务器中转。</li></ul><hr><h3 id="3-中继服务器（Relay-Server）"><a href="#3-中继服务器（Relay-Server）" class="headerlink" title="3. 中继服务器（Relay Server）"></a><strong>3. 中继服务器（Relay Server）</strong></h3><p>如果 <strong>NAT 穿透失败</strong>（如严格型 NAT），Syncthing 会使用 <strong>中继服务器（Relay Server）</strong> 进行数据中转：</p><ul><li>官方提供了一些公共中继服务器（如 <code>relays.syncthing.net</code>），用户也可以 <strong>自建私有中继</strong>。</li><li>数据经过中继时仍然是 <strong>端到端加密（TLS）</strong> 的，中继服务器无法解密文件内容。</li></ul><hr><h3 id="4-数据同步协议（BEP）"><a href="#4-数据同步协议（BEP）" class="headerlink" title="4. 数据同步协议（BEP）"></a><strong>4. 数据同步协议（BEP）</strong></h3><p>Syncthing 使用 <strong>Block Exchange Protocol（BEP）</strong> 进行文件同步：</p><ul><li>文件被分成 <strong>块（Blocks）</strong>，仅传输变化的块，提高效率。</li><li>采用 <strong>版本控制</strong>，可以保留历史版本，防止误删或冲突。</li></ul><hr><h3 id="5-安全性保障"><a href="#5-安全性保障" class="headerlink" title="5. 安全性保障"></a><strong>5. 安全性保障</strong></h3><ul><li><strong>设备认证</strong>：每个设备有唯一的 <strong>加密证书（Device ID）</strong>，只有授权的设备才能同步。</li><li><strong>端到端加密（TLS）</strong>：所有传输的数据都经过加密，即使经过中继服务器也无法窥探。</li><li><strong>无中央存储</strong>：文件不会上传到任何服务器，仅在用户设备之间传输。</li></ul><hr><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>Syncthing 在没有公网 IP 的情况下，仍然可以通过 <strong>发现服务器 + NAT 穿透 + 中继备份</strong> 的方式实现文件同步。它的去中心化设计使其在 <strong>隐私性、安全性和灵活性</strong> 上优于传统的云存储服务（如 Dropbox 或 Resilio Sync）。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>问题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>代码大全-1-软件创建</title>
    <link href="/2024/03/27/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8-1-%E8%BD%AF%E4%BB%B6%E5%88%9B%E5%BB%BA/"/>
    <url>/2024/03/27/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8-1-%E8%BD%AF%E4%BB%B6%E5%88%9B%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>问题定义 -&gt;需求分析 -&gt;实现计划 -&gt;总体设计 -&gt;详细设计 -&gt;创建即实现 -&gt;系统集成 -&gt;单元测试 -&gt;系统测试 -&gt;校正性的维护</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python自动化</title>
    <link href="/2024/03/05/Python%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    <url>/2024/03/05/Python%E8%87%AA%E5%8A%A8%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="增"><a href="#增" class="headerlink" title="增"></a>增</h1><h1 id="删"><a href="#删" class="headerlink" title="删"></a>删</h1><h1 id="改"><a href="#改" class="headerlink" title="改"></a>改</h1><h2 id="批量重命名"><a href="#批量重命名" class="headerlink" title="批量重命名"></a>批量重命名</h2><h4 id="将文件名前的数字去除"><a href="#将文件名前的数字去除" class="headerlink" title="将文件名前的数字去除"></a>将文件名前的数字去除</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<span class="hljs-comment">#与操作系统交互的函数</span><br><span class="hljs-keyword">import</span> re<span class="hljs-comment">#提供正则表达式相关函数</span><br><br>files = os.listdir(<span class="hljs-string">&#x27;.&#x27;</span>)<span class="hljs-comment">#获取当前目录下的所有文件和文件夹的名字</span><br><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> files:<br>    <span class="hljs-keyword">if</span> file.endswith(<span class="hljs-string">&#x27;.pdf&#x27;</span>):<span class="hljs-comment">#检查是否以.pdf结束</span><br>        <span class="hljs-keyword">if</span> re.<span class="hljs-keyword">match</span>(<span class="hljs-string">r&#x27;\d+-&#x27;</span>,file):<span class="hljs-comment">#</span><br>            new_file = re.sub(<span class="hljs-string">r&#x27;\d+-&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>,file)<br>            os.rename(file,new_file)<br></code></pre></td></tr></table></figure><h4 id="将文件名后缀修改"><a href="#将文件名后缀修改" class="headerlink" title="将文件名后缀修改"></a>将文件名后缀修改</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> re<br><br>files = os.listdir(<span class="hljs-string">&#x27;.&#x27;</span>)<br><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> files:<br>    <span class="hljs-keyword">if</span> file.endswith(<span class="hljs-string">&#x27;.mp3.lrc&#x27;</span>):<br>        new_file = re.sub(<span class="hljs-string">r&#x27;\.mp3\.lrc$&#x27;</span>,<span class="hljs-string">&#x27;.lrc&#x27;</span>,file)<br>        os.rename(file,new_file)<br>    <span class="hljs-keyword">elif</span> file.endswith(<span class="hljs-string">&#x27;.mp3.vtt&#x27;</span>):<span class="hljs-comment">#如果发现是vtt格式则自动修改为lrc格式</span><br>        new_file = re.sub(<span class="hljs-string">r&#x27;\.mp3\.vtt$&#x27;</span>,<span class="hljs-string">&#x27;.vtt&#x27;</span>,file)<br>        os.rename(file,new_file)<br>        vtt_to_lrc(new_file)<br>    <span class="hljs-keyword">elif</span> file.endswith(<span class="hljs-string">&#x27;.wav.vtt&#x27;</span>):<br>        new_file = re.sub(<span class="hljs-string">r&#x27;\.wav\.vtt$&#x27;</span>,<span class="hljs-string">&#x27;.vtt&#x27;</span>,file)<br>        os.rename(file,new_file)<br>        vtt_to_lrc(new_file)<br></code></pre></td></tr></table></figure><h2 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h2><h4 id="vtt转lrc"><a href="#vtt转lrc" class="headerlink" title="vtt转lrc"></a>vtt转lrc</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> re<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">vtt_to_lrc</span>(<span class="hljs-params">vtt_file</span>):<br>    <span class="hljs-comment"># 打开 .vtt 文件</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(vtt_file, <span class="hljs-string">&#x27;r&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        lines = f.readlines()<br><br>    <span class="hljs-comment"># 准备 .lrc 文件内容</span><br>    lrc_content = <span class="hljs-string">&#x27;&#x27;</span><br><br>    <span class="hljs-comment"># 遍历 .vtt 文件中的行</span><br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines:<br>        <span class="hljs-comment"># 如果该行是时间戳行</span><br>        <span class="hljs-keyword">if</span> re.<span class="hljs-keyword">match</span>(<span class="hljs-string">r&#x27;\d&#123;2&#125;:\d&#123;2&#125;:\d&#123;2&#125;.\d&#123;3&#125; --&gt; \d&#123;2&#125;:\d&#123;2&#125;:\d&#123;2&#125;.\d&#123;3&#125;&#x27;</span>, line):<br>            <span class="hljs-comment"># 将时间戳转换为 .lrc 格式</span><br>            start_time, end_time = line.split(<span class="hljs-string">&#x27; --&gt; &#x27;</span>)<br>            start_min, start_sec = start_time.split(<span class="hljs-string">&#x27;:&#x27;</span>)[-<span class="hljs-number">2</span>:]<br>            start_sec, start_msec = start_sec.split(<span class="hljs-string">&#x27;.&#x27;</span>)<br>            lrc_timestamp = <span class="hljs-string">f&#x27;[<span class="hljs-subst">&#123;start_min&#125;</span>:<span class="hljs-subst">&#123;start_sec&#125;</span>.<span class="hljs-subst">&#123;start_msec&#125;</span>]&#x27;</span><br>            lrc_content += lrc_timestamp<br>        <span class="hljs-keyword">elif</span> line.strip() <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> line.startswith(<span class="hljs-string">&#x27;WEBVTT&#x27;</span>) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> re.<span class="hljs-keyword">match</span>(<span class="hljs-string">r&#x27;NOTE.*&#x27;</span>, line) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> re.<span class="hljs-keyword">match</span>(<span class="hljs-string">r&#x27;\d+&#x27;</span>, line):<br>            <span class="hljs-comment"># 如果该行是字幕行，将其添加到 .lrc 文件内容中</span><br>            lrc_content += line<br><br>    <span class="hljs-comment"># 将 .lrc 文件内容写入新的 .lrc 文件</span><br>    lrc_file = vtt_file.replace(<span class="hljs-string">&#x27;.vtt&#x27;</span>, <span class="hljs-string">&#x27;.lrc&#x27;</span>)<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(lrc_file, <span class="hljs-string">&#x27;w&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(lrc_content)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;vtt_file&#125;</span> 已成功转换为 <span class="hljs-subst">&#123;lrc_file&#125;</span>.&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="查"><a href="#查" class="headerlink" title="查"></a>查</h1>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>脚本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python数据结构</title>
    <link href="/2024/02/29/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2024/02/29/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>python没有内置数组类型，但是可以为所有相同任务使用列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">list</span>.append(x) <span class="hljs-comment">#把元素添加到列表的结尾，相当于a[len(a):]=[x]</span><br><span class="hljs-built_in">list</span>.extend(L) <span class="hljs-comment">#通过添加指定列表的所有元素来扩充列表，相当于a[len(a):]=L</span><br><span class="hljs-built_in">list</span>.insert(i,x)<br><span class="hljs-built_in">list</span>.remove(x)<span class="hljs-comment">#删除列表中值为x的第一个元素</span><br><span class="hljs-built_in">list</span>.pop([i])<span class="hljs-comment">#</span><br><span class="hljs-built_in">list</span>.clear()<span class="hljs-comment">#移除列表中的所有项</span><br><span class="hljs-built_in">list</span>.index(x)<span class="hljs-comment">#返回列表中第一个值为x的元素的索引</span><br><span class="hljs-built_in">list</span>.count(x)<span class="hljs-comment">#x在列表中出现的次数</span><br><span class="hljs-built_in">list</span>.sort()<span class="hljs-comment">#对列表中元素进行排序</span><br><span class="hljs-built_in">list</span>.reverse()<span class="hljs-comment">#倒排列表中的元素</span><br><span class="hljs-built_in">list</span>.copy()<span class="hljs-comment">#返回列表的浅复制</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = [<span class="hljs-number">66.25</span>, <span class="hljs-number">333</span>, <span class="hljs-number">333</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1234.5</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(a.count(<span class="hljs-number">333</span>), a.count(<span class="hljs-number">66.25</span>), a.count(<span class="hljs-string">&#x27;x&#x27;</span>))<br><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a.insert(<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a.append(<span class="hljs-number">333</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br>[<span class="hljs-number">66.25</span>, <span class="hljs-number">333</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">333</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1234.5</span>, <span class="hljs-number">333</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>a.index(<span class="hljs-number">333</span>)<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a.remove(<span class="hljs-number">333</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br>[<span class="hljs-number">66.25</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">333</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1234.5</span>, <span class="hljs-number">333</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>a.reverse()<br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br>[<span class="hljs-number">333</span>, <span class="hljs-number">1234.5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">333</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">66.25</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>a.sort()<br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br>[-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">66.25</span>, <span class="hljs-number">333</span>, <span class="hljs-number">333</span>, <span class="hljs-number">1234.5</span>]<br></code></pre></td></tr></table></figure><h4 id="将列表当作栈堆用"><a href="#将列表当作栈堆用" class="headerlink" title="将列表当作栈堆用"></a>将列表当作栈堆用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>stack = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>stack.append(<span class="hljs-number">6</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>stack.append(<span class="hljs-number">7</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>stack<br>[<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>stack.pop()<br><span class="hljs-number">7</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>stack<br>[<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>stack.pop()<br><span class="hljs-number">6</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>stack.pop()<br><span class="hljs-number">5</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>stack<br>[<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><h4 id="将列表当作队列使用"><a href="#将列表当作队列使用" class="headerlink" title="将列表当作队列使用"></a>将列表当作队列使用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python基础</title>
    <link href="/2024/02/28/Python%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/02/28/Python%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="lambda-匿名函数"><a href="#lambda-匿名函数" class="headerlink" title="lambda(匿名函数)"></a>lambda(匿名函数)</h2><p>lambda是一种小型、匿名的、内联函数，它可以有任意数量的参数，但只能有一个表达式。</p><p>匿名函数不需要使用def定义完整函数。</p><p>lambda函数通常用于编写简单的、单行的函数，通常在需要函数作为参数传递的情况下使用，例如在map()、filter()、reduce()等函数中。</p><h4 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">lambda</span> arguments: expression<br></code></pre></td></tr></table></figure><ul><li>lambda 关键字</li><li>arguments 参数列表，可以包含零个或多个参数，必须在：前指定</li><li>expression 用于计算并返回函数的结果的表达式</li></ul><h6 id="以下lambda函数没有参数："><a href="#以下lambda函数没有参数：" class="headerlink" title="以下lambda函数没有参数："></a>以下lambda函数没有参数：</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">f = <span class="hljs-keyword">lambda</span>: <span class="hljs-string">&quot;Hello,World!&quot;</span><br><span class="hljs-built_in">print</span>(f())<br></code></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">Hello,World!<br></code></pre></td></tr></table></figure><h6 id="以下实例用lambda创建匿名函数，设置一个参数a并计算a加10"><a href="#以下实例用lambda创建匿名函数，设置一个参数a并计算a加10" class="headerlink" title="以下实例用lambda创建匿名函数，设置一个参数a并计算a加10"></a>以下实例用lambda创建匿名函数，设置一个参数a并计算a加10</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-keyword">lambda</span> a : a+<span class="hljs-number">10</span><br><span class="hljs-built_in">print</span>(x(<span class="hljs-number">5</span>))<br></code></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pyton">15<br></code></pre></td></tr></table></figure><h6 id="lamda表达式也可设置多个参数，中间用”-“隔开"><a href="#lamda表达式也可设置多个参数，中间用”-“隔开" class="headerlink" title="lamda表达式也可设置多个参数，中间用”,“隔开"></a>lamda表达式也可设置多个参数，中间用”,“隔开</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-keyword">lambda</span> a,b: a*b<br><span class="hljs-built_in">print</span>(x(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>))<br></code></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">30</span><br></code></pre></td></tr></table></figure><h6 id="以下实例使用lambda创建函数，函数参数a-b-c相加并返回结果"><a href="#以下实例使用lambda创建函数，函数参数a-b-c相加并返回结果" class="headerlink" title="以下实例使用lambda创建函数，函数参数a,b,c相加并返回结果"></a>以下实例使用lambda创建函数，函数参数a,b,c相加并返回结果</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-keyword">lambda</span> a,b,c: a+b+c<br><span class="hljs-built_in">print</span>(x(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">13</span><br></code></pre></td></tr></table></figure><h6 id="lambda函数与内置函数如map-、filter-、reduce-一起使用，以便在集合上执行操作"><a href="#lambda函数与内置函数如map-、filter-、reduce-一起使用，以便在集合上执行操作" class="headerlink" title="lambda函数与内置函数如map()、filter()、reduce()一起使用，以便在集合上执行操作"></a>lambda函数与内置函数如map()、filter()、reduce()一起使用，以便在集合上执行操作</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">numbers = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>squard = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: x**<span class="hljs-number">2</span>,numbers))<br><span class="hljs-built_in">print</span>(squard) <span class="hljs-comment"># 输出[1,4,9,16,25]</span><br></code></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">16</span>,<span class="hljs-number">25</span>]<br></code></pre></td></tr></table></figure><h6 id="使用lambda函数与filter一起筛选偶数"><a href="#使用lambda函数与filter一起筛选偶数" class="headerlink" title="使用lambda函数与filter一起筛选偶数"></a>使用lambda函数与filter一起筛选偶数</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">numbers = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]<br>even_numbers = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x : x%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>),numbers)<br><span class="hljs-built_in">print</span>(even_numbers) <span class="hljs-comment">#输出[2,4,6,8]</span><br></code></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>]<br></code></pre></td></tr></table></figure><h6 id="下面是一个使用reduce-和lambda表达式演示如何计算一个序列的累积乘积"><a href="#下面是一个使用reduce-和lambda表达式演示如何计算一个序列的累积乘积" class="headerlink" title="下面是一个使用reduce()和lambda表达式演示如何计算一个序列的累积乘积"></a>下面是一个使用reduce()和lambda表达式演示如何计算一个序列的累积乘积</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br>numbers= [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><span class="hljs-comment"># 使用reduce()和lambda函数计算乘积</span><br>product = reduce(<span class="hljs-keyword">lambda</span> x,y:x*y,numbers)<br><span class="hljs-built_in">print</span>(product) <span class="hljs-comment">#输出: 120</span><br></code></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">120</span><br></code></pre></td></tr></table></figure><p>在上面的实例中，reduce通过遍历numbers列表，并使用lambda函数将累积的结果不断更新，最终得到了<code>1*2*3*4*5=120</code>的结果</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>Python从设计之初就已经是一门面向对象的语言，因此在Python中创建一个类和对象是很容易的。</p><h4 id="技术简介"><a href="#技术简介" class="headerlink" title="技术简介"></a>技术简介</h4><ul><li><strong>类：</strong>用来描述具有相同属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</li><li><strong>方法：</strong> 类中定义的函数</li><li><strong>对象：</strong> 通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法</li><li><strong>类变量：</strong> 类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</li><li><strong>实例化：</strong> 创建一个类的实例，类的具体对象。</li><li><strong>实例变量：</strong> 在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用self修饰的变量。</li><li><strong>局部变量：</strong> 定义在方法中的变量，只作用域当前实例的类。</li></ul><p>和其它编程语言相比，Python在尽可能不增加新的语法和语义的情况下加入了类机制。</p><p>Python中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中古代同名方法。</p><p>对象可以包含任意数量和类型的数据。</p><h4 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h4><p>语法结构如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span>:<br>    &lt;statement-<span class="hljs-number">1</span>&gt;<br>    .<br>    .<br>    .<br>    &lt;statement-N&gt;<br></code></pre></td></tr></table></figure><p>类实例化后，可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性。</p><h4 id="类对象"><a href="#类对象" class="headerlink" title="类对象"></a>类对象</h4><p>类对象支持两种操作：<strong>属性引用</strong>和<strong>实例化</strong>。</p><p>属性引用使用和Python中所有属性引用一样的标准语法：<strong>obj.name</strong>。</p><p>类对象创建后，类命名空间中所有的命名都是有效属性名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;一个简单的类实例&quot;&quot;&quot;</span><br>    i = <span class="hljs-number">12345</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello world&#x27;</span><br> <br><span class="hljs-comment"># 实例化类</span><br>x = MyClass()<br> <br><span class="hljs-comment"># 访问类的属性和方法</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;MyClass 类的属性 i 为：&quot;</span>, x.i)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;MyClass 类的方法 f 输出为：&quot;</span>, x.f())<br></code></pre></td></tr></table></figure><h6 id="以上代码创建了一个新的类实例并将该对象赋给局部变量x，x为空的对象。"><a href="#以上代码创建了一个新的类实例并将该对象赋给局部变量x，x为空的对象。" class="headerlink" title="以上代码创建了一个新的类实例并将该对象赋给局部变量x，x为空的对象。"></a>以上代码创建了一个新的类实例并将该对象赋给局部变量x，x为空的对象。</h6><p>输出结果为：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">MyClass</span> 类的属性 i 为： <span class="hljs-number">12345</span><br><span class="hljs-keyword">MyClass</span> 类的方法 f 输出为： hello world<br></code></pre></td></tr></table></figure><h6 id="类有一个名为-init-的构造方法，该方法在类实例化时会自动调用，如下"><a href="#类有一个名为-init-的构造方法，该方法在类实例化时会自动调用，如下" class="headerlink" title="类有一个名为__init__()的构造方法，该方法在类实例化时会自动调用，如下"></a>类有一个名为<code>__init__()</code>的构造方法，该方法在类实例化时会自动调用，如下</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>    self.data = []<br></code></pre></td></tr></table></figure><p>类定义了<code>__init__()</code>方法，类的实例化操作会自动调用<code>__init__()</code>方法。如下实例化类MyClass，对应的<code>__init__()</code>方法会被调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">x=MyClass()<br></code></pre></td></tr></table></figure><h6 id="init-方法可以有参数，参数通过-init-传递到类的实例化操作上。如："><a href="#init-方法可以有参数，参数通过-init-传递到类的实例化操作上。如：" class="headerlink" title="__init__()方法可以有参数，参数通过__init__()传递到类的实例化操作上。如："></a><code>__init__()</code>方法可以有参数，参数通过<code>__init__()</code>传递到类的实例化操作上。如：</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, realpart, imagpart</span>):<br>        self.r = realpart<br>        self.i = imagpart<br>x = Complex(<span class="hljs-number">3.0</span>, -<span class="hljs-number">4.5</span>)<br><span class="hljs-built_in">print</span>(x.r, x.i)   <span class="hljs-comment"># 输出结果：3.0 -4.5</span><br></code></pre></td></tr></table></figure><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">__init__() -&gt; <span class="hljs-literal">None</span>:<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-comment"># vscode自动补齐了如上内容，其中</span><br><span class="hljs-comment"># -&gt; 代表函数的返回值是空值，没有具体返回结果</span><br><span class="hljs-comment"># pass代表占位符，此函数什么都不做</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="self代表类的实例，而非类"><a href="#self代表类的实例，而非类" class="headerlink" title="self代表类的实例，而非类"></a>self代表类的实例，而非类</h4><p>类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的<strong>第一个参数名称</strong>，按照惯例它的名称是self。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">prt</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(self)<br>        <span class="hljs-built_in">print</span>(self.__class__)<br> <br>t = Test()<br>t.prt()<br></code></pre></td></tr></table></figure><p>上述实例执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">&lt;__main__.Test instance at <span class="hljs-number">0x100771878</span>&gt;<br>__main__.Test<br></code></pre></td></tr></table></figure><p>从执行结果可以很明显的看出，self代表的是类的实例，代表当前对象的地址，而self.class则指向类。</p><p>self不是python关键字，我们把他缓存任何名字都可以正常执行。</p><h4 id="类的方法"><a href="#类的方法" class="headerlink" title="类的方法"></a>类的方法</h4><p>在类的内部，使用<code>def</code>关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数self，且为第一个参数，self代表的是类的实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 类定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">people</span>:<br>    <span class="hljs-comment"># 定义基本属性</span><br>    name = <span class="hljs-string">&#x27;&#x27;</span><br>    age = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 定义私有属性，私有属性在外部无法直接进行访问</span><br>    __weight = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 定义构造方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,n,a,w</span>):<br>        self.name = n<br>        self.age = a<br>        self.__weight = w<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s说:我%d岁。&quot;</span>%(self.name,self.age))<br><span class="hljs-comment"># 实例化类</span><br>p = people(<span class="hljs-string">&#x27;骨头汤&#x27;</span>,<span class="hljs-number">18</span>,<span class="hljs-number">30</span>)<br>p.speak()<br></code></pre></td></tr></table></figure><p>执行上述程序输出结果为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">骨头汤说:我18岁</span><br></code></pre></td></tr></table></figure><h2 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h2><p>python推导式可以从一个数据序列构建另一个新的数据序列的结构体，支持推导式的数据结构有:</p><ul><li>列表list</li><li>字典dict</li><li>集合set</li><li>元组tuple</li></ul><h4 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">[表达式 <span class="hljs-keyword">for</span> 变量 <span class="hljs-keyword">in</span> 列表]<br>或<br>[表达式 <span class="hljs-keyword">for</span> 变量 <span class="hljs-keyword">in</span> 列表 <span class="hljs-keyword">if</span> 条件]<br></code></pre></td></tr></table></figure><h6 id="过滤掉长度小于或等于3的字符串列表，并将剩下的转换成大写字母"><a href="#过滤掉长度小于或等于3的字符串列表，并将剩下的转换成大写字母" class="headerlink" title="过滤掉长度小于或等于3的字符串列表，并将剩下的转换成大写字母"></a>过滤掉长度小于或等于3的字符串列表，并将剩下的转换成大写字母</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>names = [<span class="hljs-string">&#x27;Bob&#x27;</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>,<span class="hljs-string">&#x27;alice&#x27;</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>,<span class="hljs-string">&#x27;Wendy&#x27;</span>,<span class="hljs-string">&#x27;Smith&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>new_names = [name.upper()<span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> names <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(name)&gt;<span class="hljs-number">3</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(new_names)<br>[<span class="hljs-string">&#x27;ALICE&#x27;</span>, <span class="hljs-string">&#x27;JERRY&#x27;</span>, <span class="hljs-string">&#x27;WENDY&#x27;</span>, <span class="hljs-string">&#x27;SMITH&#x27;</span>]<br></code></pre></td></tr></table></figure><h6 id="计算30以内可以被3整除的整数"><a href="#计算30以内可以被3整除的整数" class="headerlink" title="计算30以内可以被3整除的整数"></a>计算30以内可以被3整除的整数</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>multiples= [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">if</span> i % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(multiples)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>, <span class="hljs-number">12</span>, <span class="hljs-number">15</span>, <span class="hljs-number">18</span>, <span class="hljs-number">21</span>, <span class="hljs-number">24</span>, <span class="hljs-number">27</span>]<br></code></pre></td></tr></table></figure><h4 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h4><p>字典推导基本格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123; key_expr: value_expr <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> collection &#125;<br>或<br>&#123; key_expr: value_expr <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> collection <span class="hljs-keyword">if</span> condition &#125;<br></code></pre></td></tr></table></figure><h6 id="使用字符串及其长度创建字典"><a href="#使用字符串及其长度创建字典" class="headerlink" title="使用字符串及其长度创建字典"></a>使用字符串及其长度创建字典</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">listdemo = [<span class="hljs-string">&#x27;Google&#x27;</span>,<span class="hljs-string">&#x27;Runoob&#x27;</span>, <span class="hljs-string">&#x27;Taobao&#x27;</span>]<br><span class="hljs-comment"># 将列表中各字符串值为键，各字符串的长度为值，组成键值对</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>newdict = &#123;key:<span class="hljs-built_in">len</span>(key) <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> listdemo&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>newdict<br>&#123;<span class="hljs-string">&#x27;Google&#x27;</span>: <span class="hljs-number">6</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>: <span class="hljs-number">6</span>, <span class="hljs-string">&#x27;Taobao&#x27;</span>: <span class="hljs-number">6</span>&#125;<br></code></pre></td></tr></table></figure><h6 id="提供三个数字，以三个数字为键，三个数字的平方为值来创建字典"><a href="#提供三个数字，以三个数字为键，三个数字的平方为值来创建字典" class="headerlink" title="提供三个数字，以三个数字为键，三个数字的平方为值来创建字典"></a>提供三个数字，以三个数字为键，三个数字的平方为值来创建字典</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>dic = &#123;x: x**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> (<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>)&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>dic<br>&#123;<span class="hljs-number">2</span>: <span class="hljs-number">4</span>, <span class="hljs-number">4</span>: <span class="hljs-number">16</span>, <span class="hljs-number">6</span>: <span class="hljs-number">36</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(dic)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;dict&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><h4 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h4><p>集合推导基本格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123; expression <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> <span class="hljs-type">Sequence</span> &#125;<br>或<br>&#123; expression <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> <span class="hljs-type">Sequence</span> <span class="hljs-keyword">if</span> conditional &#125;<br></code></pre></td></tr></table></figure><h6 id="计算1，2，3的平方数"><a href="#计算1，2，3的平方数" class="headerlink" title="计算1，2，3的平方数"></a>计算1，2，3的平方数</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>setnew = &#123;i**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>setnew<br>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>&#125;<br></code></pre></td></tr></table></figure><h6 id="判断不是abc的字母并输出"><a href="#判断不是abc的字母并输出" class="headerlink" title="判断不是abc的字母并输出"></a>判断不是abc的字母并输出</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = &#123;x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;abracadabra&#x27;</span> <span class="hljs-keyword">if</span> x <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;abc&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br>&#123;<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(a)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;set&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><h4 id="元组推导式（生成器表达式）"><a href="#元组推导式（生成器表达式）" class="headerlink" title="元组推导式（生成器表达式）"></a>元组推导式（生成器表达式）</h4><p>元组推导式可以利用range区间，元组，列表，字典和集合等数据类型，快速生成一个满足指定需求的元组</p><p>元组推导式基本格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">(expression <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> <span class="hljs-type">Sequence</span> )<br>或<br>(expression <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> <span class="hljs-type">Sequence</span> <span class="hljs-keyword">if</span> conditional )<br></code></pre></td></tr></table></figure><p>元组推导式和列表推导式的用法也完全相同，只是元组推导式是用（）而列表推导式用[]，另外元组推导式返回的结果是一个生成器对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = (x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br>&lt;generator <span class="hljs-built_in">object</span> &lt;genexpr&gt; at <span class="hljs-number">0x7faf6ee20a50</span>&gt;  <span class="hljs-comment"># 返回的是生成器对象</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">tuple</span>(a)       <span class="hljs-comment"># 使用 tuple() 函数，可以直接将生成器对象转换成元组</span><br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>)<br></code></pre></td></tr></table></figure><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器是python最强大的功能之一，是访问集合元素的一种方式。</p><p>迭代器是一个可以记住遍历的位置的对象。</p><p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p><p>迭代器有两个基本方法：<code>iter()</code>和<code>next()</code>。</p><h6 id="字符串，列表或元组对象都可用于创建迭代器。"><a href="#字符串，列表或元组对象都可用于创建迭代器。" class="headerlink" title="字符串，列表或元组对象都可用于创建迭代器。"></a>字符串，列表或元组对象都可用于创建迭代器。</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>it = <span class="hljs-built_in">iter</span>(<span class="hljs-built_in">list</span>)    <span class="hljs-comment"># 创建迭代器对象</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span> (<span class="hljs-built_in">next</span>(it))   <span class="hljs-comment"># 输出迭代器的下一个元素</span><br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span> (<span class="hljs-built_in">next</span>(it))<br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h6 id="迭代器对象可以使用常规for语句进行遍历"><a href="#迭代器对象可以使用常规for语句进行遍历" class="headerlink" title="迭代器对象可以使用常规for语句进行遍历"></a>迭代器对象可以使用常规for语句进行遍历</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br> <br><span class="hljs-built_in">list</span>=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>it = <span class="hljs-built_in">iter</span>(<span class="hljs-built_in">list</span>)    <span class="hljs-comment"># 创建迭代器对象</span><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> it:<br>    <span class="hljs-built_in">print</span> (x, end=<span class="hljs-string">&quot; &quot;</span>)<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>也可以使用next()函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br> <br><span class="hljs-keyword">import</span> sys         <span class="hljs-comment"># 引入 sys 模块</span><br> <br><span class="hljs-built_in">list</span>=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>it = <span class="hljs-built_in">iter</span>(<span class="hljs-built_in">list</span>)    <span class="hljs-comment"># 创建迭代器对象</span><br> <br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-built_in">print</span> (<span class="hljs-built_in">next</span>(it))<br>    <span class="hljs-keyword">except</span> StopIteration:<br>        sys.exit()<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h4 id="创建一个迭代器"><a href="#创建一个迭代器" class="headerlink" title="创建一个迭代器"></a>创建一个迭代器</h4><p>把一个类作为一个迭代器使用需要在类中实现两个方法<code>__iter__()</code>与<code>__next__()</code>。</p><p>Python的构造函数为<code>__init__()</code>，它会在对象初始化的时候执行。</p><p><code>__iter__()</code>方法返回一个特殊的迭代器对象，这个迭代器对象实现了<code>__next__()</code>方法并通过StopIteration异常标识迭代的完成。</p><p><code>__next__()</code>方法会返回下一个迭代器对象。</p><p>创建一个返回数字的迭代器，初始值为1，逐步递增1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyNumbers</span>:<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>    self.a = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> self<br> <br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):<br>    x = self.a<br>    self.a += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> x<br> <br>myclass = MyNumbers()<br>myiter = <span class="hljs-built_in">iter</span>(myclass)<br> <br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(myiter))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(myiter))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(myiter))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(myiter))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(myiter))<br></code></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h4 id="StopIteration"><a href="#StopIteration" class="headerlink" title="StopIteration"></a>StopIteration</h4><p>StopIteration异常用于标识迭代器的完成，防止无限出现无限循环的情况在<code>__next__()</code>方法中可以指定在完成指定循环次数后触发StopIteration异常来结束迭代。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">```<br><br><br><br><br><br><span class="hljs-comment">#### 遗！误！</span><br><br>```python<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">greetPerson</span>(<span class="hljs-params">*name</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>, name)<br>  <br>greetPerson(<span class="hljs-string">&#x27;Runoob&#x27;</span>, <span class="hljs-string">&#x27;Google&#x27;</span>)<br></code></pre></td></tr></table></figure><p>以上代码输出结果为？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">Hello Runoob<br>Hello Google<br></code></pre></td></tr></table></figure><p>加了*的参数会以元组（tuple）的形式导入，存放所有未命名的变量参数</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java面向对象</title>
    <link href="/2024/02/27/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2024/02/27/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承就是子类继承父类的特征和行为，使得子类对象具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p><p>如列门纲目科属种</p><p><img src="https://www.runoob.com/wp-content/uploads/2013/12/14B0951E-FC75-47A3-B611-4E1883887339.jpg" alt="原图来自菜鸟教程"></p><h4 id="类的继承格式"><a href="#类的继承格式" class="headerlink" title="类的继承格式"></a>类的继承格式</h4><p>Java中通过extends关键字可以申明一个类是从另外一个类继承而来的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">class 父类&#123;    <br>&#125;<br>class 子类 extends 父类&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="动物类"><a href="#动物类" class="headerlink" title="动物类"></a>动物类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Animal</span><span class="hljs-params">(String myName, <span class="hljs-type">int</span> myid)</span>&#123;<br>        name = myName;<br>        id = myid;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(name+<span class="hljs-string">&quot;正在吃&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(name+<span class="hljs-string">&quot;正在睡&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">introduction</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;大家好！我是&quot;</span> +id+<span class="hljs-string">&quot;号&quot;</span>+name+<span class="hljs-string">&quot;。&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="企鹅类"><a href="#企鹅类" class="headerlink" title="企鹅类"></a>企鹅类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Penguin</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Penguin</span><span class="hljs-params">(String myName,<span class="hljs-type">int</span> myid)</span>&#123;<br>        <span class="hljs-built_in">super</span>(myName, myid);<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="老鼠类"><a href="#老鼠类" class="headerlink" title="老鼠类"></a>老鼠类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Penguin</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Penguin</span><span class="hljs-params">(String myName,<span class="hljs-type">int</span> myid)</span>&#123;<br>        <span class="hljs-built_in">super</span>(myName, myid);<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="继承类型"><a href="#继承类型" class="headerlink" title="继承类型"></a>继承类型</h4><p><strong>Java不支持多继承，但是支持多重继承。</strong></p><p><img src="https://www.runoob.com/wp-content/uploads/2013/12/java-extends-2020-12-08.png" alt="img"></p><h4 id="继承的特性"><a href="#继承的特性" class="headerlink" title="继承的特性"></a>继承的特性</h4><ul><li>子类拥有父类非private的属性，方法。</li><li>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</li><li>子类可以勇自己的方法实现父类的方法。</li><li>提高了类之间的耦合性，也是继承的<strong>缺点</strong>，耦合度高就会造成代码之间的联系越紧密，代码独立性差</li></ul><h4 id="继承关键字"><a href="#继承关键字" class="headerlink" title="继承关键字"></a>继承关键字</h4><p>继承可以用extends和implements这两个关键字来实现继承，而且所有的类都是继承于java.lang.Object，当一个类没有继承的两个关键字，则默认Object祖先类</p><h5 id="implements关键字"><a href="#implements关键字" class="headerlink" title="implements关键字"></a>implements关键字</h5><p>使用implements关键字可以变相的使java具有多继承的特性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">A</span>,B &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="super与this关键字"><a href="#super与this关键字" class="headerlink" title="super与this关键字"></a>super与this关键字</h5><p>super关键字：可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类</p><p>this关键字： 指向自己的引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;animal:eat&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;dog:eat&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">eatTest</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.eat();<span class="hljs-comment">//调用自己的方法</span><br>        <span class="hljs-built_in">super</span>.eat();<span class="hljs-comment">//调用父类方法</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestExtands</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>();<br>        a.eat();   <br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        d.eatTest();<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">animal:eat<br>dog:eat<br>animal:eat<br></code></pre></td></tr></table></figure><h5 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h5><p>final可以用来修饰变量（包括类属性、对象属性、局部变量和形参）、方法（包括类方法和对象方法）和类。</p><p>如果使用final来声明类，就是把类定义为最终类，不能被继承，或者用于修饰方法，该方法不能被子类重写。</p><ul><li>声明类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> class 类名 &#123;<span class="hljs-comment">/*类体*/</span>&#125;<br></code></pre></td></tr></table></figure><ul><li>声明方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-keyword">final</span> 返回值类型 方法名（）&#123;方法体&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《数据结构与算法分析 Java语言描述》</title>
    <link href="/2024/02/26/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%20Java%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/02/26/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%20Java%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>第3章 表、栈和队列</p><p>3.2.1 表的简单数组实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> [] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>    <span class="hljs-type">int</span> [] newArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length*<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++)<br>        newArr[i] = arr[i];<br>    arr = newArr;<br></code></pre></td></tr></table></figure><p>表Lists</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; arrayList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-comment">//顺序表</span><br>List&lt;Integer&gt; linkList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><span class="hljs-comment">//链表</span><br></code></pre></td></tr></table></figure><p>集合Sets</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;String&gt; hashSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 无序集合，基于HashMap实现</span><br><span class="hljs-comment">* 高效的查找和插入操作</span><br><span class="hljs-comment">* 不保证顺序</span><br><span class="hljs-comment">*/</span><br>Set&lt;String&gt; treeSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>3.2.2 简单链表</p><p>3.3 Java collections API 中的表</p><p>表ADT是在Collections API中实现的数据结构之一</p><p>3.3.1 Collection接口</p><p>Collections API 位于java.util包中。集合（collection）的概念在Collecion接口中得到抽象，它存储一组类型相同的对象。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java网络编程</title>
    <link href="/2024/02/24/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/02/24/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>ping</p><p>用来测试数据包能否透过IP协议到达特定主机。ping会向目标主机发出一个ICMP的请求回显数据包，并等待接收回显响应数据包。</p><p>socket</p><p>Java的客户端套接字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>(<span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;bbs.newsmth.net&quot;</span>,<span class="hljs-number">23</span>);)&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java Stream</title>
    <link href="/2024/02/24/Java%20Stream/"/>
    <url>/2024/02/24/Java%20Stream/</url>
    
    <content type="html"><![CDATA[<p>为了解放程序员操作集合（Colletction）时的生产力，其出现归功于同时期出现的Lambda表达式，极大的提高了编程效率和程序可读性。</p><h3 id="什么是Stream？"><a href="#什么是Stream？" class="headerlink" title="什么是Stream？"></a>什么是Stream？</h3><p>Stream就像一个高级迭代器，但只能遍历一次，在流的过程中，队流中的元素执行一些操作。</p><p>想要操作流，首先需要有一个数据源，可以是数组或者集合。每次操作都会返回一个新的流对象，方便进行链式操作，但原有的流对象会保持不变。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java常用工具类</title>
    <link href="/2024/02/22/Java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <url>/2024/02/22/Java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h3><p>扫描控制台输入的工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<span class="hljs-comment">//创建Scanner对象，从标准输入流中读取数据</span><br>System.out.println(<span class="hljs-string">&quot;请输入一个整数&quot;</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> scanner.nextInt();<span class="hljs-comment">//获取用户输入的整数</span><br>System.out.println(<span class="hljs-string">&quot;您输入的整数是&quot;</span>+num);<br>scanner.nextLine();<span class="hljs-comment">//读取换行符，避免下一次读取</span><br>System.out.println(<span class="hljs-string">&quot;请输入一个字符串:&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> scanner.nextLine();<span class="hljs-comment">//获取用户输入的字符串</span><br>System.out.println(<span class="hljs-string">&quot;您输入的字符串是:&quot;</span>+str);<br>scanner.close();<span class="hljs-comment">//关闭sacanner对象</span><br></code></pre></td></tr></table></figure><p>其中System.in返回的是一个字节输入流InputStream</p><p><code>nextLine()</code>方法</p><h3 id="IpUtil"><a href="#IpUtil" class="headerlink" title="IpUtil"></a>IpUtil</h3><p>获取本机IP</p><p>基本方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>quest2激活</title>
    <link href="/2024/02/22/quest2%E6%BF%80%E6%B4%BB/"/>
    <url>/2024/02/22/quest2%E6%BF%80%E6%B4%BB/</url>
    
    <content type="html"><![CDATA[<ul><li><p>pc端使用clash进行代理，需使用支持UDP的代理</p></li><li><p>打开Allow LAN模式，允许局域网连接</p></li><li><p>确保quest2和pc连接在同一网络下</p></li><li><p>记住clash代理的端口和pc的ip地址</p></li><li><p>在quest2连接网络的时候高级设置，手动配置代理，地址为pc端wlan的ip地址，端口为代理端口</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>quest2</tag>
      
      <tag>vr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Arch Linux 安装过程记录</title>
    <link href="/2024/02/12/Arch%20Linux%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/02/12/Arch%20Linux%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>上次是直接安装在老旧笔记本电脑上的，没有进行记录，这次在虚拟机virtual box上安装一下复习一下</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Arch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL数据库</title>
    <link href="/2024/01/30/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2024/01/30/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install mysql-server mysql-client -y<br></code></pre></td></tr></table></figure><p>随即出现问题，执行<code>mysql -uroot -p</code>时出现如下报错</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">ERROR </span>2002 (HY000): Can&#x27;t connect to local MySQL server through socket &#x27;/var/run/mysqld/mysqld.sock&#x27; (2)<br></code></pre></td></tr></table></figure><p>可能原因</p><ul><li>没有启动MySQL服务</li></ul><p>解决方法</p><p>根据&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf文档的内容修改&#x2F;etc&#x2F;mysql&#x2F;my.cnf文档，具体内容如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">[mysqld]<br>datadir=/var/lib/mysql<br>basedir=/usr<br>socket=/var/run/mysqld/mysqld.sock<br>user=mysql<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Disabling symbolic-links is recommended to prevent assorted security risks</span><br>symbolic-links=0<br><br>[mysqld_safe]<br>log-error=/var/log/mysqld.log<br>pid-file=/var/run/mysqld/mysqld.pid<br><br>[client]<br>port=3306<br>socket=/var/run/mysqld/mysqld.sock<br></code></pre></td></tr></table></figure><p>修改后直接<code>mysql -u root -p</code>成功运行</p><h3 id="SQL语法"><a href="#SQL语法" class="headerlink" title="SQL语法"></a>SQL语法</h3><p>SQL对大小写不敏感，SELECT和select是不同的。</p><p>某些数据库系统要求在每条SQL语句末端使用分号，这样就可以在对服务器的相同请求中执行一条以上的SQL语句。</p><h3 id="一些重要的SQL命令"><a href="#一些重要的SQL命令" class="headerlink" title="一些重要的SQL命令"></a>一些重要的SQL命令</h3><ul><li><p><strong>SELECT</strong> 从数据库中提取数据</p></li><li><p><strong>UPDATE</strong> 更新数据库中的数据</p></li><li><p><strong>DELETE</strong> 从数据库中删除数据</p></li><li><p><strong>INSERT INTO</strong> 向数据库中插入新数据</p></li><li><p><strong>CREATE DATABASE</strong> 创建新数据库</p></li><li><p><strong>ALTER DATABASE</strong> 修改数据库</p></li><li><p><strong>CREATE TABLE</strong> 创建新表</p></li><li><p><strong>ALTER TABLE</strong> 变更（改变）数据表</p></li><li><p><strong>DROP TABLE</strong> 删除表</p></li><li><p><strong>CREATE INDEX</strong> 创建索引 （搜索键）</p></li><li><p><strong>DROP INDEX</strong> 删除索引</p></li></ul><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul><li><strong>数据库</strong> 关联表的集合</li><li><strong>数据表</strong> 数据的矩阵。在一个数据库中的表看起来像是一个简单的电子表格。</li><li><strong>冗余</strong> 存储两倍数据，冗余降低了性能，但提高了数据的安全性。</li><li><strong>主键</strong> 主键是唯一的，一个数据表中只能包含一个主键。</li><li><strong>外键</strong> 用于关联两个表</li><li><strong>复合键</strong> 符合键将多个列作为一个索引键，一般用于复合索引</li></ul><h3 id="数据库增删改查"><a href="#数据库增删改查" class="headerlink" title="数据库增删改查"></a>数据库增删改查</h3><h4 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">写mysql语句的时候要加分号;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">&gt;  show databases<br>-&gt; show databases;<br></code></pre></td></tr></table></figure><p>报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;show databases&#x27; at line 2<br></code></pre></td></tr></table></figure><p>问题</p><p>错误代码1064对应的是语法错误</p><p>第一行没有加分号导致被识别为两行了，重起一行写<code>show databases</code>解决</p><h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">creat database 数据库名<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>如：<code>creat database test;</code></p><p>提示<code>Query OK, 1 row affected (0.02 sec)</code>则说明创建成功</p><p>通常会在创建数据库的时候加上<code>if not exist</code>否则当数据库已经存在的时候会报<code>database exist</code>的错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create database if not exists test;<br></code></pre></td></tr></table></figure><p>这样在再次创建同名数据库的时候就会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ERROR 1007 (HY000): Can&#x27;t create database &#x27;test&#x27;; database exists<br></code></pre></td></tr></table></figure><h4 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">use 数据名;<br></code></pre></td></tr></table></figure><p>如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">use test;<br></code></pre></td></tr></table></figure><p>如果提示<code>Database changed</code>则说明切换成功了。</p><p>只有切换到相应数据库下，才能对相应数据库下面的表进行操作。</p><h4 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop database 数据库名;<br></code></pre></td></tr></table></figure><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop database test;<br></code></pre></td></tr></table></figure><p>提示<code>Query OK, 0 rows affected (0.25 sec)</code>则说明成功。</p><p>还可以加上<code>if exists</code>以避免数据库不存在的时候报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop database if exists test;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show processlist;<br>查看当前MySQL被多少个客户端连接了<br>show varables like &#x27;wait_timeout&#x27;;<br>查看Mysql定义的连接最大空闲时长，如果空闲连接超过了这个时长，连接器会自动将其断开<br></code></pre></td></tr></table></figure><h3 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h3><p>语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE table_name (<br>    column1 datatype,<br>    column2 datatype,<br>    ...<br>);<br></code></pre></td></tr></table></figure><p>下面是一个实例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE users (<br>id INT AUTO_INCREMENT PRIMARY KEY,<br>    username VARCHAR(50) NOT NULL,<br>    email VARCHAR(100) NOT NULL,<br>   birthdate DATE,<br>    is_active BOOLEAN DEFAULT TRUE<br>);<br></code></pre></td></tr></table></figure><ul><li>id 用户id，整数类型，自增长，作为主键</li><li>username 用户名，变长字符串，不允许为空</li><li>email 用户邮箱，边长字符串，不允许为空</li><li>birthdate 用户的生日，日期类型</li><li>is_active 用户是否已经激活，布尔类型，默认值为true</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>整蛊的程序反馈</title>
    <link href="/2024/01/04/%E6%95%B4%E8%9B%8A%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%8F%8D%E9%A6%88/"/>
    <url>/2024/01/04/%E6%95%B4%E8%9B%8A%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%8F%8D%E9%A6%88/</url>
    
    <content type="html"><![CDATA[<ul><li><p>Something went wrong</p><p>“介不对吧介个”</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java基础</title>
    <link href="/2024/01/01/Java%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/01/01/Java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>虽然很早就因为想要写个自己的app来接触过java了，但是因为看到java连写个hello，world都冗杂成这样导致对java一直兴趣缺缺</p><hr><h3 id="问题-回答"><a href="#问题-回答" class="headerlink" title="问题&amp;回答"></a>问题&amp;回答</h3><ul><li><p>JDK和OpenJDK有什么区别？安装哪个？安装过程？</p><ul><li><p>区别就像是google的pixel和开源的安卓系统，openjdk可以被任何公司拿过来魔改自己的版本，就像linux，但是Oracle收购了sun因此可以用java的商标，它的版本有一些私有类库，面向企业的版本又称Java EE</p></li><li><p>在Linux中运行<code>snap install openjdk</code>后无法直接使用，在终端运行<code>openjdk</code>，将输出OpenJDK的配置文件地址，如<code>/var/snap/openjdk/common/openjdk.env</code></p></li><li><p>用vim复制此文件中的内容并粘贴到<code>/etc/prifile</code>文末</p></li><li><p>用<code>source /etc/profile</code>重新加载环境变量即可</p></li></ul></li><li><p>vscode运行helloworld.java后生成了helloworld.class文件，这是个啥？</p><p>通过javac编译java源文件生成的字节码文件，在linux上是以下步骤</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">javac </span>HelloWorld.<span class="hljs-keyword">java</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">java </span>HelloWorld<br>Hello,World!<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="第一个程序"><a href="#第一个程序" class="headerlink" title="第一个程序"></a>第一个程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello,World!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="问题和回答"><a href="#问题和回答" class="headerlink" title="问题和回答"></a>问题和回答</h3><ul><li><p>为什么String args[]和String[] args写法都可以但是菜鸟教程推荐第二种且可以避免歧义和误读？</p><p>如果写<code>String args[]</code>可以生成一个字符串数组，但是当写<code>String args[],args2</code>的时候，可能会被误读为定义了两个字符串数组，但是实际上定义了一个字符串数组和一个字符串，<code>String[] args,args2</code>即可生成两个字符串</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        System.out.println(args[<span class="hljs-number">0</span>]);<span class="hljs-comment">//打印输出数组的第一项内容</span><br>    &#125;<br>&#125;<br><br>java Test hello<span class="hljs-comment">//相当于将一个hello字符串传入数组，main是一个程序的入口，一个java程序运行必须有且仅有一个main方法</span><br>java Test aaa <span class="hljs-string">&quot;b  b b&quot;</span> ccc<span class="hljs-comment">//传入多个参数之间需要用空格隔开，需要包含空格的参数要用&quot;&quot;</span><br></code></pre></td></tr></table></figure><ul><li><strong>public</strong>:程序的访问权限，表示任何场合都可以被引用</li><li><strong>static</strong>:表明方法是静态的，不依赖类的对象的，是属于类的，在加载的时候main()方法也随着加载到内存中</li><li><strong>void main</strong>:方法不需要返回值</li></ul><hr><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul><li><strong>大小写</strong>: Hello和hello不同</li><li><strong>类名</strong>: 类名的首字母要大写，若其由若干单词组成，则每个单词的首字母要大写</li><li><strong>方法名</strong>: 方法名都应以小写字母开头，如果方法名含有若干单词，则后面的每个单词首字母大写</li><li><strong>源文件名</strong>: 源文件名必须和类名相同</li><li><strong>主方法入口</strong>: Java程序由<code>public static void main(String[] args)</code>方法开始执行</li></ul><hr><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li>局部变量</li><li>类变量（静态变量）</li><li>成员变量（非静态变量）</li></ul><hr><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//单行注释</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">多行注释</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">*一个文档注释，以&quot;/**&quot;开始，&quot;*/</span><span class="hljs-string">&quot;结束.</span><br><span class="hljs-string">*这种方式书写的代码可以被JavaDoc等工具提取并生成API文档</span><br><span class="hljs-string">*</span><br><span class="hljs-string">*/</span><br></code></pre></td></tr></table></figure><hr><h3 id="支持的概念"><a href="#支持的概念" class="headerlink" title="支持的概念"></a>支持的概念</h3><ul><li><strong>多态</strong></li><li><strong>继承</strong></li><li><strong>封装</strong></li><li><strong>抽象</strong></li><li><strong>类</strong></li><li><strong>对象</strong></li><li><strong>实例</strong></li><li><strong>方法</strong></li><li><strong>重载</strong></li></ul><hr><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>&#123;<br>    String breed;<br>    <span class="hljs-type">int</span> size;<br>    String colour;<br>    <span class="hljs-type">int</span> age;<span class="hljs-comment">//成员变量</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> classvariable;<span class="hljs-comment">//类变量</span><br>    <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//局部变量</span><br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">name</span><span class="hljs-params">()</span>&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Puppy</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Puppy</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-comment">//这个构造器仅有一个参数name</span><br>        System.out.println(<span class="hljs-string">&quot;小狗的名字是：&quot;</span>+name);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//下面的语句将创建一个Puppy对象</span><br>        <span class="hljs-type">Puppy</span> <span class="hljs-variable">myPuppy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Puppy</span>(<span class="hljs-string">&quot;tommy&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="问题-解决"><a href="#问题-解决" class="headerlink" title="问题&amp;解决"></a>问题&amp;解决</h3><ul><li><p>错误: 编码 GBK 的不可映射字符 (0x80)</p><p>用<code>javac -encoding UTF-8 myfilename.java</code>命令来编译我的java文件</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Puppy</span>&#123;<br>    <span class="hljs-type">int</span> puppyAge;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Puppy</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-comment">//这个构造器仅有一个参数name</span><br>        System.out.println(<span class="hljs-string">&quot;小狗的名字是：&quot;</span>+name);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span>&#123;<br>        puppyAge=age;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;小狗的年龄是：&quot;</span>+puppyAge+<span class="hljs-string">&quot;岁&quot;</span>);<br>        <span class="hljs-keyword">return</span> puppyAge;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//创建对象</span><br>        Puppy myPuppy=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Puppy</span>(<span class="hljs-string">&quot;tommy&quot;</span>);<br>        <span class="hljs-comment">//通过方法来设定年龄</span><br>        myPuppy.setAge(<span class="hljs-number">2</span>);<br>        <span class="hljs-comment">//调用另一个方法来获取年龄</span><br>        muPuppy.getAge();<br>        <span class="hljs-comment">//也可以用这种方法来访问成员变量名</span><br>        System.out.println(<span class="hljs-string">&quot;狗子的年龄:&quot;</span>+myPuppy.puppyAge);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="源文件声明规则"><a href="#源文件声明规则" class="headerlink" title="源文件声明规则"></a>源文件声明规则</h3><ul><li>一个源文件中只能有一个public类</li><li>一个源文件可以有多个非public类</li><li>源文件名和public类的类名保持一致</li><li>如果一个类定义在某个包中，那么package语句应该在源文件的首行</li><li>如果源文件包含import语句，则应放在package和类定义之间，如果没有package语句，则import放在首行</li><li>import语句和package语句对源文件中定义的所有类都有效，在同一源文件中不能给不同的类不同的包声明<strong>（？）</strong></li></ul><h3 id="import语句"><a href="#import语句" class="headerlink" title="import语句"></a>import语句</h3><p>载入java_installation&#x2F;java&#x2F;io路径下的所有类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br></code></pre></td></tr></table></figure><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>Employee.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    String designation;<br>    <span class="hljs-type">double</span> salary;<br>    <span class="hljs-comment">//Employee类的构造器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Employee</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>    &#125;<br>    <span class="hljs-comment">//设置age的值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">empAge</span><span class="hljs-params">(<span class="hljs-type">int</span> empAge)</span>&#123;<br>        age=empAge;<br>    &#125;<br>    <span class="hljs-comment">//设置designation的值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">empDesignation</span><span class="hljs-params">(String empDesig)</span>&#123;<br>        designation=empDesig;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">empSalary</span><span class="hljs-params">(<span class="hljs-type">double</span> empSalary)</span>&#123;<br>        salary=empSalary;<br>    &#125;<br>    <span class="hljs-comment">//打印信息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printEmployee</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;名字:&quot;</span>+name);<br>        System.out.println(<span class="hljs-string">&quot;年龄:&quot;</span>+age);<br>        System.out.println(<span class="hljs-string">&quot;职位:&quot;</span>+designation);<br>        System.out.println(<span class="hljs-string">&quot;薪水:&quot;</span>+salary);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>EmployeeTest.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmployeeTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//使用创造器创建两个对象</span><br>        Employee empOne=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;RUNOOB1&quot;</span>);<br>        Employee empTwo=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;RUNOOB2&quot;</span>);<br>        <span class="hljs-comment">//调用这两个对象的成员方法</span><br>        empOne.empAge(<span class="hljs-number">26</span>);<br>        empOne.empDesignation(<span class="hljs-string">&quot;高级程序员&quot;</span>);<br>        empOne.empSalary(<span class="hljs-number">1000</span>);<br>        empOne.printEmployee();<br><br>        empTwo.empAge(<span class="hljs-number">21</span>);<br>        empTwo.empDesignation(<span class="hljs-string">&quot;菜鸟程序员&quot;</span>);<br>        empTwo.empSalary(<span class="hljs-number">500</span>);<br>        empTwo.printEmployee();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Java基本数据类型"><a href="#Java基本数据类型" class="headerlink" title="Java基本数据类型"></a>Java基本数据类型</h3><p>java提供了两种数据类型</p><ul><li>内置数据类型</li><li>引用数据类型</li></ul><h4 id="内置数据类型"><a href="#内置数据类型" class="headerlink" title="内置数据类型"></a>内置数据类型</h4><p>java提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，一种布尔型</p><h5 id="byte："><a href="#byte：" class="headerlink" title="byte："></a>byte：</h5><ul><li>byte数据类型是8位，有符号的，以二进制补码表示的整数；</li><li>最小值是<code>-128(-2^7)</code>;</li><li>最大值是<code>127(2^7 -1);</code></li><li>默认值是<code>0</code>;</li><li>byte类型勇者大型数组中节约空间，主要代替整数，因为byte变量占用的空间只有int类型的四分之一；</li><li><code>byte a=100, byte b=-50</code></li></ul><h5 id="short"><a href="#short" class="headerlink" title="short:"></a>short:</h5><ul><li>short数据类型是16位，有符号以二进制补码表示的整数</li><li>最小值是<code>-32768（-2^15）</code></li><li>最大值是<code>327667（2^15 -1）</code></li><li>short数据类型也可以像byte那样节省空间，一个short变量是int类型所占空间的二分之一</li><li>默认值是<code>0</code></li><li><code>short s=1000, short r=-20000</code></li></ul><h5 id="int"><a href="#int" class="headerlink" title="int:"></a>int:</h5><ul><li>int数据类型是32位、有符号的以二进制补码表示的整数</li><li>最小值是<code>-2,147,483,648(-2^31)</code>;</li><li>最大值是<code>2,147,483,647(2^31 -1)</code>;</li><li>一般地整型标量默认为int类型；</li><li>默认值是<code>0</code></li><li><code>int a=100000 int b=-200000</code></li></ul><h5 id="long"><a href="#long" class="headerlink" title="long:"></a>long:</h5><ul><li>long数据类型是64位，有符号的以二进制补码表示的整数</li><li>最小值是<code>-9，223，372，036，854，775，808（-2^63）</code>；</li><li>最大值是<code>9,223,372,036,854,775,807(2^63 -1)</code>;</li><li>这种类型主要用在比较大整数的系统上</li><li>默认值是<code>0L</code>;</li><li><code>long a=100000L long b=-200000L</code></li><li>L不分大小写，最好写成大写</li></ul><h5 id="float"><a href="#float" class="headerlink" title="float:"></a>float:</h5><ul><li>float数据类型是单精度32位符合IEEE 754标准的浮点数</li><li>float在储存大型浮点数的时候可以节省内存空间</li><li>默认值是<code>0.0f</code></li><li>浮点数不能用来表示精确的值，如货币</li><li>float f1&#x3D;234.5f</li></ul><h5 id="double"><a href="#double" class="headerlink" title="double:"></a>double:</h5><ul><li><p>double数据类型是双精度64位符合IEEE 754标准的浮点数</p></li><li><p>浮点数默认类型为double类型</p></li><li><p>double类型同样不能表示精确的值，如货币</p></li><li><p>默认值是<code>0.0d</code></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">double d1<span class="hljs-operator">=</span><span class="hljs-number">7</span>D<span class="hljs-comment">;</span><br>double d2<span class="hljs-operator">=</span><span class="hljs-number">7</span>.<span class="hljs-comment">;</span><br>double d3<span class="hljs-operator">=</span><span class="hljs-number">8.0</span><span class="hljs-comment">;</span><br>double d4<span class="hljs-operator">=</span><span class="hljs-number">8</span>.D<span class="hljs-comment">;</span><br>double d5<span class="hljs-operator">=</span><span class="hljs-number">12.9867</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="boolean："><a href="#boolean：" class="headerlink" title="boolean："></a>boolean：</h5><ul><li>boolean数据类型表示一位的信息</li><li>只有两个值：true和false</li><li>这种类型只作为一种标志来记录true&#x2F;false情况</li><li>默认值是<code>false</code></li><li><code>boolean one=true</code></li></ul><h5 id="char"><a href="#char" class="headerlink" title="char:"></a>char:</h5><ul><li>char类型是一个单一的16位Unicode字符</li><li>最小值是<code>\u0000</code>(十进制等效值为0)</li><li>最大值是<code>\uffff</code>(即为65535)</li><li>char数据类型可以存储任何字符</li><li><code>char letter=&#39;A&#39;</code></li></ul><h5 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrimitiveTypeTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//byte</span><br>        System.out.println(<span class="hljs-string">&quot;基本类型: byte 二进制位数：&quot;</span>+ Byte.SIZE);<br>        System.out.println(<span class="hljs-string">&quot;包装值: java.lang.Byte&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;最小值: Byte.MIN_VALUE=&quot;</span>+ Byte.MIN_VALUE);<br>        System.out.println(<span class="hljs-string">&quot;最大值: Byte.MAX_VALUE=&quot;</span>+Byte.MAX_VALUE);<br>        System.out.println();<br><br>        <span class="hljs-comment">//short</span><br>        System.out.println(<span class="hljs-string">&quot;基本类型: short 二进制位数: &quot;</span>+Short.SIZE);<br>        System.out.println(<span class="hljs-string">&quot;包装值: java.lang.Short&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;最小值: Short.MIN_VALUE=&quot;</span>+ Short.MIN_VALUE );<br>        System.out.println(<span class="hljs-string">&quot;最大值: Short.MAZ_VALUE=&quot;</span>+ Short.MAX_VALUE);<br>        System.out.println();<br><br>        <span class="hljs-comment">//int</span><br>        System.out.println(<span class="hljs-string">&quot;基本类型: int 二进制位数: &quot;</span>+ Integer.SIZE);<br>        System.out.println(<span class="hljs-string">&quot;包装值: java.lang.Integer&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;最小值: Integer.MIN_VALUE=&quot;</span>+ Long.MIN_VALUE);<br>        System.out.println(<span class="hljs-string">&quot;最大值: Integer.MAX_VALUE=&quot;</span>+ Long.MAX_VALUE);<br>        System.out.println();<br><br>        <span class="hljs-comment">//long</span><br>        System.out.println(<span class="hljs-string">&quot;基本类型: long 二进制位数&quot;</span>+ Long.SIZE);<br>        System.out.println(<span class="hljs-string">&quot;包装值: java.lang.long&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;最小值: Long.MIN_VALUE=&quot;</span>+ Long.MIN_VALUE);<br>        System.out.println(<span class="hljs-string">&quot;最大值: Long.MAX_VALUE=&quot;</span>+ Long.MAX_VALUE);<br>        System.out.println();<br><br>        <span class="hljs-comment">//float</span><br>        System.out.println(<span class="hljs-string">&quot;基本类型: float 二进制位数&quot;</span>+ Float.SIZE);<br>        System.out.println(<span class="hljs-string">&quot;包装值: java.lang.Float&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;最小值: Float.MIN_VALUE=&quot;</span>+Float.MIN_VALUE);<br>        System.out.println(<span class="hljs-string">&quot;最大值: FLoat.MAX_VALUE=&quot;</span>+Float.MAX_VALUE);<br>        System.out.println();<br><br>        <span class="hljs-comment">//double</span><br>        System.out.println(<span class="hljs-string">&quot;基本类型: double 二进制位数&quot;</span>+Double.SIZE);<br>        System.out.println(<span class="hljs-string">&quot;包装值: java.lang.Double&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;最小值: Double.MIN_VALUE=&quot;</span>+ Double.MIN_VALUE);<br>        System.out.println(<span class="hljs-string">&quot;最大值: Double.MAX_VALUE=&quot;</span>+Double.MAX_VALUE);<br>        System.out.println();<br><br>        <span class="hljs-comment">//char</span><br>        System.out.println(<span class="hljs-string">&quot;基本类型: char 二进制位数&quot;</span>+Character.SIZE);<br>        System.out.println(<span class="hljs-string">&quot;包装值: java.lang.Character&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;最小值: Character.MIN_VALUE=&quot;</span>+(<span class="hljs-type">int</span>)Character.MIN_VALUE);<span class="hljs-comment">//以数值形式而不是字符形式将Character.MIN_VALUE输出到控制台</span><br>        System.out.println(<span class="hljs-string">&quot;最大值: Character.MAX_VALUE=&quot;</span>+(<span class="hljs-type">int</span>)Character.MAX_VALUE);<br>        System.out.println();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h5 id="数学运算符"><a href="#数学运算符" class="headerlink" title="数学运算符"></a>数学运算符</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Math</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> b=<span class="hljs-number">20</span>;<br>        <span class="hljs-type">int</span> c=<span class="hljs-number">25</span>;<br>        <span class="hljs-type">int</span> d=<span class="hljs-number">25</span>;<br>        System.out.println(<span class="hljs-string">&quot;a+b=&quot;</span>+(a+b));<br>        System.out.println(<span class="hljs-string">&quot;a-b=&quot;</span>+(a-b));<br>        System.out.println(<span class="hljs-string">&quot;a*b=&quot;</span>+(a*b));<br>        System.out.println(<span class="hljs-string">&quot;b/a=&quot;</span>+(b/a));<br>        System.out.println(<span class="hljs-string">&quot;b%a=&quot;</span>+(b%a));<br>        System.out.println(<span class="hljs-string">&quot;a++ =&quot;</span>+(a++));<br>        System.out.println(<span class="hljs-string">&quot;a-- =&quot;</span>+(a--));<br>        System.out.println(<span class="hljs-string">&quot;++a=&quot;</span>+(++a));<br>        <span class="hljs-comment">//++a是先进行自增或自减运算，再进行表达式运算</span><br>        <span class="hljs-comment">//a++是先进行表达式运算，再进行自增或自减运算</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><ul><li>while循环</li><li>do…while循环</li><li>for循环</li></ul><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(布尔表达式)&#123;<br>    <span class="hljs-comment">//循环内容</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Test.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">int</span> x=<span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">while</span>(x&lt;<span class="hljs-number">20</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;value of x: &quot;</span>+x);<br>            x++;<br>            System.out.println(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="do…while"><a href="#do…while" class="headerlink" title="do…while"></a>do…while</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">do</span>&#123;<br>    <span class="hljs-comment">//代码语句</span><br>&#125;<span class="hljs-keyword">while</span>(布尔表达式);<br></code></pre></td></tr></table></figure><p>布尔表达式在循环体的后面，所以语句块在检测布尔表达式之前已经执行了。如果布尔表达式的值为true，则语句块一直执行，直到表达式的值为false</p><p>Test.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">int</span> x=<span class="hljs-number">10</span>;<br>        <br>        <span class="hljs-keyword">do</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;value of x: &quot;</span>+x);<br>            x++;<br>            System.out.pritn(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<span class="hljs-keyword">while</span>(x&lt;<span class="hljs-number">20</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(初始化;布尔表达式;更新)&#123;<br>    <span class="hljs-comment">//代码语句</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Test.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=<span class="hljs-number">10</span>;x&lt;<span class="hljs-number">20</span>;x=x+<span class="hljs-number">1</span>)&#123;<br>            System.out.print(<span class="hljs-string">&quot;value of x:&quot;</span>+x);<br>            System.out.print(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(声明语句 : 表达式)&#123;<br>    <span class="hljs-comment">//代码句子</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Test.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">int</span> [] numbers=&#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>&#125;;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x : numbers )&#123;<br>            System.out.print(x);<br>            System.out.print(<span class="hljs-string">&quot;,&quot;</span>);<br>        &#125;<br>        System.out.print(<span class="hljs-string">&quot;\n&quot;</span>);<br>        String [] names = &#123;<span class="hljs-string">&quot;James&quot;</span>,<span class="hljs-string">&quot;Larry&quot;</span>,<span class="hljs-string">&quot;Tom&quot;</span>,<span class="hljs-string">&quot;Lacy&quot;</span>&#125;;<br>        <span class="hljs-keyword">for</span>(String name : names)&#123;<br>            System.out.print(name);<br>            System.out.print(<span class="hljs-string">&quot;,&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="break关键字"><a href="#break关键字" class="headerlink" title="break关键字"></a>break关键字</h4><p>Test.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">int</span> [] numbers=&#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>&#125;;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x : numbers)&#123;<br>            <span class="hljs-keyword">if</span>(x==<span class="hljs-number">30</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            System.out.print(x);<br>            System.out.print(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">10</span><br><span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><h4 id="continue关键字"><a href="#continue关键字" class="headerlink" title="continue关键字"></a>continue关键字</h4><p>Test.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">int</span> [] numbers==&#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>&#125;;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x : nubmers)&#123;<br>            <span class="hljs-keyword">if</span>(x==<span class="hljs-number">30</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            System.out.print(x);<br>            System.out.print(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">10<br>20<br>40<br>50<br></code></pre></td></tr></table></figure><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><h4 id="if…else"><a href="#if…else" class="headerlink" title="if…else"></a>if…else</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(布尔表达式)&#123;<br>    <span class="hljs-comment">//如果布尔表达式为true将执行的语句</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-comment">//如果布尔表达式为false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Test.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">int</span> x=<span class="hljs-number">30</span>;<br>        <br>        <span class="hljs-keyword">if</span>(x==<span class="hljs-number">10</span>)&#123;<br>            System.out.print(<span class="hljs-string">&quot;Value of X is 10&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x==<span class="hljs-number">20</span>)&#123;<br>            System.out.print(<span class="hljs-string">&quot;Value of X is 20&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x==<span class="hljs-number">30</span>)&#123;<br>            System.out.print(<span class="hljs-string">&quot;Value of x is 30&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.print(<span class="hljs-string">&quot;这是else语句&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="嵌套的if…else语句"><a href="#嵌套的if…else语句" class="headerlink" title="嵌套的if…else语句"></a>嵌套的if…else语句</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(布尔表达式<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-keyword">if</span>(布尔表达式<span class="hljs-number">2</span>)&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Test.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">int</span> x=<span class="hljs-number">30</span>;<br>        <span class="hljs-type">int</span> y=<span class="hljs-number">10</span>;<br>        <br>        <span class="hljs-keyword">if</span>(x==<span class="hljs-number">30</span>)&#123;<br>            <span class="hljs-keyword">if</span>(x==<span class="hljs-number">10</span>)&#123;<br>                System.out.print(<span class="hljs-string">&quot;X=30 and Y=10&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="switch-case语句"><a href="#switch-case语句" class="headerlink" title="switch case语句"></a>switch case语句</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span>(expression)&#123;<br>    <span class="hljs-keyword">case</span> value:<br>      <span class="hljs-comment">//语句</span><br>       <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> value:<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span> :    <br>&#125;<br></code></pre></td></tr></table></figure><p>Test.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">grade</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;C&#x27;</span>;<br>        <br>        <span class="hljs-keyword">switch</span>(grade)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;A&#x27;</span>:<br>                System.out.println(<span class="hljs-string">&quot;优秀&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;B&#x27;</span>:<br>                System.out.println(<span class="hljs-string">&quot;良好&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;C&#x27;</span>:<br>                System.out.println(<span class="hljs-string">&quot;及格&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;D&#x27;</span>:<br>                System.out.println(<span class="hljs-string">&quot;不及格&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span> :<br>                System.out.println(<span class="hljs-string">&quot;未知等级&quot;</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;你的等级是&quot;</span>+grade);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">及格<br>你的等级是<span class="hljs-built_in">C</span><br></code></pre></td></tr></table></figure><p>如果case语句块中没有break语句，匹配成功后会将匹配到的case项后面的所有项都输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">switch</span>(i)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                System.out.println(<span class="hljs-string">&quot;0&quot;</span>);<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                System.out.println(<span class="hljs-string">&quot;1&quot;</span>);<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                System.out.println(<span class="hljs-string">&quot;2&quot;</span>);<br>            <span class="hljs-keyword">default</span>:<br>                System.out.println(<span class="hljs-string">&quot;default&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>2<br>3<br></code></pre></td></tr></table></figure><h3 id="Number-Math类"><a href="#Number-Math类" class="headerlink" title="Number &amp; Math类"></a>Number &amp; Math类</h3><p><img src="https://www.runoob.com/wp-content/uploads/2013/12/OOP_WrapperClass.png" alt="Java Number类 (图片来自菜鸟教程)"></p><h4 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;90°的正弦值: &quot;</span>+Math.sin(Math.PI/<span class="hljs-number">2</span>));<br>        System.out.println(<span class="hljs-string">&quot;0°的余弦值: &quot;</span>+Math.cos(<span class="hljs-number">0</span>));<br>        System.out.println(<span class="hljs-string">&quot;60°的正切值: &quot;</span>+Math.tan(Math.PI/<span class="hljs-number">3</span>));<br>        System.out.println(<span class="hljs-string">&quot;1的反正切值: &quot;</span>+Math.atan(<span class="hljs-number">1</span>));<br>        System.out.println(<span class="hljs-string">&quot;Π/2的角度值: &quot;</span>+Math.toDegrees(Math.PI/<span class="hljs-number">2</span>));<br>        System.out.println(Math.PI);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Number-Math类方法"><a href="#Number-Math类方法" class="headerlink" title="Number &amp; Math类方法"></a>Number &amp; Math类方法</h4><h5 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        Integer x=<span class="hljs-number">5</span>;<br>        Integer y=<span class="hljs-number">10</span>;<br>        Integer z=<span class="hljs-number">5</span>;<br>        Short a=<span class="hljs-number">5</span>;<br>        <br>        System.out.println(x.equals(y));<br>        System.out.println(x.equals(z));<br>System.out.println(x.equals(a));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">false</span><br><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h5 id="问题和回答-1"><a href="#问题和回答-1" class="headerlink" title="问题和回答"></a>问题和回答</h5><ul><li><p>在写程序的时候，如果写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> a=<span class="hljs-number">1</span>,b=<span class="hljs-number">2</span>;<br>...<br>    System.out.println(a.equals(b));<br>...<br></code></pre></td></tr></table></figure><p>会报错<code>“Cannot invoke equals(int) on the primitive type int”</code>，意思是不能在基本类型int上调用<code>equals(int)</code>方法。</p><p>在Java中，基本类型如<code>int,double,char</code>等，不是对象，因此它们没有方法可以调用，<code>equals()</code>方法是一个对象方法，通常用于比较两个对象是否相等，如果非要比较两个基本类型并返回布尔值，可以用<code>a==b</code></p><p>但是这里如果这么写就没问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer x=<span class="hljs-number">5</span>;<br>Integer y=<span class="hljs-number">10</span>;<br>Integer z=<span class="hljs-number">5</span>;<br>Short a=<span class="hljs-number">5</span>;<br>...<br>    System.out.println(x.equals(y));<br>System.out.println(x.equals(z));<br>System.out.println(x.equals(a));<br></code></pre></td></tr></table></figure><p>这里使用的就是<code>Integer和Short</code>对象，<code>Integer</code>和<code>Short</code>都是包装类，分别对应<code>int</code>和<code>short</code>基本类型</p><p>当调用<code>x.equals(y)</code>的时候，实际上是在调用<code>Integer</code>对象的<code>equals()</code>方法</p><h4 id="abs"><a href="#abs" class="headerlink" title="abs()"></a>abs()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        Integer a=-<span class="hljs-number">8</span>;<br>        <span class="hljs-type">double</span> d=-<span class="hljs-number">100</span>;<br>        <span class="hljs-type">float</span> f=-<span class="hljs-number">90f</span>;<br>        <br>        System.out.println(Math.abs(a));<br>        System.out.println(Math.abs(d));<br>        System.out.println(Math.abs(f));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">8</span><br><span class="hljs-attribute">100</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">90</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="min"><a href="#min" class="headerlink" title="min()"></a>min()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        System.out.println(Math.min(<span class="hljs-number">12.123</span>,<span class="hljs-number">12.456</span>));<br>        System.out.println<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h3><h4 id="获取当前日期时间"><a href="#获取当前日期时间" class="headerlink" title="获取当前日期时间"></a>获取当前日期时间</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DateDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        Date date=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><br>        System.out.println(date.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="格式化输出当前日期"><a href="#格式化输出当前日期" class="headerlink" title="格式化输出当前日期"></a>格式化输出当前日期</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.text.*;<br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DateDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">dNow</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        SimpleDateFormat ft=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;当前时间为: &quot;</span>+ft.format(dNow));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>或者使用printf格式化输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DateFormateExample</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        Date date=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        System.out.printf(<span class="hljs-string">&quot;%tY-%tm-%td %tH:%tM:%tS %tZ&quot;</span>,date,date,date,date,date,date,date)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><table>    <thead>        <tr>            <th>转换符</th>            <th>说明</th>        </tr>    </thead>    <tbody>        <tr>            <td>%tc</td>            <td>包括全部日期和时间</td>        </tr>        <tr>            <td>%tF</td>            <td>年-月-日格式</td>        </tr>        <tr>            <td>%tD</td>            <td>年/月/日</td>        </tr>        <tr>            <td>%tr</td>            <td>12小时制 02:25:51 下午</td>        </tr>        <tr>            <td>%tT</td>            <td>24小时制 14:25:51</td>        </tr>        <tr>            <td>%tR</td>            <td>24小时制 14:25</td>        </tr>        <tr>            <td>%tY</td>            <td>四位数的年份</td>        </tr>        <tr>            <td>%tm</td>            <td>月份数字</td>        </tr>        <tr>            <td>%tB</td>            <td>月份全称（会用汉字）</td>        </tr>    </tr><tr>    <td>%te</td>    <td>一位数的日期24或2</td></tr></tr><tr>    <td>%td</td>    <td>两位数的日期24或02</td></tr><tr>    <td>%tA</td>    <td>星期的全名</td></tr></tr><tr>    <td>%tp</td>    <td>上午或者下午</td></tr><tr>    <td>%tH</td>    <td>24小时时制</td></tr></tr><tr>    <td>%tI</td>    <td>12小时时制但是12或06</td></tr><tr>    <td>%tl</td>    <td>12小时时制但是12或6</td></tr><tr>    <td>%tM</td>    <td>分钟数</td></tr><tr>    <td>%tS</td>    <td>秒数</td></tr></tr><tr>    <td>%tZ</td>    <td>时区</td></tr></tbody></table><h4 id="Sleep"><a href="#Sleep" class="headerlink" title="Sleep"></a>Sleep</h4><p>sleep()使当前吸纳从进入停滞状态（阻塞当前线程），让出CPU的使用，目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SleepDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">//System.out.println(new Date()+&quot;\n&quot;);</span><br>            System.out.printf(<span class="hljs-string">&quot;%tF %tT\n&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(),<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>            Thread.sleep(<span class="hljs-number">1000</span>*<span class="hljs-number">3</span>);<span class="hljs-comment">//休眠3秒</span><br>            System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()+<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;介不对吧介个&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="测量时间间隔"><a href="#测量时间间隔" class="headerlink" title="测量时间间隔"></a>测量时间间隔</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiffDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-type">long</span> start=System.currentTimeMillis();<br>            System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()+<span class="hljs-string">&quot;\n&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">5</span>*<span class="hljs-number">60</span>*<span class="hljs-number">10</span>);<br>            System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()+<span class="hljs-string">&quot;\n&quot;</span>);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>            <span class="hljs-type">long</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span>end-start;<br>            Long diffvalue=Long.valueOf(diff);<br>            <span class="hljs-type">double</span> diff2=diffvalue.doubleValue()/<span class="hljs-number">1000</span>;<br>            System.out.println(<span class="hljs-string">&quot;Difference is &quot;</span>+String.format(<span class="hljs-string">&quot;%.3f&quot;</span>,diff2)+<span class="hljs-string">&quot;s&quot;</span>);<br>        &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>            System.out.println(<span class="hljs-string">&quot;介不对啊介个&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="问题-解答"><a href="#问题-解答" class="headerlink" title="问题&amp;解答"></a>问题&amp;解答</h5><ul><li>为什么这里必须用Long对象转换为double数据的方式来解决精度问题？</li></ul><hr><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>例：<code>System.out.println()</code></p><ul><li>println()是一个方法</li><li>System是系统类</li><li>out是标准输出对象</li><li><code>System.out.println()</code>即调用系统类System中的标准输出对象out中的方法println()</li></ul><hr><h4 id="问题-解答-1"><a href="#问题-解答-1" class="headerlink" title="问题&amp;解答"></a>问题&amp;解答</h4><ul><li>Java的方法和C的函数有什么异同？<ul><li>Java的方法都是属于类或对象的，而C的函数是独立于类或对象的。因此Java方法必须通过类名或对象名来调用，而C的函数可以直接调用</li><li>Java的方法分为静态方法和实例方法，而C的函数只有一种</li><li>Java的方法有四种访问权限，分别是public、protected、private和默认；而C只有两种，分别是extern和static</li></ul></li></ul><h5 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 返回值类型 方法名(参数类型 参数名)&#123;<br>    方法体<br>    <span class="hljs-keyword">return</span> 返回值;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2013/12/D53C92B3-9643-4871-8A72-33D491299653.jpg" alt="(图像来自菜鸟教程)"></p><hr><h4 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h4><p>Java支持两种调用方法的方式，根据方法是否返回值来选择</p><p>当程序调用一个方法时，程序的控制权交给了被调用的方法。当被调用方法的放回语句执行或者到达方法体闭括号时侯交还控制权给程序。</p><ul><li><p>当方法返回一个值的时候，方法调用通常被当做一个值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">larger</span> <span class="hljs-operator">=</span> max(<span class="hljs-number">30</span>,<span class="hljs-number">40</span>);<br></code></pre></td></tr></table></figure></li><li><p>如果方法返回值是void，方法调用一定是一条语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul><p>例TestMax.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestMax</span> &#123;<br>    <span class="hljs-comment">/** 主方法 */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> max(i,j);<br>        System.out.println(i+<span class="hljs-string">&quot;和&quot;</span>+j+<span class="hljs-string">&quot;比较大的是: &quot;</span>+k);<br>    &#125;<br><br>    <span class="hljs-comment">/** 返回两个整数变量较大的值 */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> num1,<span class="hljs-type">int</span> num2)</span>&#123;<br>        <span class="hljs-type">int</span> result;<br>        <span class="hljs-keyword">if</span>(num1 &gt; num2)&#123;<br>            result = num1;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            result = num2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如何调用一个void方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestVoidMethod</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printGrade</span><span class="hljs-params">(<span class="hljs-type">double</span> score)</span>&#123;<br>        <span class="hljs-keyword">if</span>(score &gt;= <span class="hljs-number">90.0</span>)&#123;<br>            System.out.println(<span class="hljs-string">&#x27;A&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score&gt;=<span class="hljs-number">80.0</span>)&#123;<br>            System.out.println(<span class="hljs-string">&#x27;B&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score&gt;=<span class="hljs-number">70.0</span>)&#123;<br>            System.out.println(<span class="hljs-string">&#x27;C&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score&gt;=<span class="hljs-number">60.0</span>)&#123;<br>            System.out.println(<span class="hljs-string">&#x27;D&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&#x27;F&#x27;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用void方法的一定是一个语句</p><hr><h4 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h4><p>一个有意思的机制，比如我写了一个<code>public static int max(int num1,int num2)</code>的方法，然后又写了一个同名的<code>public static double max(double num1,double num2)</code>的方法，一般来说这在C里面是不成的，但是Java的重载功能可以让程序运行的时候，根据传递的参数的数据型来调用方法，Java的编译器会根据方法签名来判断哪个方法应该被调用</p><ul><li>重载的方法必须拥有不同的参数列表，不能仅仅依据修饰符或者返回类型的不同来重载方法</li></ul><h3 id="流-Stream-、文件-FIle-和IO"><a href="#流-Stream-、文件-FIle-和IO" class="headerlink" title="流(Stream)、文件(FIle)和IO"></a>流(Stream)、文件(FIle)和IO</h3><h4 id="读取控制台"><a href="#读取控制台" class="headerlink" title="读取控制台"></a>读取控制台</h4><h5 id="读取控制台输入"><a href="#读取控制台输入" class="headerlink" title="读取控制台输入"></a>读取控制台输入</h5><p>由<code>System.in</code>完成，可以把<code>System.in</code>包装在BufferedReader对象中来创建一个字符流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BRRead</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">( String[] args)</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>        <span class="hljs-type">char</span> c;<br>        <span class="hljs-comment">// 使用System.in 创建 BufferedReader</span><br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>        System.out.println(<span class="hljs-string">&quot;输入字符，按下&#x27;q&#x27;键退出。&quot;</span>);<br>        <span class="hljs-comment">// 读取字符</span><br>        <span class="hljs-keyword">do</span>&#123;<br>            c = (<span class="hljs-type">char</span>) br.read();<br>            System.out.println(c);<br>        &#125; <span class="hljs-keyword">while</span> (c!=<span class="hljs-string">&#x27;q&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="从控制台读取字符串"><a href="#从控制台读取字符串" class="headerlink" title="从控制台读取字符串"></a>从控制台读取字符串</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScannerDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-comment">//从键盘接收数据</span><br><br>        <span class="hljs-comment">// next方法接收字符串</span><br>        System.out.println(<span class="hljs-string">&quot;next方式接收:&quot;</span>);<br>        <span class="hljs-comment">// 判断是否还有输入</span><br>        <span class="hljs-keyword">if</span> (scan.hasNext())&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> scan.next();<br>            System.out.println(<span class="hljs-string">&quot;输入的数据为: &quot;</span>+str1);<br>        &#125;<br>        scan.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Intel/AMD命名规则</title>
    <link href="/2023/12/08/Intel%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/"/>
    <url>/2023/12/08/Intel%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/</url>
    
    <content type="html"><![CDATA[<p>&#x3D;&#x3D;$intel$&#x3D;&#x3D;酷睿&#x3D;&#x3D;$i5$&#x3D;&#x3D;-<strong>$12$</strong>&#x3D;&#x3D;$600$&#x3D;&#x3D;<strong>$K$</strong>&#x3D;&#x3D;$F$&#x3D;&#x3D;</p><ul><li><p><strong>Intel</strong> 是一款知名牙膏品牌</p></li><li><p><strong>酷睿</strong> 英特尔的CPU系列</p><table><thead><tr><th>Core</th><th>酷睿</th></tr></thead><tbody><tr><td><strong>Pentium</strong></td><td><strong>奔腾</strong></td></tr><tr><td><strong>Celeron</strong></td><td><strong>赛扬</strong></td></tr><tr><td><strong>Xeon</strong></td><td><strong>至强</strong></td></tr><tr><td><strong>Atom</strong></td><td><strong>凌动</strong></td></tr></tbody></table></li><li><p><strong>i5</strong> 中端定位，i3，i5，i7，i9，数字越大越强</p></li><li><p><strong>12</strong> 代数，数字越大越新</p></li><li><p><strong>600</strong> 性能，数字越大，频率越高</p></li><li><p><strong>B</strong> BGA封装的CPU，专为紧凑型设备开发</p><ul><li><strong>BGA</strong> 是一种CPU封装技术，</li></ul></li><li><p><strong>X</strong> 带X的表示支持XFR技术，自适应动态扩频，频率的最大值受到散热器散热效果而变化，<strong>散热器越强</strong>，<strong>频率越高</strong>。</p></li><li><p><strong>XT</strong> 相当于X的加强版</p></li></ul><p>$R5-5600G$</p><ul><li><strong>G</strong> 表示属于<strong>APU</strong>，内置强大的核显，如R5 5600G</li><li><strong>U</strong> 低电压，性能弱但功耗低，常见轻薄本</li><li><strong>H</strong> 低压，性能强，常见游戏本</li><li><strong>HX</strong> 一般使用在AMD高端发烧级CPU上，至尊版</li><li><strong>HS</strong> 相较于H工号更低，性能较强</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>上古互联网笑话</title>
    <link href="/2023/12/01/%E4%B8%8A%E5%8F%A4%E4%BA%92%E8%81%94%E7%BD%91%E7%AC%91%E8%AF%9D/"/>
    <url>/2023/12/01/%E4%B8%8A%E5%8F%A4%E4%BA%92%E8%81%94%E7%BD%91%E7%AC%91%E8%AF%9D/</url>
    
    <content type="html"><![CDATA[<ol><li><p>很久以前，那还是我用win98的时候有次我系统崩溃了，因为我是电脑白吃，我朋友给我介绍了一个高手来帮我修电脑。 他看了一下电脑，问我有没有98的盘，我说没有。 他想了一下，叫我把固定电话拿给他，我想修电脑要电话干什么，但人家是高手，我也不好说什么，就把电话拔下来给他了。 他把电话线空着的一头接在电脑的一个插孔内，然后进入了dos，然后就开始在电话上不停的按着键，他按键的速度非常快，但是只按0，1两个键，我搞不懂这有什么用，但也不敢问，看了半个多小时，他还是不停的按这两个键，我渐渐的有些困，我问他这东西要搞多久，他说要几个小时，我给他倒了杯茶，就一个人去隔壁睡觉了。 醒来的时候，一看已经过了4个多小时，我起身到隔壁，看见他正在98里面调试，过了一会儿，他说，你试试，我坐上椅子用了一下，真的好了，我当时也不懂电脑，谢过人家就走了。 后来我慢慢对电脑有了了解，终于了解，原来当时那位高手是用机器语言编了一个98系统，我后来问我朋友那位高手的下落，我朋友说前几年去了美国之后，杳无音讯….</p></li><li><p>很久以前，那还是我用winXP的时候有次我系统崩溃了，因为我是电脑白吃，我朋友给我介绍了一个高手来帮我修电脑。 他看了一下电脑，问我有没有XP的安装盘，我说没有。 他想了一下，叫我把一张空的DVD刻录盘和一根针拿给他，我想修电脑要刻录盘和针干什么，但人家是高手，我也不好说什么，就把DVD刻录盘拿一张来给他了。 他把针头对着刻录盘戳，他戳的速度非常快，但是只戳深或浅，我搞不懂这有什么用，但也不敢问，看了半个多小时，他还是不停的戳着DVD刻录盘，我渐渐的有些困，我问他这东西要搞多久，他说要几个小时，我给他倒了杯茶，就一个人去隔壁睡觉了。 醒来的时候，一看已经过了4个多小时，我起身到隔壁，看见他正在Xp里面调试，还装上了office、photoshop、迅雷、魔兽世界等软件……过了一会儿，他说，你试试，我坐上椅子用了一下，真的好了，我当时也不懂电脑，谢过人家就走了。 后来我慢慢对电脑有了了解，终于了解，原来当时那位高手是针头刻了一个单面双层的DVD，在里面刻上了Xp、office、photoshop、魔兽世界的安装程序，我后来问我朋友那位高手的下落，我朋友说前几年去了美国之后，杳无音讯….</p></li><li><p>很久以前，那还是我用winXP的时候有次我不小心把D盘格了，因为我是电脑白吃，我朋友给我介绍了一个高手来帮我恢复数据。 他看了一下电脑，问我有没有备份过Ghost，我说没有。 他想了一下，叫我把一块磁铁拿给他，还问我D盘里有什么东西，我想修电脑要磁铁干什么，但人家是高手，我也不好说什么，就把磁铁给他了，还告诉他我D盘里全是火影忍者的动画。 他把硬盘拆了，用磁铁在上面画圈，他画圈的速度非常快，但是只有碰到或不碰到，我搞不懂这有什么用，但也不敢问，看了半个多小时，他还是不停的在硬盘上画着圈，我渐渐的有些困，我问他这东西要搞多久，他说要几个小时，我给他倒了杯茶，就一个人去隔壁睡觉了。 醒来的时候，一看已经过了4个多小时，我起身到隔壁，看见他正在D盘里面调试，里面全是火影忍者的动画片，过了一会儿，他说，你试试，我坐上椅子用了一下，真的好了，我当时也不懂电脑，谢过人家就走了。 后来我慢慢对电脑有了了解，终于了解，原来当时那位高手是用磁铁直接在硬盘上写数据，凭着惊人的记忆力将火影忍者的动画片都写入了硬盘，我后来问我朋友那位高手的下落，我朋友说前几年去了美国之后，杳无音讯….</p></li><li><p>很久以前，那还是我在玩WOW的时候有次我不小心把60级T1的人物删了，因为我是游戏白吃，我朋友给我介绍了一个高手来帮我找回任务。 他看了一下电脑，问我有没有找过客服，我说没有。 他想了一下，叫我把一块石头给他，还问我人物什么职业，我想修复人物要石头干什么，但人家是高手，我也不好说什么，就把石头给他了，还告诉他我的人物已经有全套的T1。 他把硬盘拆了，并把石头放上去用手在上面搓，他搓的速度非常快，但是只有搓到和搓不到，我搞不懂这有什么用，但也不敢问，看了半个多小时，他还是不停的在石头上搓，我渐渐的有些困，我问他这东西要搞多久，他说要几个小时，我给他倒了杯茶，就一个人去隔壁睡觉了。 醒来的时候，一看已经过了4个多小时，我起身到隔壁，看见他正在打黑龙公主，身上已经有T2了，过了一会儿，他说，你试试，我坐上椅子用了一下，真的NB，我当时也不懂电脑，谢过人家就走了。 后来我慢慢对电脑有了了解，终于了解，原来当时那位高手是用手搓炉石回档呢，凭着惊人的速度搓热了炉石恢复了人物，我后来问我朋友那位高手的下落，我朋友说前几年去了暴雪之后，杳无音讯….</p></li><li><p>很久以前，那还是我用电脑的时候有次我不小心把cpu烧坏了了，因为我是电脑白吃，我朋友给我介绍了一个高手来帮我修电脑。 他看了一下电脑，问我有没有买新的cpu，我说没有。 他想了一下，叫我把一张香烟纸拿给他，还问我cpu是多少的，我想修电脑要香烟纸干什么，但人家是高手，我也不好说什么，就把香烟纸给他了，还告诉他我cpu是inter2.8g的。 他把cpu拆了，把香烟纸上的金属溥弄成一丝一丝的往cpu上粘，他粘的速度非常快，但是只有长的短的，我搞不懂这有什么用，但也不敢问，看了半个多小时，他还是不停的在cpu上贴香烟纸，我渐渐的有些困，我问他这东西要搞多久，他说要几个小时，我给他倒了杯茶，就一个人去隔壁睡觉了。 醒来的时候，一看已经过了4个多小时，我起身到隔壁，看见他正在调试，居然cpu已经弄到4.0g，过了一会儿，他说，你试试，我坐上椅子用了一下，真的好了，那个速度才叫速度，以前的简直叫蚂蚁爬，我当时也不懂电脑，谢过人家就走了。 后来我慢慢对电脑有了了解，终于了解，原来当时那位高手是用锡纸直接在cpu上做电路，凭着惊人的记忆力将烧掉的cpu重新排了一个微电路，我后来问我朋友那位高手的下落，我朋友说前几年去了美国之后，杳无音信…</p></li><li><p>很久以前，那还是我用普通照相机的时候有次我照相机坏了，找出来的照片不清楚。因为我是照相机白吃，我朋友给我介绍了一个高手来帮我修照相机。<br>他看了一下照相机，问我有没有维修手册，我说没有。<br>他想了一下，叫我把一块窗户玻璃拿给他，我想修照相机要玻璃干什么，但人家是高手，我也不好说什么，就把玻璃摘下来给他了。<br>他把玻璃敲碎了，拿起一小块，然后打开了照相机，然后就开始在地上不停的磨着玻璃，他磨的速度非常快，但是只有左右两下动作，我搞不懂这有什么用，但也不敢问，看了半个多小时，他还是不停的磨这两个玻璃，我渐渐的有些困，我问他这东西要搞多久，他说要几个小时，我给他倒了杯茶，就一个人去隔壁睡觉了。<br>醒来的时候，一看已经过了4个多小时，我起身到隔壁，看见他正在调试照相机，过了一会儿，他说，你试试，我拿过来用了一下，真的好了，我当时也不懂照相机，谢过人家就走了。<br>后来我慢慢对照相机有了了解，终于了解，原来当时我的镜头坏了，那位高手是用玻璃磨了一组镜头，我后来问我朋友那位高手的下落，我朋友说前几年去了美国之后，杳无音讯….</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笑话</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C/C++指针</title>
    <link href="/2023/11/29/C&amp;C++%E6%8C%87%E9%92%88/"/>
    <url>/2023/11/29/C&amp;C++%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C/C++数据结构</title>
    <link href="/2023/11/29/C&amp;C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2023/11/29/C&amp;C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h3 id="数组（array）"><a href="#数组（array）" class="headerlink" title="数组（array）"></a>数组（array）</h3><ol><li><p>数组中的元素在内存中处于相邻的位置</p></li><li><p>数组的长度是固定的，一旦创建之后长度是不会变的，向量和链表就会改变</p></li><li><p>数组支持随机访问，可以用a[i]访问第i个元素，时间复杂度只有O(1)，也就是常数时间，<strong>向量就能按[]访问，但是链表就不成，链表只能按照顺序访问</strong></p></li><li><p>可以把数组中间的数删掉，这种操作很慢，而且要将后面的元素向左移，需要O(n)的时间复杂度，n为数组长度，<strong>相比之下链表的好处在于可以删除任意元素，时间复杂度只有常数</strong></p></li></ol><h5 id="静态数组"><a href="#静态数组" class="headerlink" title="静态数组"></a>静态数组</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">char</span> a[<span class="hljs-number">6</span>]=&#123;<span class="hljs-string">&#x27;h&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;\0&#x27;</span>&#125;;<br><span class="hljs-comment">// 这里一开始写的是char a[5],会输出hellP&#x27;,</span><br><span class="hljs-comment">// 因为在C++中，字符数组是以&#x27;\0&#x27;为结尾的，</span><br><span class="hljs-comment">// 如果没有则会持续输出直到遇到&#x27;\0&#x27;为止，因此需要加上,或者手动在cout里添加</span><br></code></pre></td></tr></table></figure><h5 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">char</span>* b=<span class="hljs-literal">NULL</span>;<br><span class="hljs-type">int</span> n; <span class="hljs-comment">//数组大小，可以用cin &gt;&gt; n;让用户手动输入</span><br><span class="hljs-comment">// 另，编译数组的时候编译器是不知道数组大小的，只有程序运行的时候才知道</span><br>b=<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n]; <span class="hljs-comment">//这样就获得了一个空数组b</span><br>b[<span class="hljs-number">0</span>]=<span class="hljs-string">&#x27;w&#x27;</span>;<br>b[<span class="hljs-number">1</span>]=<span class="hljs-string">&#x27;o&#x27;</span>;<br>b[<span class="hljs-number">2</span>]=<span class="hljs-string">&#x27;r&#x27;</span>;<br>b[<span class="hljs-number">3</span>]=<span class="hljs-string">&#x27;l&#x27;</span>;<br>b[<span class="hljs-number">4</span>]=<span class="hljs-string">&#x27;d&#x27;</span>;<br><span class="hljs-keyword">delete</span> [] b;<br>b=<span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//如果后面的程序又用到了b就很容易出现bug</span><br></code></pre></td></tr></table></figure><h3 id="向量（vector）"><a href="#向量（vector）" class="headerlink" title="向量（vector）"></a>向量（vector）</h3><ol><li>向量就是把数组包了一层，里面就是个数组，特点和数组差不多</li><li>与数组一样，元素在内存中处于相邻的位置，向量也可以通过[]来访问第i个元素</li><li><strong>向量和数组的主要区别在于大小不固定，可以自动增长</strong></li><li>可以用<code>push_back()</code>函数在向量末尾添加新的元素，添加新的元素之后，向量的大小就会增长，时间复杂度为O(1)</li><li>还可以用<code>pop_back()</code>函数把向量最后一个元素删除掉，时间复杂度为O(1)</li><li>可以用<code>erase()</code>来删除中间的元素，但是平均情况下时间复杂度会是O(n)，n为后面所有的元素</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 需要#include &lt;vector&gt;</span><br>vector&lt;<span class="hljs-type">char</span>&gt; v=&#123;<span class="hljs-string">&#x27;h&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>&#125;;<br><span class="hljs-comment">// 指定初始的大小</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">w</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;<br><span class="hljs-comment">// 在向量的最后插入内容</span><br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;,&#x27;</span>);<br><span class="hljs-comment">// 删除向量最后一位的内容</span><br><span class="hljs-comment">// 运行后向量的最后一位会空出来，back指针会指向前一个位置</span><br>v.<span class="hljs-built_in">pop_back</span>();<br><span class="hljs-comment">// 删除中间的元素</span><br>v.<span class="hljs-built_in">erase</span>(v.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>)<br><span class="hljs-comment">// 查看向量v的大小</span><br>v.<span class="hljs-built_in">size</span>();<br><span class="hljs-comment">// 查看向量v的容量</span><br>v.<span class="hljs-built_in">capacity</span>(); <br>cout&lt;&lt;w.<span class="hljs-built_in">size</span>()&lt;&lt;endl; <span class="hljs-comment">// 大小为100</span><br>cout&lt;&lt;w.<span class="hljs-built_in">capacity</span>()&lt;&lt;endl; <span class="hljs-comment">// 容量为100</span><br><br><span class="hljs-comment">// 在w的末尾再添加一个元素</span><br>w.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<br>cout&lt;&lt;w.<span class="hljs-built_in">size</span>()&lt;&lt;endl; <span class="hljs-comment">// 大小变成了101</span><br>cout&lt;&lt;w.<span class="hljs-built_in">capacity</span>()&lt;&lt;endl; <span class="hljs-comment">// 容量变成了200</span><br><br><span class="hljs-comment">// 解释一下</span><br><span class="hljs-comment">// 原本向量里有个数组用来存储元素，原本数组大小为100，数组大小就是向量的容量capacity，数组已经存满了，有100个元素，因此size也是100;</span><br><span class="hljs-comment">// 加入一个元素之后，原本数组大小无法存储，自动添加了新的数组长度，因此此时capacity为200，size为101</span><br><span class="hljs-comment">// 这个过程实际上就是一个创建新数组并拷贝数据的过程，因此非常的慢，标准库的策略是一次让数组增加很多，下一次就不用再来一遍</span><br><br></code></pre></td></tr></table></figure><h3 id="链表（List）"><a href="#链表（List）" class="headerlink" title="链表（List）"></a>链表（List）</h3><ol><li>想要访问一个节点，需要一个个元素的找下去，因为数据元素在内存中并不相连</li><li>链表中有一个指向开头的指针<code>front</code>和指向末尾的指针<code>back</code>，访问开头或者末尾的时间复杂度是O(1)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 创建一个链表</span><br><span class="hljs-comment">// C++默认的链表是双链表，有一个指向前一个元素的指针和指向后一个元素的指针，最前面的元素指向前的指针和最后一个元素指向后的指针可以认为是指向NULL</span><br>list&lt;<span class="hljs-type">char</span>&gt; l=&#123;<span class="hljs-string">&#x27;h&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>&#125;;<br><span class="hljs-comment">// 访问链表开头元素</span><br>l.<span class="hljs-built_in">front</span>();<br><span class="hljs-comment">// 访问链表末尾元素</span><br>l.<span class="hljs-built_in">back</span>();<br><span class="hljs-comment">// 历遍链表的话要使用迭代器interator</span><br><span class="hljs-comment">// 用此段代码定义一个迭代器</span><br><span class="hljs-comment">// iter指向链表的头部节点</span><br>list&lt;<span class="hljs-type">char</span>&gt;::iterator iter=l.<span class="hljs-built_in">begin</span>();<br><span class="hljs-comment">// 打印inter中的数据</span><br>cout&lt;&lt;*iter&lt;&lt;endl;<br><span class="hljs-comment">// 让iter指向下一个节点</span><br>iter++;<br><span class="hljs-comment">// 此时iter的内容就会是&#x27;e&#x27;</span><br><span class="hljs-comment">// 可以用迭代器来更改链表数据</span><br>*iter=<span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-comment">// 链表支持插入操作，可以用push_back()或push_front()</span><br><span class="hljs-comment">// 此操作只有常数时间复杂度</span><br>l.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;s&#x27;</span>);<br>l.<span class="hljs-built_in">push_front</span>(<span class="hljs-string">&#x27;s&#x27;</span>);<br><span class="hljs-comment">// 可以对链表节点进行删除，可以用pop_back()或pop_front()</span><br><span class="hljs-comment">// 此操作只有常数时间复杂度</span><br>l.<span class="hljs-built_in">pop_back</span>();<br>l.<span class="hljs-built_in">pop_front</span>();<br><span class="hljs-comment">// 可以对链表中间的元素进行删除和插入，</span><br><span class="hljs-comment">// 此操作只有常数时间复杂度</span><br><span class="hljs-comment">// 在链表中间插入元素</span><br><span class="hljs-built_in">advance</span>(iter,<span class="hljs-number">1</span>);<br>l.<span class="hljs-built_in">insert</span>(iter,<span class="hljs-string">&#x27;e&#x27;</span>);<br></code></pre></td></tr></table></figure><table><thead><tr><th></th><th>数组</th><th>向量</th><th>链表</th></tr></thead><tbody><tr><td>大小</td><td>无法更改</td><td>增删改查</td><td>增删改查</td></tr><tr><td>内存</td><td>随机访问内存</td><td>随机访问内存</td><td>内存上不相邻，不支持随机访问</td></tr><tr><td>常规操作</td><td>O(1)</td><td>O(1)</td><td>&#x2F;</td></tr><tr><td>push_back()</td><td>&#x2F;</td><td>O(1)</td><td>O(1)</td></tr><tr><td>pop_back()</td><td>&#x2F;</td><td>O(1)</td><td>O(1)</td></tr><tr><td>insert()</td><td>&#x2F;</td><td>O(n)</td><td>O(1)</td></tr><tr><td>erase()</td><td>&#x2F;</td><td>O(n)</td><td>O(1)</td></tr></tbody></table><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><ul><li>数组 <ul><li>需要固定长度存储数据，从创建到删除无需改变长度</li></ul></li><li>向量<ul><li>频繁访问任意元素而不是按照顺序访问，应该用向量</li><li>可以快速在末尾插入和删除元素，但是在开头和中间就很慢</li></ul></li><li>链表<ul><li>在任何位置访问和修改内存</li><li>但是不支持随机访问内存</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>终端彩色字体显示</title>
    <link href="/2023/11/27/%E7%BB%88%E7%AB%AF%E5%BD%A9%E8%89%B2%E5%AD%97%E4%BD%93%E6%98%BE%E7%A4%BA/"/>
    <url>/2023/11/27/%E7%BB%88%E7%AB%AF%E5%BD%A9%E8%89%B2%E5%AD%97%E4%BD%93%E6%98%BE%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<p>终端的字符颜色是用转义序列控制的，是文本模式下的系统显示功能，和具体的语言无关</p><h3 id="常用的ANSI控制码如下"><a href="#常用的ANSI控制码如下" class="headerlink" title="常用的ANSI控制码如下"></a>常用的ANSI控制码如下</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs bash">\033[0m <span class="hljs-comment"># 关闭所有属性</span><br>\033[0m <span class="hljs-comment"># 关闭所有属性</span><br>\033[1m <span class="hljs-comment"># 高亮</span><br>\033[2m <span class="hljs-comment"># 亮度减半</span><br>\033[3m <span class="hljs-comment"># 斜体</span><br>\033[4m <span class="hljs-comment"># 下划线</span><br>\033[5m <span class="hljs-comment"># 闪烁</span><br>\033[6m <span class="hljs-comment"># 快闪</span><br>\033[7m <span class="hljs-comment"># 反显</span><br>\033[8m <span class="hljs-comment"># 消隐</span><br>\033[9m <span class="hljs-comment"># 中间一道横线</span><br>10-19 <span class="hljs-comment"># 关于字体的</span><br>21-29 <span class="hljs-comment"># 基本与1-9正好相反</span><br>30-37 <span class="hljs-comment"># 设置前景色</span><br>40-47 <span class="hljs-comment"># 设置背景色</span><br>30:<span class="hljs-comment"># 黑</span><br>31:<span class="hljs-comment"># 红</span><br>32:<span class="hljs-comment"># 绿</span><br>33: <span class="hljs-comment">#黄</span><br>34: <span class="hljs-comment">#蓝色</span><br>35: <span class="hljs-comment">#紫色</span><br>36: <span class="hljs-comment">#深绿</span><br>37: <span class="hljs-comment">#白色</span><br>38 <span class="hljs-comment"># 打开下划线,设置默认前景色</span><br>39 <span class="hljs-comment"># 关闭下划线,设置默认前景色</span><br>40 <span class="hljs-comment"># 黑色背景</span><br>41 <span class="hljs-comment"># 红色背景</span><br>42 <span class="hljs-comment"># 绿色背景</span><br>43 <span class="hljs-comment"># 棕色背景</span><br>44 <span class="hljs-comment"># 蓝色背景</span><br>45 <span class="hljs-comment"># 品红背景</span><br>46 <span class="hljs-comment"># 孔雀蓝背景</span><br>47 <span class="hljs-comment"># 白色背景</span><br>48 <span class="hljs-comment"># 不知道什么东西</span><br>49 <span class="hljs-comment"># 设置默认背景色</span><br>50-89 <span class="hljs-comment"># 没用</span><br>90-109 <span class="hljs-comment"># 又是设置前景背景的，比之前的颜色浅</span><br>\033[nA <span class="hljs-comment"># 光标上移n行</span><br>\033[nB <span class="hljs-comment"># 光标下移n行</span><br>\033[nC <span class="hljs-comment"># 光标右移n行</span><br>\033[nD <span class="hljs-comment"># 光标左移n行</span><br>\033[y;xH <span class="hljs-comment"># 设置光标位置</span><br>\033[2J <span class="hljs-comment"># 清屏</span><br>\033[K <span class="hljs-comment"># 清除从光标到行尾的内容</span><br>\033[s <span class="hljs-comment"># 保存光标位置</span><br>\033[u <span class="hljs-comment"># 恢复光标位置</span><br>\033[?25l <span class="hljs-comment"># 隐藏光标</span><br>\033[?25h <span class="hljs-comment"># 显示光标</span><br></code></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\033[47内容\033[0m&quot;</span>)<br><span class="hljs-comment"># 内容部分会设置为白色背景</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>磁场强者语翻译</title>
    <link href="/2023/11/25/%E7%A3%81%E5%9C%BA%E5%BC%BA%E8%80%85%E8%AF%AD%E7%BF%BB%E8%AF%91/"/>
    <url>/2023/11/25/%E7%A3%81%E5%9C%BA%E5%BC%BA%E8%80%85%E8%AF%AD%E7%BF%BB%E8%AF%91/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>小说</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux服务器安装code-server</title>
    <link href="/2023/11/25/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85code-server/"/>
    <url>/2023/11/25/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85code-server/</url>
    
    <content type="html"><![CDATA[<p>服务器用wget安装太慢了，手机上先下载好了用termius传上去<br>使用<code>tar -xf xxx.tar.gz</code>命令来解压gzip压缩包并进入bin文件夹，运行<code>nohup ./code-server &amp;</code>即可<br>配置文件位于&#x2F;用户&#x2F;.config&#x2F;code-server&#x2F;config.yaml中，格式如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">bind-addr:</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-string">:8080</span><br><span class="hljs-attr">auth:</span> <span class="hljs-string">password</span><br><span class="hljs-attr">password:</span> <span class="hljs-string">xxxxx</span><br><span class="hljs-attr">cert:</span> <span class="hljs-literal">false</span>     <br></code></pre></td></tr></table></figure><p>即可配置密码</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux服务器安装Jupyter服务</title>
    <link href="/2023/11/24/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85jupyter%E6%9C%8D%E5%8A%A1/"/>
    <url>/2023/11/24/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85jupyter%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p>在Linux服务器上安装Jupyter服务，加上Linux上安装的OneDrive服务以同步hexo源文件，以达到在浏览器上编辑hexo博客的目的</p><h4 id="安装miniconda"><a href="#安装miniconda" class="headerlink" title="安装miniconda"></a>安装miniconda</h4><p>用<code>wget</code>命令从<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/">清华源</a>下载Miniconda3安装脚本并运行,并将conda添加到环境变量中</p><h4 id="安装Jupyter"><a href="#安装Jupyter" class="headerlink" title="安装Jupyter"></a>安装Jupyter</h4><p>以<code>conda install jupyter</code>来安装jupyter<br>安装成功后，运行<code>jupyter notebook password</code>，会让你输入一个密码，经过确认后会生成一个哈希密码，存在&#x2F;用户&#x2F;.jupyter&#x2F;jupyter_server_config.json里</p><h5 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题:"></a>遇到问题:</h5><p>在非root用户安装了conda和jupyter之后在root用户上执行<code>jupyter notebook --allow-root</code>虽然成功开始了jupyter notebook服务，但是浏览器完全无法访问成功</p><h5 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题:"></a>解决问题:</h5><p>竟然是因为没有以root用户安装jupyter，原因不明，conda卸载jupyter之后以root用户重新安装jupyter即可成功<br><em>主要是OneDrive文件夹同步到了root文件夹，改到普通用户文件夹太麻烦了懒得弄了（捂脸）</em></p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>通过运行<code>jupyter notebook --generate-config</code>命令在&#x2F;用户&#x2F;.jupyter&#x2F; 文件夹下生成一个jupyter_notebook_config.py文件，以下是一些基本配置:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 设置可以访问的ip，默认是localhost，可以将其改为&#x27;*&#x27;,表示允许任何ip访问</span><br>c.NotebookApp.ip = <span class="hljs-string">&#x27;*&#x27;</span><br><span class="hljs-comment"># 笔记本的默认打开目录</span><br>c.NotebookApp.notebook_dir=<span class="hljs-string">&#x27;/root/hexo&#x27;</span><br><span class="hljs-comment"># 笔记本启动后是否打开浏览器，设置为False即可</span><br><span class="hljs-comment"># c.NotebookApp.open_browser=False</span><br><span class="hljs-comment"># 默认访问端口，可以自己修改</span><br><span class="hljs-comment"># c.NotebookApp.port=8888</span><br><span class="hljs-comment"># jupyterlab是否显示quit按钮，设为false可以免得不小心把服务停了</span><br>c.NotebookApp.quit_button = <span class="hljs-literal">False</span><br><span class="hljs-comment"># 是否允许以root用户运行</span><br>c.NoatebookApp.allow_root = <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h4 id="使Jupyter在服务器上一直运行"><a href="#使Jupyter在服务器上一直运行" class="headerlink" title="使Jupyter在服务器上一直运行"></a>使Jupyter在服务器上一直运行</h4><p><em>这段是我已经配置成功了在手机上编辑的</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">nohup</span> jupyter notebook --allow-root &amp; <span class="hljs-comment">#用nohup命令使其即使ssh断开也</span><br></code></pre></td></tr></table></figure><h4 id="给Jupyter安装中文"><a href="#给Jupyter安装中文" class="headerlink" title="给Jupyter安装中文"></a>给Jupyter安装中文</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install jupyter_contrib_nbextensions <span class="hljs-comment"># 下载中文包</span><br>jupyter contrib nbextension install --user <span class="hljs-comment"># 安装中文包</span><br><span class="hljs-comment"># 此时出现问题: MoudleNotFoundError: No moudule named &#x27;notebook.base&#x27;</span><br><span class="hljs-comment"># notebook库版本太高了，不兼容了，安装6.1.0版本</span><br>pip install notebook==6.1.0<br><span class="hljs-comment"># 再执行jupyter安装命令，成功</span><br>jupyter nbextension <span class="hljs-built_in">enable</span> --py widgetsnbextension<br>jupyter nbextension <span class="hljs-built_in">enable</span> --py jupyter_highlight_selected_word<br></code></pre></td></tr></table></figure><blockquote><p>Ps. jupyter_server_config.json的优先级要高于jupyter_notebook_config.py</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Hexo</tag>
      
      <tag>Jupyter</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>npm命令</title>
    <link href="/2023/11/22/npm%E5%91%BD%E4%BB%A4/"/>
    <url>/2023/11/22/npm%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<ul><li><p>npm install xxx</p><ul><li><p>-s相当于-S，即–save</p><p>局部安装，会写进package.json文件中的dependencie里</p><p>dependencies: 表示生产环境下的依赖管理；</p></li><li><p>-g全局安装</p></li><li><p>-d相当于-D，即–save-dev<br>  局部安装，会写进package.json中的devDenpencies里<br>  devDependencies: 表示开发环境下的依赖管理<br>  如果安装这些库是用来打包的或者解析代码的，就可以用这个来安装</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笑话收集</title>
    <link href="/2023/11/21/%E7%AC%91%E8%AF%9D%E6%94%B6%E9%9B%86/"/>
    <url>/2023/11/21/%E7%AC%91%E8%AF%9D%E6%94%B6%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="战锤笑话"><a href="#战锤笑话" class="headerlink" title="战锤笑话"></a>战锤笑话</h2><ul><li><p>第一个笑话不是这个都对不起这个版本：</p><blockquote><p>原体的时代结束了！</p></blockquote></li><li><p>亚空间笑话其二：</p><blockquote><p>恐虐是懦夫，但是安格隆不是</p></blockquote></li><li><p>教你的孩子玩战锤，这样他们就没钱买毒品了</p><blockquote><p>结果这孩子开始贩毒买棋子了</p></blockquote></li><li><p>另一个经典笑话</p><blockquote><p>寂静王，维特克和帝皇来到一个岔路口。只见两边路牌上一边写着科技，一边写着玄学。寂静王径直走了科技那边，维克特稍作思考也走了科技那边。帝皇稍作思考，将两块路牌交换位置，走了科技那边。</p></blockquote></li></ul><h3 id="苏联笑话"><a href="#苏联笑话" class="headerlink" title="苏联笑话"></a>苏联笑话</h3><ol><li><p>伊万在看电视，是列昂尼德同志在演讲。伊万觉得无聊，换了个台，还是列昂尼德同志在演讲，又换了一个，还是他。伊万一连换了几十个台，最后累了，准备关电视。这时候电话响了，是克格勃的同志“你再换？你再换判你十年大牢！”</p></li><li><p>在苏联是否可以存在两党制？</p><blockquote><p>不，不可能，因为我们养不起</p></blockquote></li><li><p>什么在苏联最常见？</p><blockquote><p>暂时的困难</p></blockquote></li><li><p>苏联的制度优越性在哪？</p><blockquote><p>成功地克服了在其它社会制度里不会存在的困难</p></blockquote></li><li><p>一位内务人民委员部审判员结束一天的审判工作，回到办公室，突然独自大笑起来。对面办公桌的同事奇怪的问道：“有什么好笑的事吗？” “是啊，”审判员用手帕擦着笑出来的眼泪：“一个很好笑的笑话……” “哦？说来听听？” “你疯了吗？！我刚判了说这笑话的家伙五年苦役！” </p></li><li><p>勃列日涅夫同志，听说您收集政治笑话，是真的吗？</p><p>是的。</p><p>那么您现在收集了多少了呢？</p></li></ol><p>​三座半劳改营。</p><ol start="7"><li><p>有三条狗，一条美国狗，一条波兰狗，一条俄国狗。一次，波兰狗与俄国狗到美国来。美国狗教他们怎么做。美国狗说：在这个国家，你知道的，只要你叫的时间够长，你叫，就会有人过来给你肉吃。波兰狗问到：“肉”是什么？俄国狗问到：“叫”是什么？</p></li><li><p>尼基塔同志来华盛顿拜访约翰先生，约翰先生在白宫殷勤款待，席间，厨房上了一道烤香肠。尼基塔同志吃了以后对其美味赞不绝口，约翰先生对尼基塔同志夸口道：“在我们美利坚农场，生产美味的香肠已经达到了完全自动化水平，那你只要赶一头猪道香肠制造机的入口里去，过不多久机器的那一头就会自动出来一串一串的香肠…”尼基塔同志边嚼香肠连连点头，约翰先生十分得意。这时，坐在一旁的杰奎琳由于嫌香肠油脂多，吃了一点就吩咐把她的那份撤掉了。尼基塔同志问约翰先生：”撤下去的香肠你们怎么办？“约翰先生答到：”当垃圾倒掉呗！“尼基塔同志摇了摇头，说：”在我们哪里，吃剩的香肠只要往我们的香肠制造机出口扔进去，机器的那一头过不了多久就会跑出一头猪来……“</p></li><li><p>为什么这个演员被解雇了？</p><blockquote><p>因为他太像斯大林了，他的表演引发了高层恐慌</p></blockquote></li><li><p>精神病院里播放着赫鲁晓夫的演讲。讲完一段，所有人都热烈鼓掌，只有一个人站着不动。旁人问道：”你为什么不鼓掌？“答：”因为我是医生“</p></li><li><p>为什么齐奥塞斯库要在五月一日举办群众集会？</p><blockquote><p>他要看看在冬天过后，还可以活下来多少人</p></blockquote></li><li><p>亚历山大，凯撒，拿破仑作为贵宾，参加红场阅兵</p><blockquote><p>“我要是有苏联的坦克，我将是战无不胜的！”亚历山大说</p><p>”我要是有苏联的飞机，我将政府全世界！“凯撒说。</p><p>”我要是有真理报，世界现在也不会知道滑铁卢！“拿破仑说</p></blockquote></li><li><p>理查德先生访问苏联。在记者招待会上，理查德先生想借机宣扬美国式的民主，于是说：”在我们美国言论自由，任何人都可以在白宫前大骂：‘尼克松是个王八蛋！’肯定没有警察来抓他。“</p><blockquote><p>列昂尼德同志不动声色的说：”在苏联同样也是言论自由，任何人也都可以在克里姆林宫前大骂：‘尼克松是个王八蛋！’，同样没有警察来抓他！“</p></blockquote></li><li><p>一个苏联克格勃特工和一个美国中情局特工互相吹嘘各自的机构是如何的杰出。</p><p>那个克格勃特工首先发言说，”我们拥有你们美国过去15年里所有导弹发射的详细数据“</p><p>中情局特工说：“这不算什么。我们中情局掌握着你们苏联未来15年里所有当选的中央委员名单”</p></li><li><p>苏联知识分子有五个规则：</p><ul><li>什么都别去思考；</li><li>如果你一定要思考，那就别说；</li><li>如果你又要思考又要说，那就别写；</li><li>如果你又思考又说还非要写，那么别签名；</li><li>如果以上规则你都不遵守，那你就别惊讶。</li></ul></li><li><p>将军的儿子能成为元帅吗？</p><blockquote><p>不可能，元帅都有儿子。</p></blockquote></li><li><p>两个中学同学相遇然后寒暄。</p><p>您现在在哪工作？</p><p>中学老师，您呢？</p><p>克格勃。</p><p>啊！您在克格勃具体干什么？</p><p>我们负责揪出那些对苏联不满的家伙。</p><p>您的意思是……还有人比较满意？</p><p>那些人不归我们管——管他们的是纪委。</p></li><li><p>问：“假设你在酒吧，而一个陌生人坐到你身边并开始唉声叹气，你该怎么做？</p><blockquote><p>答：”立即去阻止这种反苏宣传！“</p></blockquote></li><li><p>有一个人在莫斯科红场分发白纸，被克格勃逮捕。克格勃问他：”你知不知道分发传单是违法的？“此人回答：“可是我分发的是白纸啊？”克格勃冷哼一声“哼，别以为上面什么都没写，我就不知道你要说什么了！”</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>知识记录</title>
    <link href="/2023/11/21/%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/11/21/%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="AGI"><a href="#AGI" class="headerlink" title="AGI"></a>AGI</h3><p>恰逢Open AI之父亲加入微软，记录一下什么是AGI</p><p>AGI是通用人工智能的缩写，也就是广为人知的<strong>强人工智能</strong>，被认为是奇点技术之一</p><h3 id="中文屋论证（CRA）"><a href="#中文屋论证（CRA）" class="headerlink" title="中文屋论证（CRA）"></a>中文屋论证（CRA）</h3>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>对于经典逻辑漏洞的反驳方法</title>
    <link href="/2023/11/20/%E5%AF%B9%E4%BA%8E%E7%BB%8F%E5%85%B8%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%8F%8D%E9%A9%B3%E6%96%B9%E6%B3%95/"/>
    <url>/2023/11/20/%E5%AF%B9%E4%BA%8E%E7%BB%8F%E5%85%B8%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%8F%8D%E9%A9%B3%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="你行你上啊？"><a href="#你行你上啊？" class="headerlink" title="你行你上啊？"></a>你行你上啊？</h3><ul><li><p><strong>预设谬误</strong> 它假设了一个没有证明的前提，即“只有做得比别人好才有资格评价别人”</p><ul><li>鲁迅先生的名言——“譬如厨子做菜，有人品评他坏，他固不应该将厨刀铁釜交给批评者，说道你试来做一碗好的看。” ——&gt;现代话语版本：”你吃了一道难吃的菜，你说“这菜真难吃”，难道你还得做菜比厨子好吃才能这么说吗？”</li></ul></li><li><p><strong>偷换概念</strong> 诡辩，将“某人或者某事的是非”转移到了“发言者的能力”上，从而避开了对这件事本身的讨论，你在回避话题</p></li><li><p><strong>相干谬误</strong> 它认为“做得好”和“评价好”之间有必然的联系，而忽略了评价的标准，依据和目的</p></li></ul><h3 id="电车难题-老妈和媳妇掉水里救哪个"><a href="#电车难题-老妈和媳妇掉水里救哪个" class="headerlink" title="电车难题&#x2F;老妈和媳妇掉水里救哪个"></a>电车难题&#x2F;老妈和媳妇掉水里救哪个</h3><ul><li><strong>虚实两难</strong> 即排除了事物的其他选项，只提供两种选项，这种问题用逻辑陷阱屏蔽了其他所有现实中的可能性，比如在她们掉下去之前拉住她们啊，找路人求救啊，周围有急救人员啊等等，要求对方仅在两者间做出选择</li></ul><h3 id="以偏概全"><a href="#以偏概全" class="headerlink" title="以偏概全"></a>以偏概全</h3><ul><li>就像盲人摸象一样，你遇到了一个坏老师，那世界上的所有老师救都是坏老师，你遇到了一个某某地区的人低素质，那那个地区的人就都是低素质，非常经典</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>人格面具与扮演法</title>
    <link href="/2023/11/20/%E4%BA%BA%E6%A0%BC%E9%9D%A2%E5%85%B7%E4%B8%8E%E6%89%AE%E6%BC%94%E6%B3%95/"/>
    <url>/2023/11/20/%E4%BA%BA%E6%A0%BC%E9%9D%A2%E5%85%B7%E4%B8%8E%E6%89%AE%E6%BC%94%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>人格面具理论是荣格提出的，是一种关于自我认知和表达的理论，本文旨在讨论此理论与广为传播的网络小说《诡秘之主》中的“扮演法”概念与《赛博英雄传》中的“人格覆面”概念，以及卢梭的剧场理论等概念形成的有趣化学反应。</p><p>在开始文章的讨论之前，先介绍一下设定：</p><ul><li><p>人格面具</p><p>荣格将一个人的人格比喻为面具，在不同的社交场合人们会表现出不同的形象，也就是戴上不同的面具（使形象化和具象化）</p></li><li><p>神格面具</p></li><li><p>扮演法</p></li></ul><p>​《诡秘之主》中，角色可以选择一个有九个“序列”的“途径”，然后经过仪式和魔药来晋升序列，每个途径的九个序列都有对应的名称，如“小丑”，“水手”，“学徒”等等，服用魔药者可以根据序列的名称进行相应的模仿和扮演，以此来增加对于当前序列的特殊能力的掌握</p><ul><li>人格覆面<ul><li>假性人格覆面 [spurious persona]</li><li>真性人格覆面 []</li></ul></li></ul><p>不难发现，诡秘之主的“扮演法”实际上就是</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>心理学</tag>
      
      <tag>诡秘之主</tag>
      
      <tag>赛博英雄传</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>apt命令</title>
    <link href="/2023/11/20/apt%E5%91%BD%E4%BB%A4/"/>
    <url>/2023/11/20/apt%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h4 id="一条命令更新并升级"><a href="#一条命令更新并升级" class="headerlink" title="一条命令更新并升级"></a>一条命令更新并升级</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt update &amp;&amp; sudo apt upgrade -y<br></code></pre></td></tr></table></figure><p>-y安装过程中有需要用户确认的步骤时，可以选择全部为“yes”</p><h4 id="指定版本安装"><a href="#指定版本安装" class="headerlink" title="指定版本安装"></a>指定版本安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install &lt;package_name&gt;=&lt;version_number&gt;<br></code></pre></td></tr></table></figure><h4 id="清理不再使用的依赖和库文件"><a href="#清理不再使用的依赖和库文件" class="headerlink" title="清理不再使用的依赖和库文件"></a>清理不再使用的依赖和库文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt autoremove<br></code></pre></td></tr></table></figure><h4 id="修复安装"><a href="#修复安装" class="headerlink" title="修复安装"></a>修复安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt -f install<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim插件配置</title>
    <link href="/2023/11/18/Vim%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/11/18/Vim%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>使用**<a href="https://github.com/junegunn/vim-plug">vim-plug</a>**插件来安装和管理插件，需要将plug.vim文件复制到</p><ul><li>WindwosC:\Program Files\Neovim\share\nvim\runtime\autoload</li><li>Linux~&#x2F;.local&#x2F;share&#x2F;nvim&#x2F;site&#x2F;autoload&#x2F;plug.vim</li></ul><p>然后在</p><ul><li>WindowsC:\Users\用户名\AppData\Local\nvim\</li><li>Linux~&#x2F;.config&#x2F;nvim&#x2F;init.vim</li></ul><p>中创建init.vim文件,如果没有这个文件夹就自己创建一个</p><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs leaf">call plug<span class="hljs-punctuation">#</span><span class="hljs-keyword">begin</span><span class="hljs-params">(&#x27;&#x27;)</span><br><br>Plug &#x27;插件名&#x27;<br><br>call plug<span class="hljs-punctuation">#</span><span class="hljs-keyword">end</span><span class="hljs-params">()</span><br></code></pre></td></tr></table></figure><p>然后在nvim里执行:PlugIntall即可开始安装</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker使用</title>
    <link href="/2023/11/17/Docker%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/11/17/Docker%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>docker中的镜像，容器和仓库</p><ul><li><p>镜像</p><p>镜像是一个只读的模板，可以用来创建容器</p></li><li><p>容器</p><p>容器是docker的运行环境，提供了一个独立的可移植的环境，可以在这个环境中运行应用程序，是一个运行实例</p></li><li><p>仓库</p><p>用来存储docker镜像的地方，用来管理和存储docker的镜像</p></li></ul><p>镜像是比容器更抽象的东西，镜像就是食谱或者说建筑图纸，容器就是根据食谱和建筑图纸做出来的菜和盖出来的房子</p><p>docker使用client-server架构模式，Docker client和Docker Daemon之间通过Socket和RESTful API进行通信</p><p>Docker daemon即服务端的守护进程，负责管理Docker的各种资源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">snap install docker<br><br>docker-compose pull<br><span class="hljs-comment"># 从Docker Compose文件中定义的服务所需的镜像从仓库中拉取镜像</span><br>docker-compose up -d<br><span class="hljs-comment"># 用此命令来构建并自动创建或重建容器，然后启动它们，并建立它们之间的网络连接，-d表示以后台模式运行容器，不会占用终端的输出</span><br>docker images<br><span class="hljs-comment"># 查看目前我所有的docker镜像</span><br>docker rmi my_image_id<br><span class="hljs-comment"># 删除名字为my_image_id的镜像</span><br>docker prune -a<br><span class="hljs-comment"># 删除所有没有被使用的dockr镜像</span><br>docker rmi $(docker images -q)<br><span class="hljs-comment"># 删除所有docker镜像</span><br>docker scout quickview<br><span class="hljs-comment"># 用docker scout来显示docker镜像的快速概览</span><br>docker ps -a<br><span class="hljs-comment"># 查看所有容器的名字</span><br>docker ps<br><span class="hljs-comment"># 查看所有正在运行的容器的名字</span><br>docker logs container_name<br><span class="hljs-comment"># 查看容器的日志信息</span><br>docker logs -f container_name<br><span class="hljs-comment"># 实时查看容器的日志信息</span><br>docker restart container_name<br><span class="hljs-comment"># 重启docker容器</span><br></code></pre></td></tr></table></figure><h4 id="reader3"><a href="#reader3" class="headerlink" title="reader3"></a>reader3</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">从GitHub上下载源码，解压到文件夹并<br></code></pre></td></tr></table></figure><h4 id="calibre-web"><a href="#calibre-web" class="headerlink" title="calibre-web"></a>calibre-web</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 报错</span><br>/usr/bin/python: can<span class="hljs-string">&#x27;t open file &#x27;</span>/calibre-web/app/cps.py<span class="hljs-string">&#x27;: [Errno 2] No such file or directory</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>遇到的bug和解决方法</title>
    <link href="/2023/11/17/%E9%81%87%E5%88%B0%E7%9A%84bug%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <url>/2023/11/17/%E9%81%87%E5%88%B0%E7%9A%84bug%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h4 id="YAMLException-end-of-the-stream-or-a-document-separator-is-expected-at-line-2-column-8"><a href="#YAMLException-end-of-the-stream-or-a-document-separator-is-expected-at-line-2-column-8" class="headerlink" title="YAMLException: end of the stream or a document separator is expected at line 2, column 8:"></a>YAMLException: end of the stream or a document separator is expected at line 2, column 8:</h4><ul><li>非常愚蠢的错误，”:”后面加空格即可解决</li></ul><h4 id="无法将“pwsh”项识别为-cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次"><a href="#无法将“pwsh”项识别为-cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次" class="headerlink" title="无法将“pwsh”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次"></a>无法将“pwsh”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次</h4><ul><li>Power shell的默认版本太低了，去<a href="https://learn.microsoft.com/zh-cn/powershell/scripting/install/installing-powershell-on-windows?view=powershell-7.3#installing-the-msi-package">微软官方</a>下载并安装一下新版的Power shell即可</li></ul><p>​可以使用</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$PSVersionTable</span>.PSVersion<br></code></pre></td></tr></table></figure><p>来查看Powershell的版本，会返回一个这样的内容</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">Major  Minor  Patch  PreReleaseLabel</span><br><span class="hljs-literal">-----</span>  <span class="hljs-literal">-----</span>  <span class="hljs-literal">-----</span>  <span class="hljs-literal">---------------</span><br><span class="hljs-comment">7      1      0</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解压tar.gz文件</title>
    <link href="/2023/11/17/%E8%A7%A3%E5%8E%8Btar.gz%E6%96%87%E4%BB%B6/"/>
    <url>/2023/11/17/%E8%A7%A3%E5%8E%8Btar.gz%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">gzip -d filename.gz 这个命令将会将文件解压缩并删除原有压缩文件，如果想要保留原有压缩文件，使用:<br>gzip -dk filename.gz<br>.tar.gz 即是用gzip压缩的.tar归档文件<br>tar -xf filename.tar.gz 使用该命令可以直接解压.tar.gz文件<br>-x 从归档文件中提取文件<br>-f 指定归档文件的名称，后面紧跟着归档文件的名字<br>-v 在执行操作时显示详细信息，即输出操作流程<br>-z 表示文档是经过gzip压缩的，虽然大部分情况下新版本tar会自动识别，<br>但是万一有上手04年之前的linux的可能性呢（耸肩）<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编程中遇到的非常好的各种文章和网站</title>
    <link href="/2023/11/17/%E7%BC%96%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%9E%E5%B8%B8%E5%A5%BD%E7%9A%84%E5%90%84%E7%A7%8D%E6%96%87%E7%AB%A0%E5%92%8C%E7%BD%91%E7%AB%99/"/>
    <url>/2023/11/17/%E7%BC%96%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%9E%E5%B8%B8%E5%A5%BD%E7%9A%84%E5%90%84%E7%A7%8D%E6%96%87%E7%AB%A0%E5%92%8C%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<h4 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h4><ul><li><p><strong><a href="https://www.zhihu.com/column/c_1527964562929893376">从零开始配置vim</a></strong> 来自知乎<a href="https://www.zhihu.com/people/jeccica-20">Masimaro</a></p></li><li><p><strong><a href="https://www.zhihu.com/column/c_1497149473017442304">vim使用技巧 </a></strong> 来自知乎<a href="https://www.zhihu.com/people/jeccica-20">Masimaro</a></p></li></ul><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><ul><li><a href="https://xiaolincoding.com/os/6_file_system/file_system.html#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90">7.1 文件系统全家桶 </a>来自博客<a href="https://xiaolincoding.com/">小林coding</a></li></ul><h4 id="代码质量"><a href="#代码质量" class="headerlink" title="代码质量"></a>代码质量</h4><ul><li><a href="https://www.zhihu.com/question/20017545/answer/3066680548">好的提高代码质量的方法有哪些？有什么经验和技巧？</a> 来自知乎<a href="https://www.zhihu.com/people/wang_zheng_">王争 </a></li><li><a href="https://blog.csdn.net/A1342772/article/details/91349142">23 种设计模式详解（全23种）_23种设计模式</a> 来自CSDN<a href="https://blog.csdn.net/A1342772?type=blog">鬼灭之刃</a></li></ul><h4 id="码农翻身"><a href="#码农翻身" class="headerlink" title="码农翻身"></a>码农翻身</h4><ul><li><p><a href="https://mp.weixin.qq.com/s/Itk0n8gax1f4oA8BV_qDbA">世界上有两种公众号，我坚持做第二种</a> 来自公众号码农翻身</p></li><li><p><a href="https://mp.weixin.qq.com/s/tgLVC5MwBYSFuxEGUy4P6A">我把这两年的精华文章都整理出来了 </a>来自公众号码农翻身</p></li></ul><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><ul><li><a href="https://javabetter.cn/cs/os.html">操作系统核心知识点大梳理 | 二哥的Java进阶之路 (javabetter.cn)</a></li></ul><h4 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h4><ul><li><a href="https://javabetter.cn/cs/wangluo.html">计算机网络核心知识点 | 二哥的Java进阶之路 (javabetter.cn)</a></li></ul><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ul><li><a href="http://hardyfish.top/2023/10/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/">算法知识</a></li></ul><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li><a href="http://hardyfish.top/2023/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构 | 月伴飞鱼 (hardyfish.top)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>分享</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>搭建骰子机器人的过程</title>
    <link href="/2023/11/17/%E6%90%AD%E5%BB%BA%E9%AA%B0%E5%AD%90%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <url>/2023/11/17/%E6%90%AD%E5%BB%BA%E9%AA%B0%E5%AD%90%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<ul><li>从GitHub上下载release到服务器上，用tar解压并安装为系统服务，开始运行服务，</li><li>出现问题：在浏览器用公网ip无法找到开启的UI界面</li><li>解决问题：没打开服务所需的对应端口</li><li>出现问题：无法直接用骰子机器人对接QQ账号，需要签名服务器</li><li>解决问题：暂时未能解决</li><li>成功将骰子机器人部署到KooK平台</li><li>根据官方引导下载.js插件:<ul><li>定时任务2.0.0</li><li>每日新闻与历史上的今天</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>sealdice</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>与门</title>
    <link href="/2023/11/17/%E4%B8%8E%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/11/17/%E4%B8%8E%E9%97%A8%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<ul><li><p>第一章 非门</p><ul><li><p>任务要求</p><ul><li>输入0输出1</li><li>输入1输出0</li></ul></li><li><p>实现</p><ul><li>添加一个非门——输入通电输出不通电，输入不通电输出通电</li></ul></li></ul></li><li><p>第二章 与门</p><ul><li><p>任务要求</p><ul><li>输入0 0 输出0</li><li>输入0 1输出0</li><li>输入1 0输出0</li><li>输入1 1输处1</li></ul></li><li><p>实现</p><ul><li>添加一个与门——只有两个输入都通电时才通电</li></ul></li></ul></li><li><h2 id="第三章-或门-任务要求"><a href="#第三章-或门-任务要求" class="headerlink" title="第三章 或门- 任务要求"></a>第三章 或门<br>- 任务要求</h2></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逻辑门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim基础配置</title>
    <link href="/2023/11/17/Vim%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/11/17/Vim%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>vim的全局配置一般修改<code>/etc/vim/vimrc</code>或者<code>/etc/vimrc</code>，对所有用户生效，修改<code>~/.vimrc</code>仅对个人用户生效，或者在单词编辑中可以直接在命令行中写<code>set number</code>这种命令生效</p><p>Window下vim的配置文件名为_vimrc，位于vim安装目录下</p><p>下面是一个nvim的基础配置:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs text">-- 开启语法高亮<br>vim.o.syntax = &quot;enable&quot;<br>-- 显示相对行号<br>vim.o.relativenumber = true<br>-- 显示行号<br>vim.o.number = true<br>-- 高亮所在行<br>vim.o.cursorline = true<br>-- 自动换行<br>vim.o.wrap = true<br>-- 显示光标位置<br>vim.o.ruler = true<br>-- 边输入边搜索<br>vim.o.incsearch = true<br>-- 开启搜索匹配高亮<br>vim.o.hlsearch = true<br>-- 搜索时自行判断是否需要忽略大小写<br>vim.o.smartcase = true<br><br>-- tab键转换为 4 个空格<br>vim.o.tabstop = 4<br>vim.o.softtabstop = 4<br>vim.o.shiftwidth = 4<br>-- 新行对齐当前行，tab转换为空格<br>vim.o.expandtab = true<br>vim.bo.expandtab = true<br>vim.o.autoindent = true<br>vim.bo.autoindent = true<br>vim.o.smartindent = true<br><br>-- &lt;&lt; &gt;&gt; 缩进时移动的长度<br>vim.o.shiftwidth = 4<br>vim.bo.shiftwidth = 4<br><br>-- 使用jk移动光标时，上下方保留8行<br>vim.o.scrolloff = 8<br>vim.o.sidescrolloff = 8<br><br>-- 设置自动折叠<br>vim.o.smartindent = true<br>-- 历史命令最多保存1000条<br>vim.o.history = 1000<br>-- 显示空白字符<br>vim.o.list = true<br>-- 样式<br>vim.o.background = &quot;dark&quot;<br>vim.o.termguicolors = true<br>vim.opt.termguicolors = true<br></code></pre></td></tr></table></figure><p>上述代码中，<code>vim.o.syntax = &quot;enable&quot;</code> 和<code>syntax on</code>的区别是，</p><p>前者使用了lua语法来设置vim的语法高亮选项，可以自定义颜色；后者用vimscript语言来设置vim的语法高亮，用vim默认的颜色。</p><p>下面列举几个vimscript常用命令，可以在nvim和vim通用</p><h5 id="vimscript"><a href="#vimscript" class="headerlink" title="vimscript"></a>vimscript</h5><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">set</span> number 打开行前数字<br>syntax <span class="hljs-comment">on</span> 代码高亮<br><span class="hljs-keyword">set</span> <span class="hljs-comment">autoindent</span> 下一行和上一行自动缩进一致<br><span class="hljs-keyword">set</span> <span class="hljs-comment">showmatch</span> 光标遇到括号自动高亮另一个<br><span class="hljs-keyword">set</span> <span class="hljs-comment">incsearch</span> 搜索模式时，随着输入光标自动跳转到匹配结果<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim基本键位</title>
    <link href="/2023/11/17/Vim%E5%9F%BA%E6%9C%AC%E9%94%AE%E4%BD%8D/"/>
    <url>/2023/11/17/Vim%E5%9F%BA%E6%9C%AC%E9%94%AE%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<ul><li><p><strong>x键删除字符</strong></p></li><li><p>dw删除整个单词</p><ul><li>d2w删除接下来的两个单词</li></ul></li><li><p>d$删除到行尾</p></li><li><p>w到下一个单词头</p></li><li><p>e到下一个单词尾</p></li><li><p>$到行尾</p></li><li><p>u撤回</p><ul><li>Ctrl+R反撤回</li></ul></li><li><p>0到行首，包括空格</p></li><li><p>^到行首，不包括空格</p></li><li><p>G到文本最好一行首</p></li><li><p>gg到文本首行</p></li><li><p>number motion执行几次行动</p><ul><li>38j向下移动38次</li></ul></li><li><p>dd删除一整行</p></li><li><p>p在光标处粘贴先前删除的文本</p></li><li><p>r以替换光标处的字符</p><ul><li>移动光标到第一个错误，键入r和要更正的字符</li></ul></li><li><p>ce删除直到单词末尾的内容并进入编辑模式</p><ul><li>cw删除整个单词并进入编辑模式</li><li>c$删除直到行末并进入编辑模式</li></ul></li><li><p>Ctrl+G显示你在文档中的位置</p></li><li><p>number+G前往第数字行</p></li><li><p>&#x2F;+搜索的单词</p><ul><li>向下搜索下一个单词n</li><li>向上搜索下一个单词N</li></ul></li><li><p>？+向上搜索的单词</p></li><li><p>Ctrl+O回到之前的那个位置，Ctrl+I前进位置</p></li><li><p>%将光标移动到它对应的匹配括号上</p></li><li><p>:&#x2F;s&#x2F;old&#x2F;new&#x2F;g将一行中的old替换为new</p></li><li><p>:&#x2F;#,#s&#x2F;old&#x2F;new&#x2F;g其中#,#是更改的行号范围</p></li><li><p>:&#x2F;%s&#x2F;old&#x2F;new&#x2F;g更改全文件的old内容</p></li><li><p>:&#x2F;%s&#x2F;old&#x2F;new&#x2F;gc更改全文及的old内容，并给出替换与否的提示</p></li><li><p>:! 执行外部命令，如:!ls或者:!dir</p></li><li><p>:w Filename.**保存文件并更改文件名或者类型</p></li><li><p>v按住以选择</p></li><li><p>o光标下插入新的一行</p></li><li><p>O光标上插入新的一行</p></li><li><p>A在一句的末尾开始插入内容</p></li><li><p>R插入不止一句内容</p></li><li><p><strong>y复制用v的选中内容</strong>，用p粘贴内容**</p></li><li><p>选中后U将内容变成大写，u将内容变成小写，~将大小翻转</p></li><li><p>:e ~&#x2F;.vimrc 编辑Unix依赖</p></li><li><p>:e $VIM&#x2F;_vimrc编辑Windows依赖</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python批量生成问题</title>
    <link href="/2023/11/17/Python%E6%89%B9%E9%87%8F%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6/"/>
    <url>/2023/11/17/Python%E6%89%B9%E9%87%8F%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">i=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">11</span>)<br>file_name=<span class="hljs-string">&quot;文件名%d.txt&quot;</span> %i<br><span class="hljs-built_in">open</span>(file_name,<span class="hljs-string">&quot;w&quot;</span>)<br>i+=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>附上一个天干数版本的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">i=<span class="hljs-number">0</span><br>tian_gan=[<span class="hljs-string">&quot;甲&quot;</span>,<span class="hljs-string">&quot;乙&quot;</span>,<span class="hljs-string">&quot;丙&quot;</span>,<span class="hljs-string">&quot;丁&quot;</span>,<span class="hljs-string">&quot;戊&quot;</span>,<span class="hljs-string">&quot;己&quot;</span>,<span class="hljs-string">&quot;庚&quot;</span>,<span class="hljs-string">&quot;辛&quot;</span>,<span class="hljs-string">&quot;壬&quot;</span>,<span class="hljs-string">&quot;葵&quot;</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>):<br>    file_name=<span class="hljs-string">&quot;测试%s.txt&quot;</span> % tian_gan[i]<br>    <span class="hljs-built_in">open</span>(file_name,<span class="hljs-string">&#x27;w&#x27;</span>)<br>    i+=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-jupyter</title>
    <link href="/2023/11/17/Python-jupyter/"/>
    <url>/2023/11/17/Python-jupyter/</url>
    
    <content type="html"><![CDATA[<h4 id="Jupyter-notebook转markdown"><a href="#Jupyter-notebook转markdown" class="headerlink" title="Jupyter notebook转markdown"></a>Jupyter notebook转markdown</h4><p>需要的库是<code>nbconbert</code> ，它依赖库<code>pandoc</code> </p><blockquote><p><em>Ps.我看到这个库名的时候脑子里第一反应是”牛逼的转换器“（捂脸），什么牛逼哄哄的能量瓶小伙啊</em></p><p><em>Ps.Ps. 用这个<a href="https://github.com/pyppeteer/pyppeteer">pyppeteer&#x2F;pyppeteer</a>库可以转换为pdf</em></p></blockquote><p>命令为：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">jupyter nbconvert xxx<span class="hljs-selector-class">.ipynb</span> <span class="hljs-attr">--to</span> markdown<br></code></pre></td></tr></table></figure><p>如果xxx.ipynb中有图片的话，会自动保存至当前xxx_files目录下，记得将图片相关文件一并携带，否则无法显示</p><p>批量转换:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">jupyter nvconvert --to markdown *.ipynb<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux有趣小工具记录</title>
    <link href="/2023/11/17/Linux%E6%9C%89%E8%B6%A3%E5%B0%8F%E5%B7%A5%E5%85%B7%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/11/17/Linux%E6%9C%89%E8%B6%A3%E5%B0%8F%E5%B7%A5%E5%85%B7%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h4 id="cmatrix"><a href="#cmatrix" class="headerlink" title="cmatrix"></a>cmatrix</h4><p>使用任何包管理器都可以直接下载的工具，堪称“抖音黑客风”之典范，安装完成后可直接用“cmatrix”命令来将终端界面变成尼奥视角，非常有“科幻感”和“骇入感”</p><h4 id="sl"><a href="#sl" class="headerlink" title="sl"></a>sl</h4><p>因为打ls的时候经常会打错，于是出现了这么个非常整蛊的工具，只要你打错成sl并回车了的话，一辆字符小火车就会从屏幕上开过…</p><h4 id="cool-retro-term"><a href="#cool-retro-term" class="headerlink" title="cool retro term"></a><a href="https://github.com/Swordfish90/cool-retro-term">cool retro term</a></h4><p>一个非常有趣的终端主题，可以将终端样式变为crt显示器的样子，就是有点吃配置，核显可能会有点卡</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Edge浏览器手势</title>
    <link href="/2023/11/17/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%8B%E5%8A%BF/"/>
    <url>/2023/11/17/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%8B%E5%8A%BF/</url>
    
    <content type="html"><![CDATA[<p>微软的老毛病——这个功能真不错！现在让我们在下一次更新之后把它砍了！</p><p>在又一次的更新完系统之后发现鼠标手势控制消失之后，上网找到了解决方案</p><ol><li>在浏览器地址栏中输入<code>edge://flags/</code>进入实验功能配置页面，搜索出Mouse Gesture后将Default选项改为Enable</li><li>在最新的版本中可以去设置-外观里打开鼠标手势控制选项</li></ol><p>不确定究竟是哪个操作具体生效的，但是也懒得折腾了，记录一下</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>杂记</title>
    <link href="/2023/11/12/%E6%9D%82%E8%AE%B0/"/>
    <url>/2023/11/12/%E6%9D%82%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<ul><li><p>阿克琉斯值剑就是科幻小说</p></li><li><p>主人公和父亲置气，爬上了一棵树并发誓不下来，直到他垂垂老矣，一个热气球为了采集气象信息，抛下了一根锚，他看到这根从热气球上垂下来的绳子，就扑上去抓住它，最后随着热气球飞走了。</p></li><li><p>记录一个地狱笑话</p><ul><li>Level 1 Installing Arch While Parents are Arguing</li><li>Level 2 Install Gentoo in family court</li><li>Level 3 Open bsd in the orphanage</li><li>Level 4 Temple OS in the depression clinic</li></ul></li><li><p>日本女排吉村志惠</p></li><li><p>美是生活，你没办法去越过它去创造一种你没见识过的生活</p></li><li><p>叙事就是会在人的身上留下痕迹，时间不到痕迹不够重</p></li><li><p>很急的音乐配上慢动作的画面就很有冲击力</p></li><li><p>管乐开场，抒情的地方用弦乐，就非常大场面，温柔的瞬间，勇敢的地方，运动会的感觉</p></li><li><p>教堂的钟声，号角，风笛，史诗感就出现了</p></li><li><p>钟声加合唱加交响乐</p></li><li><p>转调就是一下子从一个调就转到另一个调</p></li><li><p>小提琴＋钢琴算是孤独组合了</p></li><li><p>鼓点代表前进的步伐，表示一直在推进的行军，很有压迫感</p></li><li><p>塔防特别考验音乐，因为大部分时间都在看着</p></li><li><p>ToB目标用户是企业的业务，一般分为传统软件和SaaS两种模式；ToC个人相关的业务，如常用的地图App，聊天App等</p></li><li><p>void函数的返回值可以写成return;</p></li><li><p>同期声——在拍摄现场录制的声音</p></li><li><p>在超能力战斗漫画变得这么复杂的今天，波纹那种很素的超能力战斗故事写的精彩了反而很有趣</p></li><li><p>写个公路片挺有意思的啊</p></li><li><p>《游戏玩家》</p></li><li><p>《如何不切实际地解决实际问题》</p></li><li><p>《我是遗物整理师》</p></li><li><p>《跟动物交换身体》</p></li><li><p>《蚂蚁的故事》</p></li><li><p>《非官方修炼手册》</p></li><li><p>云南玉溪市抚仙湖 在开发之前水特别清澈，湖中心向下看可见30米，在这个环境里边给我一根网线，我能统治世界</p></li><li><p>只要中国人还有好奇心，科幻就有生命</p></li><li><p>《玫瑰与蠕虫》</p></li><li><p>《Children of Death Earth》太空类游戏</p></li><li><p>清水洁</p></li><li><p>《桶川跟踪狂杀人事件》《足利女童连续失踪事件》</p></li><li><p>拿可乐举例，在物质生活极为丰富的今天，它是一种稀缺资源吗？明显不是，那人类的猴子本能如何适应这种现状呢？在以前人们可以猴王有二十个，二百个桃子，普通猴子有一个桃子，但是现在，你再能喝你能喝一吨可乐吗？因此现代的猴王为了彰显自己比普通猴子的牛逼之处就会产生一些非常有意思的设定——我能消费混元无极镶金小龙虾，那我就比你吃普通小龙虾的猴子牛逼，再进一步是什么呢？我能消费别人的时间，那我就比普通猴子牛逼，因此出现了毫无意义仅为了消费别人时间的工作，最终能够掌握别人劳动时间的猴子就成了现代的猴王，肆意浪费他人的时间以证明自己存在的重要性</p></li><li><p>劳动价值理论不再被普通价值所熟悉，“象征地位的不再是生产力而是购买力”，时至今日，当人们提到“财富创造者”大家自动对应的是资本家而不是工人，因为工人身上人的标签已经被剥除了</p></li><li><p>在代码中直接写Write方法写log的方法不是一种太好的方法，因为A方法中有了一个B方法（写Log）的功能，为了实现这个功能应该使用特性</p></li><li><p>还是要和实践结合，记得巨详细的计算机网络笔记因为用不到所以忘得差不多了有点太闹心了</p></li><li><p>软件开发的开闭原则，对扩展开放，对修改封闭</p></li><li><p>每个主板上都有一个叫实时时钟的东西，精度其实并不很高，每天都会偏个几秒钟</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实用工具推荐</title>
    <link href="/2023/11/12/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"/>
    <url>/2023/11/12/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/</url>
    
    <content type="html"><![CDATA[<p>这个帖子用来分享一些我个人用过并评价相当不错的工具，网站和资源</p><h3 id="哔哩下载姬"><a href="#哔哩下载姬" class="headerlink" title="哔哩下载姬"></a><a href="https://github.com/leiurayer/downkyi">哔哩下载姬</a></h3><p>上附Github链接，可以批量下载和下载会员视频</p><h3 id="kaf-cli"><a href="#kaf-cli" class="headerlink" title="kaf-cli"></a><a href="https://github.com/ystyle/kaf-cli">kaf-cli</a></h3><p>上附加Github链接，这是一个将txt文本转成epub和mobi类文档的工具</p><h3 id="Tickeys"><a href="#Tickeys" class="headerlink" title="Tickeys"></a><a href="https://www.yingdev.com/projects/tickeys">Tickeys</a></h3><p>一个可以给打字添加音效的工具</p>]]></content>
    
    
    <categories>
      
      <category>分享</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>代码相关单词</title>
    <link href="/2023/11/12/%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3%E5%8D%95%E8%AF%8D/"/>
    <url>/2023/11/12/%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3%E5%8D%95%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<ul><li><p>approximate adj.大概的</p><ul><li>The approximate time required to complete the tutor is 25-30minutes</li></ul></li><li><p>execute v.执行</p><ul><li>execute command</li></ul></li><li><p>hint n.暗示，提示</p></li><li><p>prompt v.(计算机上)提示</p><ul><li>shell prompt shell提示</li></ul></li><li><p>If you have these steps memorized and confident</p><p>如果你已经记住这些步骤并有信心了</p></li><li><p>discard v.弃置，扔掉</p><ul><li><p>XX discards any changes you made</p><p>XX 会取消你对文本所作的任何改动</p></li></ul></li><li><p>combination n.结合体，组合</p></li><li><p>glitch n.小故障，失灵，短时脉冲波干扰</p></li><li><p>daemon n.守护进程，后台程序</p></li><li><p>prior adj.在先的，在前的，先前的，更重要的</p></li><li><p>prefix n.前缀</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单词</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim使用</title>
    <link href="/2023/11/12/Vim%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/11/12/Vim%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<ul><li><p>x键删除字符</p></li><li><p>dw删除整个单词</p><ul><li>d2w删除接下来的两个单词</li></ul></li><li><p>d$删除到行尾</p></li><li><p>w到下一个单词头</p></li><li><p>e到下一个单词尾</p></li><li><p>$到行尾</p></li><li><p>u撤回</p><ul><li>Ctrl+R反撤回</li></ul></li><li><p>0到行首，包括空格</p></li><li><p>^到行首，不包括空格</p></li><li><p>G到文本最好一行首</p></li><li><p>gg到文本首行</p></li><li><p>number motion执行几次行动</p><ul><li>38j向下移动38次</li></ul></li><li><p>dd删除一整行</p></li><li><p>p在光标处粘贴先前删除的文本</p></li><li><p>r以替换光标处的字符</p><ul><li>移动光标到第一个错误，键入r和要更正的字符</li></ul></li><li><p>ce删除直到单词末尾的内容并进入编辑模式</p><ul><li>cw删除整个单词并进入编辑模式</li><li>c$删除直到行末并进入编辑模式</li></ul></li><li><p>Ctrl+G显示你在文档中的位置</p></li><li><p>number+G前往第数字行</p></li><li><p>&#x2F;+搜索的单词</p><ul><li>向下搜索下一个单词n</li><li>向上搜索下一个单词N</li></ul></li><li><p>？+向上搜索的单词</p></li><li><p>Ctrl+O回到之前的那个位置，Ctrl+I前进位置</p></li><li><p>%将光标移动到它对应的匹配括号上</p></li><li><p>:&#x2F;s&#x2F;old&#x2F;new&#x2F;g将一行中的old替换为new</p></li><li><p>:&#x2F;#,#s&#x2F;old&#x2F;new&#x2F;g其中#,#是更改的行号范围</p></li><li><p>:&#x2F;%s&#x2F;old&#x2F;new&#x2F;g更改全文件的old内容</p></li><li><p>:&#x2F;%s&#x2F;old&#x2F;new&#x2F;gc更改全文及的old内容，并给出替换与否的提示</p></li><li><p>:! 执行外部命令，如:!ls或者:!dir</p></li><li><p>:w Filename.**保存文件并更改文件名或者类型</p></li><li><p>v按住以选择</p></li><li><p>o光标下插入新的一行</p></li><li><p>O光标上插入新的一行</p></li><li><p>A在一句的末尾开始插入内容</p></li><li><p>R插入不止一句内容</p></li><li><p>y复制用v的选中内容，用p粘贴内容</p></li><li><p>选中后U将内容变成大写，u将内容变成小写，~将大小翻转</p></li><li><p>:e ~&#x2F;.vimrc 编辑Unix依赖</p></li><li><p>:e $VIM&#x2F;_vimrc编辑Windows依赖</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pacman命令</title>
    <link href="/2023/11/12/pacman%E5%91%BD%E4%BB%A4/"/>
    <url>/2023/11/12/pacman%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S [软件名]<br>sudo pacman -Sy <span class="hljs-comment">#更新Arch软件源</span><br>sudo pacman -Syy <span class="hljs-comment">#强制更新Arch软件源</span><br>sudo pacman -Su <span class="hljs-comment">#更新软件</span><br>sudo pcaman -Syu <span class="hljs-comment">#更新软件源并更新软件</span><br>sudo pacman -Syyu <span class="hljs-comment">#强制更新软件源并更新软件</span><br>sudo pacman -Ss vim <span class="hljs-comment">#查询软件源里所有名字里带vim的软件</span><br>sudo pacman -Ss ^vim <span class="hljs-comment">#支持正则表达式，查询所有以vim开头的软件</span><br>sudo pacman -R [软件名] <span class="hljs-comment">#卸载软件</span><br>sudo pacman -Rns [软件名] <span class="hljs-comment">#彻底卸载软件</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux文件系统</title>
    <link href="/2023/11/12/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/11/12/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>Linux</p><h4 id="文件系统的组成"><a href="#文件系统的组成" class="headerlink" title="文件系统的组成"></a>文件系统的组成</h4><ul><li><p><strong>一切皆文件</strong></p><p>不仅普通的文件和目录，包括块设备、管道，socket等一切都交给文件系统管理。</p></li></ul><p>​Linux文件系统会为每个文件分配两个数据结构<strong>索引节点(index node)</strong> 和 **目录项(directory entry)**，用来记录文件的元信息和目录层次结构</p><ul><li><p><strong>索引节点（inode）</strong></p><p>用来记录文件的元信息，包括inode编号、文件大小、访问权限、创建时间、数据在磁盘的位置等。索引节点是文件的唯一标识，且和文件一一对应，也同样会被储存，占用磁盘空间，可以用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -i<br></code></pre></td></tr></table></figure><p>来查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">30978 network             30937 security             7861 bluetooth<br></code></pre></td></tr></table></figure></li><li><p><strong>目录项（dentry）</strong></p><p>用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。多个目录项管理起来就会形成目录结构，但它与索引节点不同的是，目录项是由内核维护的一个数据结构，不会存在磁盘里，而是缓存在内存。</p></li></ul><p>​由于索引节点唯一标识一个文件，而目录项记录着文件名，所以目录项和索引节点的关系是多对一，</p><p>​<strong>目录和目录项不是一个东西</strong>，目录是个文件，持久化存储在磁盘里，而目录项是内核一个数据结构，缓存在内存里。</p><p>​如果查询目录频繁从磁盘里读取，效率会很低，因此内核会把已经读过的目录用目录项这个数据结构缓存在内存，然后下次读到相同的目录之后直接从内存读就可以，大为提高了文件系统的效率。</p><p>​目录项这个数据结构不只是表示目录，也可以表示文件。</p><p>​磁盘读写的最小单位是扇区，扇区的大小只有512B，文件系统将多个扇区组成一个逻辑快，每次读写的最小单位是逻辑块（数据块），Linux中的逻辑块大小为4KB，一次性读取8个扇区</p><h4 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h4><h4 id="文件的实用"><a href="#文件的实用" class="headerlink" title="文件的实用"></a>文件的实用</h4><h4 id="文件的储存"><a href="#文件的储存" class="headerlink" title="文件的储存"></a>文件的储存</h4><ul><li>连续空间储存</li><li>非连续空间储存</li></ul><h4 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h4><ul><li>空闲表法</li><li>空闲链表法</li><li>位图法</li></ul><h4 id="文件系统的结构"><a href="#文件系统的结构" class="headerlink" title="文件系统的结构"></a>文件系统的结构</h4><h3 id="目录的储存"><a href="#目录的储存" class="headerlink" title="目录的储存"></a>目录的储存</h3><ul><li>列表</li><li>哈希表</li></ul><h3 id="软链接和硬链接"><a href="#软链接和硬链接" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h3><h3 id="文件I-O"><a href="#文件I-O" class="headerlink" title="文件I&#x2F;O"></a>文件I&#x2F;O</h3><ul><li><p>缓冲与非缓冲I&#x2F;O</p></li><li><p>直接与非直接I&#x2F;O</p></li><li><p>阻塞与非阻塞I&#x2F;O VS 同步与异步I&#x2F;O</p></li><li><p>bin<br><strong>binaries n.二进制</strong><br>command binaries n.二进制命令文件<br>cat-concatenate v.连接 adj.连接的</p><p>可以用可以用sudo cp ls homovexillues将ls的二进制执行文件复制到homovexillues，然后用sudo rm -r 删除ls命令，</p></li><li><p>sbin</p></li><li><p>usr</p><ul><li>bin</li><li>include</li><li>lib</li><li>sbin</li></ul></li><li><p>home</p></li><li><p>root</p></li><li><p>etc</p></li><li><p>dev</p></li><li><p>media</p></li><li><p>mnt</p></li><li><p>boot</p></li><li><p>lib</p></li><li><p>var</p><ul><li>cache</li><li>log</li><li>spool</li><li>tmp</li></ul></li></ul><p><em>Ps.文章内容参考自<a href="https://xiaolincoding.com/os/6_file_system/file_system.html#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90">7.1 文件系统全家桶 |小林coding</a>，侵删。</em></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2077V震天同人随笔</title>
    <link href="/2023/11/12/2077V%E9%9C%87%E5%A4%A9%E5%90%8C%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    <url>/2023/11/12/2077V%E9%9C%87%E5%A4%A9%E5%90%8C%E4%BA%BA%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<p>“无名小卒？还是名扬天下？”</p><p>200多斤的大黑胖子在黑色高级轿车里对着面前的佣兵问出了这个问题，事实上，他现在心里已经有点发毛了。</p><p>他旁边坐着的这个人从刚才上车开始就一言不发，脸上始终挂着那“爽朗”的露出所有牙齿的微笑，只见这人：</p><p>身躯凛凛，脸板堂堂。一双歧路司光射寒星，两弯眉浑如刷漆。胸板横阔，有万夫难敌之威风；骨健筋强，似亚当重锤临座上；如同天上降魔主，真是人间太岁神。</p><p>德克斯特从V上车开始就开始和V絮絮叨叨，无非是套话吹逼之类，但V就好像全没听见一样，一双眼睛幽光莹莹，隔着黑色高级轿车的防弹玻璃盯着沿途的一台台自动贩卖机，所有自动贩卖机但凡被他一看，顿时就哗哗地落下大量的小商品来，引得周围的流浪汉和市民一阵哄抢。要是有看到的帮派份子，更是直接浑身抽抽着倒在地上，眼看是不活了。当然，这一切是在车里还戴着墨镜的德克斯特和他的那个保镖没有注意到的。</p><p>听到德克斯特此言，V好像才终于将注意力放在了这个大黑胖子身上一样，脸上还是那个“和善”的笑容，就问了一句话：</p><p>“说，去哪儿，杀谁”</p><p>德克斯特心里已经开始发慌了，心说自己这莫不是招来了个赛博精神病，但是为了不刺激眼前的这个疯子，他只能绷着一种比较淡定的语气陈述了他所知道的情报，并掏出了数据芯片，谁成想这芯片刚从兜里掏出来就消失了，耳边传来的还有“砰”的一声，他赶紧抱头缩起身子，过了好一会儿，他才意识到自己身边的那个疯子消失了。</p><p>活见了鬼了！这他妈可是一辆在路上全速行驶的轿车里！</p><p>“哔”</p><p>他接收到了一条新的语音消息，打开一看，正是刚才那个据称“V”的佣兵给他发过来的。</p><p>“回家等电话！有事通知你！”</p><p>他回到他的安全屋好久之后才反应过来，那个疯子是看到了自己拿出数据芯片之后直接开启了义体“基安威斯坦”从自己手中夺走了数据芯片，然后打开车门跳出去了的动静。</p><p>“妈的，这个疯子，就不能…”话还没说完，他的通讯器又传来了“哔”的一声。</p><p>“又怎么了”他烦躁的打开聊天界面，今天雇了个疯子佣兵的事已经让他够闹心的了，如果这时候还有些什么别的破事儿……</p><p>结果是那个叫V的家伙发来的一个视频文件。</p><p>“草？他什么时候黑的我？”</p><p>大黑胖子突然发现自己通讯录里对那个佣兵的备注不知道什么时候被改成了“&gt;&gt;&gt;大名鼎鼎的V&lt;&lt;&lt;”，甚至还加上了符号特效。</p><p>“哈，大名鼎鼎…”大黑胖子不屑的冷笑着，点开了视频。</p><p>视频内容是刚才见到的那个佣兵V，脸上挂着那个有些神经质的露全齿微笑，左手搂着那个叫梅瑞斯托特的公司女的，右手搂着杰克小子，脚下还踩着一个军用科技的箱子，摆着一个拍照常用的老土pose，身边都是军用科技的特工在为他们鼓掌，身后是烧着熊熊大火正在疯狂冒烟的全食品工厂。</p><p>由于视频内容过于劲爆，德克斯特的大脑短路了将近一分钟才缓过来，然后他的第一反应就是特效。</p><p>“都，都是假的，吓不倒我的”他将视频转发给了自己的手下，让他帮忙检查一下视频的编辑痕迹，结果手下的消息窗口显示了将近一分钟的“对方正在输入中”，然后发过来一句话“老大，看新闻。”</p><p>“搅什么了？不知所谓的小子？”德克斯特这么想着，但还是打开了电视，一般情况下他都是一个很听劝的人，正所谓听人劝，吃饱饭嘛，从他的体型就看的出，他经常听人劝。</p><p>新闻54台在播报一条重要新闻，今天晚间，漩涡帮被除名了，一个不剩的全都杀了个干净，而这笔功劳被算在了那个叫梅瑞斯托特的女人头上，剩下的就是一些车轱辘话，展现了军用科技的权威啊，打破平衡啊，公司战争的序曲啊之类的。</p><p>不过这些屁话已经穿不进德克斯特的耳朵里了，现在他脑子里只有一件事——“我特么这是招了个什么活阎王啊。”</p>]]></content>
    
    
    <categories>
      
      <category>小说</category>
      
    </categories>
    
    
    <tags>
      
      <tag>赛博朋克</tag>
      
      <tag>2077</tag>
      
      <tag>同人</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
